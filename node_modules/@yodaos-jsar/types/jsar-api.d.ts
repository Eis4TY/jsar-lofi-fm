declare module '@yodaos-jsar/dom/bindings/noise/index' {
  export function loadNoise(): Promise<void>;
  export * from "@yodaos-jsar/dom/bindings/noise/pkg/noise_binding/index";

}
declare module '@yodaos-jsar/dom/bindings/noise/pkg/noise_binding_bg_wasm' {
  const _default: Uint8Array;
  export default _default;

}
declare module '@yodaos-jsar/dom/bindings/taffy/index' {
  export function loadTaffy(): Promise<void>;
  export * from "@yodaos-jsar/dom/bindings/taffy/pkg/taffy_binding/index";

}
declare module '@yodaos-jsar/dom/bindings/taffy/pkg/taffy_binding_bg_wasm' {
  const _default: Uint8Array;
  export default _default;

}
declare module '@yodaos-jsar/dom/src/agent/DeviceMemory' {
  import { NavigatorImpl } from '@yodaos-jsar/dom/src/agent/navigator';
  export default interface DeviceMemoryImpl extends NavigatorImpl {
  }
  export default class DeviceMemoryImpl {
      get deviceMemory(): number;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/api' {
  import { Event } from 'cockatiel';
  /**
   * Primitive definition of a CDP domain.
   */
  export interface IDomain {
      requests: {
          [key: string]: IRequestDef<unknown, unknown>;
      };
      events: {
          [key: string]: IEventDef<unknown>;
      };
  }
  export interface IRequestDef<TParams, TResponse> {
      params: TParams;
      result: TResponse;
  }
  export interface IEventDef<TParams> {
      params: TParams;
  }
  type DomainEventHandlers<TDomain extends IDomain> = {
      [TKey in keyof TDomain['requests']]: Record<string, never> extends TDomain['requests'][TKey]['params'] ? () => Promise<TDomain['requests'][TKey]['result']> : (arg: TDomain['requests'][TKey]['params']) => Promise<TDomain['requests'][TKey]['result']>;
  } & {
      [TKey in keyof TDomain['events'] as `on${Capitalize<string & TKey>}`]: Event<TDomain['events'][TKey]['params']>;
  };
  /**
   * A generic type that creates Event handler methods for a map of CDP domains.
   */
  export type CdpClientHandlers<TDomains> = {
      [TKey in keyof TDomains]: TDomains[TKey] extends IDomain ? DomainEventHandlers<TDomains[TKey]> : never;
  };
  /**
   * Type for a handler for an API method.
   */
  export type CdpMethodHandlerFunction<TDomains, TParams, TResponse> = (client: CdpServerEventDispatcher<TDomains>, arg: TParams) => Promise<TResponse>;
  /**
   * A genmeric type that creates method handlers for a server
   * implementing the given CDP domain.
   */
  export type CdpServerMethodHandlers<TDomains> = {
      [TDomainName in keyof TDomains]: TDomains[TDomainName] extends IDomain ? {
          [TKey in keyof TDomains[TDomainName]['requests']]: CdpMethodHandlerFunction<TDomains, TDomains[TDomainName]['requests'][TKey]['params'], TDomains[TDomainName]['requests'][TKey]['result']>;
      } : never;
  } & {
      unknown?(client: CdpServerEventDispatcher<TDomains>, method: string, params: unknown): Promise<unknown | undefined>;
  };
  /**
   * A generic type that creates event calls for server implementing
   * the given CDP domain.
   */
  export type CdpServerEventDispatcher<TDomains> = {
      [TDomainName in keyof TDomains]: TDomains[TDomainName] extends IDomain ? {
          [TKey in keyof TDomains[TDomainName]['events']]: (arg: TDomains[TDomainName]['events'][TKey]['params']) => void;
      } : never;
  };
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/cdp/builder/main' {
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/cdp/builder/pdl-types' {
  export interface Definition {
      domains: ReadonlyArray<Domain>;
      version: {
          major: string;
          minor: string;
      };
  }
  export interface Version {
      major: string;
      minor: string;
  }
  export interface Command {
      name: string;
      description: string;
      experimental?: true;
      deprecated?: boolean;
      parameters?: ReadonlyArray<DataType<false>>;
      returns?: ReadonlyArray<DataType<false>>;
  }
  export interface Domain {
      domain: string;
      experimental: boolean;
      deprecated?: boolean;
      dependencies?: ReadonlyArray<string>;
      types?: ReadonlyArray<DataType<true>>;
      commands: ReadonlyArray<Command>;
      events: ReadonlyArray<Event>;
  }
  export type DataType<WithId> = RefType<WithId> | ObjectType<WithId> | StringType<WithId> | ArrayType<WithId>;
  export interface Event {
      name: string;
      description: string;
      parameters?: ReadonlyArray<DataType<false>>;
      deprecated?: true;
      experimental?: true;
  }
  export interface IDataType<WithId> {
      name: WithId extends true ? never : string;
      id: WithId extends false ? never : string;
      description?: string;
      optional?: true;
      deprecated?: true;
      experimental?: true;
  }
  export interface RefType<WithId> extends IDataType<WithId> {
      type: '';
      $ref: string;
  }
  export interface ObjectType<WithId> extends IDataType<WithId> {
      type: 'object';
      properties: ReadonlyArray<DataType<false>>;
  }
  export interface StringType<WithId> extends IDataType<WithId> {
      type: 'string';
      enum?: ReadonlyArray<string>;
  }
  export interface ArrayType<WithId> extends IDataType<WithId> {
      type: 'array';
      items: DataType<false>;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/builder/pdl2json' {
  export function pdlUrlToJson(pdlUrl: string): Promise<any>;

}
declare module '@yodaos-jsar/dom/src/agent/cdp/builder/pdl2typescript' {
  import * as PDL from '@yodaos-jsar/dom/src/agent/cdp/builder/pdl-types';
  export interface IDefinitionRequest {
      name: string;
      definition: PDL.Definition;
  }
  export const pdlToTypeScript: (definitions?: IDefinitionRequest[]) => string;

}
declare module '@yodaos-jsar/dom/src/agent/cdp/cancellation' {
  import { Event } from 'cockatiel';
  export interface ICancellationToken {
      readonly onCancellationRequested: Event<void>;
      readonly isCancellationRequested: boolean;
  }
  /**
   * Returns the result of the promise if it resolves before the cancellation
   * is requested. Otherwise, throws a TaskCancelledError.
   */
  export function timeoutPromise<T>(promise: Promise<T>, cancellation: ICancellationToken, message?: string): Promise<T>;

}
declare module '@yodaos-jsar/dom/src/agent/cdp/cdp-implementation' {
  import type { BaseWindowImpl, WindowOrDOMInit } from '@yodaos-jsar/dom/src/agent/window';
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { ClientConnection } from '@yodaos-jsar/dom/src/agent/cdp/connection';
  import { CdpBrowser, CdpV8 } from '@yodaos-jsar/dom/src/agent/cdp/definitions';
  import type { ITransport } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  import { ISerializer } from '@yodaos-jsar/dom/src/agent/cdp/serializer/index';
  import type { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  namespace CdpJSAR {
      interface Domains {
          Log: CdpBrowser.Domains['Log'];
          DOM: CdpBrowser.Domains['DOM'];
          SpatialDOM: SpatialDOMApi;
      }
      interface SpatialDOMApi {
          requests: {
              describeElement: {
                  params: SpatialElement.DescribeElementParams;
                  result: SpatialElement.DescribeElementResult;
              };
              highlightElement: {
                  params: SpatialElement.HighlightElementParams;
                  result: SpatialElement.HighlightElementResult;
              };
              unhighlightElement: {
                  params: SpatialElement.UnhighlightElementParams;
                  result: SpatialElement.UnhighlightElementResult;
              };
              unhighlightElements: {
                  params: SpatialElement.UnhighlightElementsParams;
                  result: SpatialElement.UnhighlightElementsResult;
              };
              setTransform: {
                  params: SpatialElement.SetTransformParams;
                  result: SpatialElement.SetTransformResult;
              };
              displayMeshNormals: {
                  params: SpatialElement.DisplayMeshNormalsParams;
                  result: SpatialElement.DisplayMeshNormalsResult;
              };
              displayVertexNormals: {
                  params: SpatialElement.DisplayVertexNormalsParams;
                  result: SpatialElement.DisplayVertexNormalsResult;
              };
              displayMeshBones: {
                  params: SpatialElement.DisplayMeshBonesParams;
                  result: SpatialElement.DisplayMeshBonesResult;
              };
              renderWireframeOverMesh: {
                  params: SpatialElement.RenderWireframeOverMeshParams;
                  result: SpatialElement.RenderWireframeOverMeshResult;
              };
          };
          events: {};
      }
      namespace SpatialElement {
          type Color3 = [number, number, number];
          type Color4 = [number, number, number, number];
          type Vector3 = {
              x: number;
              y: number;
              z: number;
          };
          type Quaternion = {
              x: number;
              y: number;
              z: number;
              w: number;
          };
          type Texture = {
              width: number;
              height: number;
          };
          type SpatialType = string;
          type SpatialTransform = {
              position: Vector3;
              rotation: Quaternion;
              scaling: Vector3;
          };
          type MeshDescriptor = {
              vertices: number;
              faces: number;
              hasNormals?: boolean;
              hasTangents?: boolean;
              hasColors?: boolean;
              hasUv0?: boolean;
              hasUv1?: boolean;
              hasUv2?: boolean;
              hasUv3?: boolean;
              hasUv4?: boolean;
          };
          type MaterialDescriptor = {
              type: string;
              name: string;
              diffuseColor?: Color3;
              diffuseTexture?: Texture;
              ambientColor?: Color3;
              ambientTexture?: Texture;
              specularColor?: Color3;
              specularTexture?: Texture;
              emissiveColor?: Color3;
              emissiveTexture?: Texture;
              albedoColor?: Color3;
              albedoTexture?: Texture;
              metallic?: number;
              metallicRoughnessTexture?: Texture;
              roughness?: number;
          };
          interface Node {
              nodeId: CdpBrowser.DOM.NodeId;
              parentId?: CdpBrowser.DOM.NodeId;
              type: SpatialType;
              transform?: SpatialTransform;
              mesh?: MeshDescriptor;
              material?: MaterialDescriptor;
          }
          interface DescribeElementParams {
              nodeId: CdpBrowser.DOM.NodeId;
              depth?: CdpBrowser.integer;
          }
          interface DescribeElementResult {
              node: SpatialElement.Node;
          }
          interface HighlightElementParams {
              nodeId: CdpBrowser.DOM.NodeId;
          }
          interface HighlightElementResult {
          }
          interface SetTransformParams {
              nodeId: CdpBrowser.DOM.NodeId;
              transform: SpatialTransform;
          }
          interface UnhighlightElementParams {
              nodeId: CdpBrowser.DOM.NodeId;
          }
          interface UnhighlightElementResult {
          }
          interface UnhighlightElementsParams {
          }
          interface UnhighlightElementsResult {
          }
          interface SetTransformResult {
          }
          interface DisplayMeshNormalsParams {
              nodeId: CdpBrowser.DOM.NodeId;
              display: boolean;
          }
          interface DisplayMeshNormalsResult {
          }
          interface DisplayVertexNormalsParams {
              nodeId: CdpBrowser.DOM.NodeId;
              display: boolean;
          }
          interface DisplayVertexNormalsResult {
          }
          interface DisplayMeshBonesParams {
              nodeId: CdpBrowser.DOM.NodeId;
              display: boolean;
          }
          interface DisplayMeshBonesResult {
          }
          interface RenderWireframeOverMeshParams {
              nodeId: CdpBrowser.DOM.NodeId;
              display: boolean;
          }
          interface RenderWireframeOverMeshResult {
          }
      }
  }
  export function createRemoteClient(transport: ITransport, serializer?: ISerializer): ClientConnection<CdpJSAR.Domains>;
  export class CdpServerImplementation {
      private _transport;
      private _window;
      private _init;
      private _server;
      private _document;
      private _isLogEnabled;
      private _domNodes;
      private _highlightedMeshes;
      get Log(): {
          clear: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.Log.ClearParams, CdpBrowser.Log.ClearResult>;
          disable: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.Log.DisableParams, CdpBrowser.Log.DisableResult>;
          enable: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.Log.EnableParams, CdpBrowser.Log.EnableResult>;
          startViolationsReport: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.Log.StartViolationsReportParams, CdpBrowser.Log.StartViolationsReportResult>;
          stopViolationsReport: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.Log.StopViolationsReportParams, CdpBrowser.Log.StopViolationsReportResult>;
      };
      get DOM(): {
          collectClassNamesFromSubtree: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.CollectClassNamesFromSubtreeParams, CdpBrowser.DOM.CollectClassNamesFromSubtreeResult>;
          copyTo: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.CopyToParams, CdpBrowser.DOM.CopyToResult>;
          describeNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.DescribeNodeParams, CdpBrowser.DOM.DescribeNodeResult>;
          scrollIntoViewIfNeeded: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.ScrollIntoViewIfNeededParams, CdpBrowser.DOM.ScrollIntoViewIfNeededResult>;
          disable: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.DisableParams, CdpBrowser.DOM.DisableResult>;
          discardSearchResults: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.DiscardSearchResultsParams, CdpBrowser.DOM.DiscardSearchResultsResult>;
          enable: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.EnableParams, CdpBrowser.DOM.EnableResult>;
          focus: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.FocusParams, CdpBrowser.DOM.FocusResult>;
          getAttributes: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetAttributesParams, CdpBrowser.DOM.GetAttributesResult>;
          getBoxModel: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetBoxModelParams, CdpBrowser.DOM.GetBoxModelResult>;
          getContentQuads: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetContentQuadsParams, CdpBrowser.DOM.GetContentQuadsResult>;
          getDocument: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetDocumentParams, CdpBrowser.DOM.GetDocumentResult>;
          getFlattenedDocument: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetFlattenedDocumentParams, CdpBrowser.DOM.GetFlattenedDocumentResult>;
          getNodesForSubtreeByStyle: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetNodesForSubtreeByStyleParams, CdpBrowser.DOM.GetNodesForSubtreeByStyleResult>;
          getNodeForLocation: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetNodeForLocationParams, CdpBrowser.DOM.GetNodeForLocationResult>;
          getOuterHTML: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetOuterHTMLParams, CdpBrowser.DOM.GetOuterHTMLResult>;
          getRelayoutBoundary: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetRelayoutBoundaryParams, CdpBrowser.DOM.GetRelayoutBoundaryResult>;
          getSearchResults: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetSearchResultsParams, CdpBrowser.DOM.GetSearchResultsResult>;
          hideHighlight: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.HideHighlightParams, CdpBrowser.DOM.HideHighlightResult>;
          highlightNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.HighlightNodeParams, CdpBrowser.DOM.HighlightNodeResult>;
          highlightRect: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.HighlightRectParams, CdpBrowser.DOM.HighlightRectResult>;
          markUndoableState: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.MarkUndoableStateParams, CdpBrowser.DOM.MarkUndoableStateResult>;
          moveTo: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.MoveToParams, CdpBrowser.DOM.MoveToResult>;
          performSearch: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.PerformSearchParams, CdpBrowser.DOM.PerformSearchResult>;
          pushNodeByPathToFrontend: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.PushNodeByPathToFrontendParams, CdpBrowser.DOM.PushNodeByPathToFrontendResult>;
          pushNodesByBackendIdsToFrontend: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.PushNodesByBackendIdsToFrontendParams, CdpBrowser.DOM.PushNodesByBackendIdsToFrontendResult>;
          querySelector: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.QuerySelectorParams, CdpBrowser.DOM.QuerySelectorResult>;
          querySelectorAll: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.QuerySelectorAllParams, CdpBrowser.DOM.QuerySelectorAllResult>;
          getTopLayerElements: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetTopLayerElementsParams, CdpBrowser.DOM.GetTopLayerElementsResult>;
          redo: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.RedoParams, CdpBrowser.DOM.RedoResult>;
          removeAttribute: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.RemoveAttributeParams, CdpBrowser.DOM.RemoveAttributeResult>;
          removeNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.RemoveNodeParams, CdpBrowser.DOM.RemoveNodeResult>;
          requestChildNodes: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.RequestChildNodesParams, CdpBrowser.DOM.RequestChildNodesResult>;
          requestNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.RequestNodeParams, CdpBrowser.DOM.RequestNodeResult>;
          resolveNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.ResolveNodeParams, CdpBrowser.DOM.ResolveNodeResult>;
          setAttributeValue: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetAttributeValueParams, CdpBrowser.DOM.SetAttributeValueResult>;
          setAttributesAsText: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetAttributesAsTextParams, CdpBrowser.DOM.SetAttributesAsTextResult>;
          setFileInputFiles: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetFileInputFilesParams, CdpBrowser.DOM.SetFileInputFilesResult>;
          setNodeStackTracesEnabled: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetNodeStackTracesEnabledParams, CdpBrowser.DOM.SetNodeStackTracesEnabledResult>;
          getNodeStackTraces: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetNodeStackTracesParams, CdpBrowser.DOM.GetNodeStackTracesResult>;
          getFileInfo: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetFileInfoParams, CdpBrowser.DOM.GetFileInfoResult>;
          setInspectedNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetInspectedNodeParams, CdpBrowser.DOM.SetInspectedNodeResult>;
          setNodeName: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetNodeNameParams, CdpBrowser.DOM.SetNodeNameResult>;
          setNodeValue: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetNodeValueParams, CdpBrowser.DOM.SetNodeValueResult>;
          setOuterHTML: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.SetOuterHTMLParams, CdpBrowser.DOM.SetOuterHTMLResult>;
          undo: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.UndoParams, CdpBrowser.DOM.UndoResult>;
          getFrameOwner: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetFrameOwnerParams, CdpBrowser.DOM.GetFrameOwnerResult>;
          getContainerForNode: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetContainerForNodeParams, CdpBrowser.DOM.GetContainerForNodeResult>;
          getQueryingDescendantsForContainer: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpBrowser.DOM.GetQueryingDescendantsForContainerParams, CdpBrowser.DOM.GetQueryingDescendantsForContainerResult>;
      };
      get SpatialDOM(): {
          describeElement: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.DescribeElementParams, CdpJSAR.SpatialElement.DescribeElementResult>;
          highlightElement: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.HighlightElementParams, CdpJSAR.SpatialElement.HighlightElementResult>;
          unhighlightElement: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.UnhighlightElementParams, CdpJSAR.SpatialElement.UnhighlightElementResult>;
          unhighlightElements: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.UnhighlightElementsParams, CdpJSAR.SpatialElement.UnhighlightElementsResult>;
          setTransform: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.SetTransformParams, CdpJSAR.SpatialElement.SetTransformResult>;
          displayMeshNormals: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.DisplayMeshNormalsParams, CdpJSAR.SpatialElement.DisplayMeshNormalsResult>;
          displayVertexNormals: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.DisplayVertexNormalsParams, CdpJSAR.SpatialElement.DisplayVertexNormalsResult>;
          displayMeshBones: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.DisplayMeshBonesParams, CdpJSAR.SpatialElement.DisplayMeshBonesResult>;
          renderWireframeOverMesh: import("@yodaos-jsar/dom/src/agent/cdp/api").CdpMethodHandlerFunction<CdpJSAR.Domains, CdpJSAR.SpatialElement.RenderWireframeOverMeshParams, CdpJSAR.SpatialElement.RenderWireframeOverMeshResult>;
      };
      constructor(_transport: ITransport, _window: BaseWindowImpl, _init: WindowOrDOMInit<NativeDocument>['devtools']);
      get rootSession(): import("@yodaos-jsar/dom/src/agent/cdp/server").ServerCdpSession<CdpJSAR.Domains>;
      set document(_document: SpatialDocumentImpl);
      addNode(node: NodeImpl): void;
      removeNode(node: NodeImpl): void;
      serializeNode(node: NodeImpl, depth?: number): CdpBrowser.DOM.Node;
      private _getValueSubtype;
      private _createPropertyPreview;
      createRemoteObject(value: any): CdpV8.Runtime.RemoteObject;
      writeLogEntry(level: 'verbose' | 'info' | 'warning' | 'error', text: any, args: any[], source?: 'javascript' | 'network' | 'appcache' | 'security' | 'other', url?: string): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol' {
  export namespace CdpProtocol {
      interface ICommand {
          id?: number;
          method: string;
          params: unknown;
          sessionId?: string;
      }
      interface IError {
          id: number;
          error: {
              code: number;
              message: string;
          };
          sessionId?: string;
      }
      interface ISuccess {
          id: number;
          result: unknown;
          sessionId?: string;
      }
      type Message = ICommand | ISuccess | IError;
      const isCommand: (message: Message) => message is ICommand;
      const isResponse: (message: Message) => message is IError | ISuccess;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/cdp-session' {
  import { IDisposable } from 'cockatiel';
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { Connection, ConnectionState } from '@yodaos-jsar/dom/src/agent/cdp/connection';
  /**
   * Base CDP session that the client and server extend.
   * @internal
   */
  export abstract class CdpSession implements IDisposable {
      readonly sessionId: string | undefined;
      private readonly closeEmitter;
      protected readonly disposables: IDisposable[];
      protected connection: {
          state: ConnectionState.Open;
          object: Connection<CdpSession>;
      } | {
          state: ConnectionState.Closed;
          cause: Error | undefined;
      };
      /**
       * Event that fires when the transport is disconnected, or when the
       * session is manually disposed of. If it was the result of a transport
       * error, the error is included.
       */
      readonly onDidClose: import("cockatiel").Event<Error>;
      /**
       * @returns true if the session or underlying connection is closed
       */
      get closed(): boolean;
      constructor(connection: Connection<CdpSession>, sessionId: string | undefined);
      /**
       * @inheritdoc
       */
      dispose(): void;
      /**
       * Handles an incoming message. Called by the connection.
       */
      abstract injectMessage(object: CdpProtocol.Message): void;
      private disposeSelf;
      protected abstract disposeInner(cause: Error | undefined): void;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/client' {
  import { Event } from 'cockatiel';
  import { CdpClientHandlers } from '@yodaos-jsar/dom/src/agent/cdp/api';
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { CdpSession } from '@yodaos-jsar/dom/src/agent/cdp/cdp-session';
  /**
   * Turns on capturing of stack traces when CDP requests are issued.
   * This is useful for debugging, but has a performance overhead.
   */
  export function captureCdpStackTraces(capture?: boolean): void;
  /**
   * A CDP session that has methods used for consuming events from a client.
   */
  export class ClientCdpSession<TDomains> extends CdpSession {
      private readonly callbacks;
      private readonly eventEmitter;
      private pauseQueue?;
      /**
       * Emitter that fires whenever an event is received. Method replies
       * are not emitted here.
       *
       * For a more specific, typed set of handlers, use the {@link api} property.
       */
      readonly onDidReceiveEvent: Event<CdpProtocol.ICommand>;
      /**
       * Typed handler for receiving events and calling methods.
       */
      readonly api: CdpClientHandlers<TDomains>;
      /**
       * Pauses the processing of messages for the connection.
       */
      pause(): void;
      /**
       * Resumes the processing of messages for the connection.
       */
      resume(): void;
      /**
       * Sends a request to CDP, returning its untyped result.
       */
      request(method: string, params?: Record<string, unknown>): Promise<unknown>;
      /**
       * @override
       */
      injectMessage(object: CdpProtocol.Message): void;
      protected disposeInner(cause: Error | undefined): void;
      private processResponse;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/connection' {
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { CdpSession } from '@yodaos-jsar/dom/src/agent/cdp/cdp-session';
  import { ClientCdpSession } from '@yodaos-jsar/dom/src/agent/cdp/client';
  import { CdpBrowser, CdpV8 } from '@yodaos-jsar/dom/src/agent/cdp/definitions';
  import { ISerializer } from '@yodaos-jsar/dom/src/agent/cdp/serializer/index';
  import { ServerCdpSession } from '@yodaos-jsar/dom/src/agent/cdp/server';
  import { ITransport } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  type SessionCtor<T extends CdpSession> = {
      new (connection: Connection<CdpSession>, sessionId: string | undefined): T;
  };
  export type ClientConnection<TDomains> = Connection<ClientCdpSession<TDomains>>;
  export type ServerConnection<TDomains> = Connection<ServerCdpSession<TDomains>>;
  export class Connection<T extends CdpSession> {
      private readonly transport;
      private readonly serializer;
      private readonly sessionCtor;
      private readonly sessions;
      private lastId;
      private _closed;
      private readonly closeEmitter;
      private readonly willSendEmitter;
      private readonly didReceiveEmitter;
      private readonly receiveErrorEmitter;
      /**
       * @returns true if the underlying transport is closed
       */
      get closed(): boolean;
      /**
       * Event that fires before anything is sent on the Connection.
       */
      readonly onWillSendMessage: import("cockatiel").Event<CdpProtocol.ICommand>;
      /**
       * Event that fires after a message is received on the connection.
       */
      readonly onDidReceiveMessage: import("cockatiel").Event<CdpProtocol.ICommand>;
      /**
       * Event that fires whenever an error is encountered processing received input.
       */
      readonly onDidReceiveError: import("cockatiel").Event<Error>;
      /**
       * Event that fires when the transport is disconnected, or when the
       * connection is manually disposed of. If it was the result of a transport
       * error, the error is included.
       */
      readonly onDidClose: import("cockatiel").Event<Error>;
      /**
       * Root CDP session.
       */
      readonly rootSession: T;
      /**
       * Creates a CDP connection for consuming as a client.
       */
      static client<TDomains = CdpV8.Domains & CdpBrowser.Domains>(transport: ITransport, serializer?: ISerializer): ClientConnection<TDomains>;
      /**
       * Creates a CDP connection for consuming as a server.
       */
      static server<TDomains>(transport: ITransport, serializer?: ISerializer): ServerConnection<TDomains>;
      constructor(transport: ITransport, serializer: ISerializer, sessionCtor: SessionCtor<T>);
      /**
       * Primitive request message. You should usually use the `request` method on
       * the {@link ClientCDPSession} instance instead.
       */
      request(method: string, params: Record<string, unknown> | undefined, sessionId: string | undefined): number;
      /**
       * Primitive request call. You should usually use the `request` method on
       * the {@link ClientCDPSession} instance instead.
       */
      send(message: CdpProtocol.Message): void;
      /**
       * Closes the connection and transport.
       */
      dispose(): void;
      /**
       * Gets or creates a Session with the given ID. If no ID is passed, the
       * root session is returned.
       */
      getSession(sessionId: string | undefined): T;
      private onTransportClose;
      private onMessage;
  }
  export const enum ConnectionState {
      Open = 0,
      Closed = 1
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/cdp/definitions' {
  export namespace CdpV8 {
      type integer = number;
      /**
       * The list of domains.
       */
      interface Domains {
          Console: ConsoleApi;
          Debugger: DebuggerApi;
          HeapProfiler: HeapProfilerApi;
          Profiler: ProfilerApi;
          Runtime: RuntimeApi;
          Schema: SchemaApi;
      }
      /**
       * Methods and events of the 'Console' domain.
       */
      interface ConsoleApi {
          requests: {
              /**
               * Does nothing.
               */
              clearMessages: {
                  params: Console.ClearMessagesParams;
                  result: Console.ClearMessagesResult;
              };
              /**
               * Disables console domain, prevents further console messages from being reported to the client.
               */
              disable: {
                  params: Console.DisableParams;
                  result: Console.DisableResult;
              };
              /**
               * Enables console domain, sends the messages collected so far to the client by means of the
               * `messageAdded` notification.
               */
              enable: {
                  params: Console.EnableParams;
                  result: Console.EnableResult;
              };
          };
          events: {
              /**
               * Issued when new console message is added.
               */
              messageAdded: {
                  params: Console.MessageAddedEvent;
              };
          };
      }
      /**
       * Types of the 'Console' domain.
       */
      namespace Console {
          /**
           * Parameters of the 'Console.clearMessages' method.
           */
          interface ClearMessagesParams {
          }
          /**
           * Return value of the 'Console.clearMessages' method.
           */
          interface ClearMessagesResult {
          }
          /**
           * Parameters of the 'Console.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Console.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Console.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Console.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Console.messageAdded' event.
           */
          interface MessageAddedEvent {
              /**
               * Console message that has been added.
               */
              message: ConsoleMessage;
          }
          /**
           * Console message.
           */
          interface ConsoleMessage {
              /**
               * Message source.
               */
              source: 'xml' | 'javascript' | 'network' | 'console-api' | 'storage' | 'appcache' | 'rendering' | 'security' | 'other' | 'deprecation' | 'worker';
              /**
               * Message severity.
               */
              level: 'log' | 'warning' | 'error' | 'debug' | 'info';
              /**
               * Message text.
               */
              text: string;
              /**
               * URL of the message origin.
               */
              url?: string;
              /**
               * Line number in the resource that generated this message (1-based).
               */
              line?: integer;
              /**
               * Column number in the resource that generated this message (1-based).
               */
              column?: integer;
          }
      }
      /**
       * Methods and events of the 'Debugger' domain.
       */
      interface DebuggerApi {
          requests: {
              /**
               * Continues execution until specific location is reached.
               */
              continueToLocation: {
                  params: Debugger.ContinueToLocationParams;
                  result: Debugger.ContinueToLocationResult;
              };
              /**
               * Disables debugger for given page.
               */
              disable: {
                  params: Debugger.DisableParams;
                  result: Debugger.DisableResult;
              };
              /**
               * Enables debugger for the given page. Clients should not assume that the debugging has been
               * enabled until the result for this command is received.
               */
              enable: {
                  params: Debugger.EnableParams;
                  result: Debugger.EnableResult;
              };
              /**
               * Evaluates expression on a given call frame.
               */
              evaluateOnCallFrame: {
                  params: Debugger.EvaluateOnCallFrameParams;
                  result: Debugger.EvaluateOnCallFrameResult;
              };
              /**
               * Returns possible locations for breakpoint. scriptId in start and end range locations should be
               * the same.
               */
              getPossibleBreakpoints: {
                  params: Debugger.GetPossibleBreakpointsParams;
                  result: Debugger.GetPossibleBreakpointsResult;
              };
              /**
               * Returns source for the script with given id.
               */
              getScriptSource: {
                  params: Debugger.GetScriptSourceParams;
                  result: Debugger.GetScriptSourceResult;
              };
              disassembleWasmModule: {
                  params: Debugger.DisassembleWasmModuleParams;
                  result: Debugger.DisassembleWasmModuleResult;
              };
              /**
               * Disassemble the next chunk of lines for the module corresponding to the
               * stream. If disassembly is complete, this API will invalidate the streamId
               * and return an empty chunk. Any subsequent calls for the now invalid stream
               * will return errors.
               */
              nextWasmDisassemblyChunk: {
                  params: Debugger.NextWasmDisassemblyChunkParams;
                  result: Debugger.NextWasmDisassemblyChunkResult;
              };
              /**
               * This command is deprecated. Use getScriptSource instead.
               * @deprecated
               */
              getWasmBytecode: {
                  params: Debugger.GetWasmBytecodeParams;
                  result: Debugger.GetWasmBytecodeResult;
              };
              /**
               * Returns stack trace with given `stackTraceId`.
               */
              getStackTrace: {
                  params: Debugger.GetStackTraceParams;
                  result: Debugger.GetStackTraceResult;
              };
              /**
               * Stops on the next JavaScript statement.
               */
              pause: {
                  params: Debugger.PauseParams;
                  result: Debugger.PauseResult;
              };
              /**
               * undefined
               * @deprecated
               */
              pauseOnAsyncCall: {
                  params: Debugger.PauseOnAsyncCallParams;
                  result: Debugger.PauseOnAsyncCallResult;
              };
              /**
               * Removes JavaScript breakpoint.
               */
              removeBreakpoint: {
                  params: Debugger.RemoveBreakpointParams;
                  result: Debugger.RemoveBreakpointResult;
              };
              /**
               * Restarts particular call frame from the beginning. The old, deprecated
               * behavior of `restartFrame` is to stay paused and allow further CDP commands
               * after a restart was scheduled. This can cause problems with restarting, so
               * we now continue execution immediatly after it has been scheduled until we
               * reach the beginning of the restarted frame.
               *
               * To stay back-wards compatible, `restartFrame` now expects a `mode`
               * parameter to be present. If the `mode` parameter is missing, `restartFrame`
               * errors out.
               *
               * The various return values are deprecated and `callFrames` is always empty.
               * Use the call frames from the `Debugger#paused` events instead, that fires
               * once V8 pauses at the beginning of the restarted function.
               */
              restartFrame: {
                  params: Debugger.RestartFrameParams;
                  result: Debugger.RestartFrameResult;
              };
              /**
               * Resumes JavaScript execution.
               */
              resume: {
                  params: Debugger.ResumeParams;
                  result: Debugger.ResumeResult;
              };
              /**
               * Searches for given string in script content.
               */
              searchInContent: {
                  params: Debugger.SearchInContentParams;
                  result: Debugger.SearchInContentResult;
              };
              /**
               * Enables or disables async call stacks tracking.
               */
              setAsyncCallStackDepth: {
                  params: Debugger.SetAsyncCallStackDepthParams;
                  result: Debugger.SetAsyncCallStackDepthResult;
              };
              /**
               * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
               * scripts with url matching one of the patterns. VM will try to leave blackboxed script by
               * performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
               */
              setBlackboxPatterns: {
                  params: Debugger.SetBlackboxPatternsParams;
                  result: Debugger.SetBlackboxPatternsResult;
              };
              /**
               * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
               * scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
               * Positions array contains positions where blackbox state is changed. First interval isn't
               * blackboxed. Array should be sorted.
               */
              setBlackboxedRanges: {
                  params: Debugger.SetBlackboxedRangesParams;
                  result: Debugger.SetBlackboxedRangesResult;
              };
              /**
               * Sets JavaScript breakpoint at a given location.
               */
              setBreakpoint: {
                  params: Debugger.SetBreakpointParams;
                  result: Debugger.SetBreakpointResult;
              };
              /**
               * Sets instrumentation breakpoint.
               */
              setInstrumentationBreakpoint: {
                  params: Debugger.SetInstrumentationBreakpointParams;
                  result: Debugger.SetInstrumentationBreakpointResult;
              };
              /**
               * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
               * command is issued, all existing parsed scripts will have breakpoints resolved and returned in
               * `locations` property. Further matching script parsing will result in subsequent
               * `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
               */
              setBreakpointByUrl: {
                  params: Debugger.SetBreakpointByUrlParams;
                  result: Debugger.SetBreakpointByUrlResult;
              };
              /**
               * Sets JavaScript breakpoint before each call to the given function.
               * If another function was created from the same source as a given one,
               * calling it will also trigger the breakpoint.
               */
              setBreakpointOnFunctionCall: {
                  params: Debugger.SetBreakpointOnFunctionCallParams;
                  result: Debugger.SetBreakpointOnFunctionCallResult;
              };
              /**
               * Activates / deactivates all breakpoints on the page.
               */
              setBreakpointsActive: {
                  params: Debugger.SetBreakpointsActiveParams;
                  result: Debugger.SetBreakpointsActiveResult;
              };
              /**
               * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
               * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
               */
              setPauseOnExceptions: {
                  params: Debugger.SetPauseOnExceptionsParams;
                  result: Debugger.SetPauseOnExceptionsResult;
              };
              /**
               * Changes return value in top frame. Available only at return break position.
               */
              setReturnValue: {
                  params: Debugger.SetReturnValueParams;
                  result: Debugger.SetReturnValueResult;
              };
              /**
               * Edits JavaScript source live.
               *
               * In general, functions that are currently on the stack can not be edited with
               * a single exception: If the edited function is the top-most stack frame and
               * that is the only activation of that function on the stack. In this case
               * the live edit will be successful and a `Debugger.restartFrame` for the
               * top-most function is automatically triggered.
               */
              setScriptSource: {
                  params: Debugger.SetScriptSourceParams;
                  result: Debugger.SetScriptSourceResult;
              };
              /**
               * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
               */
              setSkipAllPauses: {
                  params: Debugger.SetSkipAllPausesParams;
                  result: Debugger.SetSkipAllPausesResult;
              };
              /**
               * Changes value of variable in a callframe. Object-based scopes are not supported and must be
               * mutated manually.
               */
              setVariableValue: {
                  params: Debugger.SetVariableValueParams;
                  result: Debugger.SetVariableValueResult;
              };
              /**
               * Steps into the function call.
               */
              stepInto: {
                  params: Debugger.StepIntoParams;
                  result: Debugger.StepIntoResult;
              };
              /**
               * Steps out of the function call.
               */
              stepOut: {
                  params: Debugger.StepOutParams;
                  result: Debugger.StepOutResult;
              };
              /**
               * Steps over the statement.
               */
              stepOver: {
                  params: Debugger.StepOverParams;
                  result: Debugger.StepOverResult;
              };
          };
          events: {
              /**
               * Fired when breakpoint is resolved to an actual script and location.
               */
              breakpointResolved: {
                  params: Debugger.BreakpointResolvedEvent;
              };
              /**
               * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
               */
              paused: {
                  params: Debugger.PausedEvent;
              };
              /**
               * Fired when the virtual machine resumed execution.
               */
              resumed: {
                  params: Debugger.ResumedEvent;
              };
              /**
               * Fired when virtual machine fails to parse the script.
               */
              scriptFailedToParse: {
                  params: Debugger.ScriptFailedToParseEvent;
              };
              /**
               * Fired when virtual machine parses script. This event is also fired for all known and uncollected
               * scripts upon enabling debugger.
               */
              scriptParsed: {
                  params: Debugger.ScriptParsedEvent;
              };
          };
      }
      /**
       * Types of the 'Debugger' domain.
       */
      namespace Debugger {
          /**
           * Parameters of the 'Debugger.continueToLocation' method.
           */
          interface ContinueToLocationParams {
              /**
               * Location to continue to.
               */
              location: Location;
              targetCallFrames?: 'any' | 'current';
          }
          /**
           * Return value of the 'Debugger.continueToLocation' method.
           */
          interface ContinueToLocationResult {
          }
          /**
           * Parameters of the 'Debugger.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Debugger.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Debugger.enable' method.
           */
          interface EnableParams {
              /**
               * The maximum size in bytes of collected scripts (not referenced by other heap objects)
               * the debugger can hold. Puts no limit if parameter is omitted.
               */
              maxScriptsCacheSize?: number;
          }
          /**
           * Return value of the 'Debugger.enable' method.
           */
          interface EnableResult {
              /**
               * Unique identifier of the debugger.
               */
              debuggerId: Runtime.UniqueDebuggerId;
          }
          /**
           * Parameters of the 'Debugger.evaluateOnCallFrame' method.
           */
          interface EvaluateOnCallFrameParams {
              /**
               * Call frame identifier to evaluate on.
               */
              callFrameId: CallFrameId;
              /**
               * Expression to evaluate.
               */
              expression: string;
              /**
               * String object group name to put result into (allows rapid releasing resulting object handles
               * using `releaseObjectGroup`).
               */
              objectGroup?: string;
              /**
               * Specifies whether command line API should be available to the evaluated expression, defaults
               * to false.
               */
              includeCommandLineAPI?: boolean;
              /**
               * In silent mode exceptions thrown during evaluation are not reported and do not pause
               * execution. Overrides `setPauseOnException` state.
               */
              silent?: boolean;
              /**
               * Whether the result is expected to be a JSON object that should be sent by value.
               */
              returnByValue?: boolean;
              /**
               * Whether preview should be generated for the result.
               */
              generatePreview?: boolean;
              /**
               * Whether to throw an exception if side effect cannot be ruled out during evaluation.
               */
              throwOnSideEffect?: boolean;
              /**
               * Terminate execution after timing out (number of milliseconds).
               */
              timeout?: Runtime.TimeDelta;
          }
          /**
           * Return value of the 'Debugger.evaluateOnCallFrame' method.
           */
          interface EvaluateOnCallFrameResult {
              /**
               * Object wrapper for the evaluation result.
               */
              result: Runtime.RemoteObject;
              /**
               * Exception details.
               */
              exceptionDetails?: Runtime.ExceptionDetails;
          }
          /**
           * Parameters of the 'Debugger.getPossibleBreakpoints' method.
           */
          interface GetPossibleBreakpointsParams {
              /**
               * Start of range to search possible breakpoint locations in.
               */
              start: Location;
              /**
               * End of range to search possible breakpoint locations in (excluding). When not specified, end
               * of scripts is used as end of range.
               */
              end?: Location;
              /**
               * Only consider locations which are in the same (non-nested) function as start.
               */
              restrictToFunction?: boolean;
          }
          /**
           * Return value of the 'Debugger.getPossibleBreakpoints' method.
           */
          interface GetPossibleBreakpointsResult {
              /**
               * List of the possible breakpoint locations.
               */
              locations: BreakLocation[];
          }
          /**
           * Parameters of the 'Debugger.getScriptSource' method.
           */
          interface GetScriptSourceParams {
              /**
               * Id of the script to get source for.
               */
              scriptId: Runtime.ScriptId;
          }
          /**
           * Return value of the 'Debugger.getScriptSource' method.
           */
          interface GetScriptSourceResult {
              /**
               * Script source (empty in case of Wasm bytecode).
               */
              scriptSource: string;
              /**
               * Wasm bytecode. (Encoded as a base64 string when passed over JSON)
               */
              bytecode?: string;
          }
          /**
           * Parameters of the 'Debugger.disassembleWasmModule' method.
           */
          interface DisassembleWasmModuleParams {
              /**
               * Id of the script to disassemble
               */
              scriptId: Runtime.ScriptId;
          }
          /**
           * Return value of the 'Debugger.disassembleWasmModule' method.
           */
          interface DisassembleWasmModuleResult {
              /**
               * For large modules, return a stream from which additional chunks of
               * disassembly can be read successively.
               */
              streamId?: string;
              /**
               * The total number of lines in the disassembly text.
               */
              totalNumberOfLines: integer;
              /**
               * The offsets of all function bodies, in the format [start1, end1,
               * start2, end2, ...] where all ends are exclusive.
               */
              functionBodyOffsets: integer[];
              /**
               * The first chunk of disassembly.
               */
              chunk: WasmDisassemblyChunk;
          }
          /**
           * Parameters of the 'Debugger.nextWasmDisassemblyChunk' method.
           */
          interface NextWasmDisassemblyChunkParams {
              streamId: string;
          }
          /**
           * Return value of the 'Debugger.nextWasmDisassemblyChunk' method.
           */
          interface NextWasmDisassemblyChunkResult {
              /**
               * The next chunk of disassembly.
               */
              chunk: WasmDisassemblyChunk;
          }
          /**
           * Parameters of the 'Debugger.getWasmBytecode' method.
           */
          interface GetWasmBytecodeParams {
              /**
               * Id of the Wasm script to get source for.
               */
              scriptId: Runtime.ScriptId;
          }
          /**
           * Return value of the 'Debugger.getWasmBytecode' method.
           */
          interface GetWasmBytecodeResult {
              /**
               * Script source. (Encoded as a base64 string when passed over JSON)
               */
              bytecode: string;
          }
          /**
           * Parameters of the 'Debugger.getStackTrace' method.
           */
          interface GetStackTraceParams {
              stackTraceId: Runtime.StackTraceId;
          }
          /**
           * Return value of the 'Debugger.getStackTrace' method.
           */
          interface GetStackTraceResult {
              stackTrace: Runtime.StackTrace;
          }
          /**
           * Parameters of the 'Debugger.pause' method.
           */
          interface PauseParams {
          }
          /**
           * Return value of the 'Debugger.pause' method.
           */
          interface PauseResult {
          }
          /**
           * Parameters of the 'Debugger.pauseOnAsyncCall' method.
           */
          interface PauseOnAsyncCallParams {
              /**
               * Debugger will pause when async call with given stack trace is started.
               */
              parentStackTraceId: Runtime.StackTraceId;
          }
          /**
           * Return value of the 'Debugger.pauseOnAsyncCall' method.
           */
          interface PauseOnAsyncCallResult {
          }
          /**
           * Parameters of the 'Debugger.removeBreakpoint' method.
           */
          interface RemoveBreakpointParams {
              breakpointId: BreakpointId;
          }
          /**
           * Return value of the 'Debugger.removeBreakpoint' method.
           */
          interface RemoveBreakpointResult {
          }
          /**
           * Parameters of the 'Debugger.restartFrame' method.
           */
          interface RestartFrameParams {
              /**
               * Call frame identifier to evaluate on.
               */
              callFrameId: CallFrameId;
              /**
               * The `mode` parameter must be present and set to 'StepInto', otherwise
               * `restartFrame` will error out.
               */
              mode?: 'StepInto';
          }
          /**
           * Return value of the 'Debugger.restartFrame' method.
           */
          interface RestartFrameResult {
              /**
               * New stack trace.
               * @deprecated
               */
              callFrames: CallFrame[];
              /**
               * Async stack trace, if any.
               * @deprecated
               */
              asyncStackTrace?: Runtime.StackTrace;
              /**
               * Async stack trace, if any.
               * @deprecated
               */
              asyncStackTraceId?: Runtime.StackTraceId;
          }
          /**
           * Parameters of the 'Debugger.resume' method.
           */
          interface ResumeParams {
              /**
               * Set to true to terminate execution upon resuming execution. In contrast
               * to Runtime.terminateExecution, this will allows to execute further
               * JavaScript (i.e. via evaluation) until execution of the paused code
               * is actually resumed, at which point termination is triggered.
               * If execution is currently not paused, this parameter has no effect.
               */
              terminateOnResume?: boolean;
          }
          /**
           * Return value of the 'Debugger.resume' method.
           */
          interface ResumeResult {
          }
          /**
           * Parameters of the 'Debugger.searchInContent' method.
           */
          interface SearchInContentParams {
              /**
               * Id of the script to search in.
               */
              scriptId: Runtime.ScriptId;
              /**
               * String to search for.
               */
              query: string;
              /**
               * If true, search is case sensitive.
               */
              caseSensitive?: boolean;
              /**
               * If true, treats string parameter as regex.
               */
              isRegex?: boolean;
          }
          /**
           * Return value of the 'Debugger.searchInContent' method.
           */
          interface SearchInContentResult {
              /**
               * List of search matches.
               */
              result: SearchMatch[];
          }
          /**
           * Parameters of the 'Debugger.setAsyncCallStackDepth' method.
           */
          interface SetAsyncCallStackDepthParams {
              /**
               * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
               * call stacks (default).
               */
              maxDepth: integer;
          }
          /**
           * Return value of the 'Debugger.setAsyncCallStackDepth' method.
           */
          interface SetAsyncCallStackDepthResult {
          }
          /**
           * Parameters of the 'Debugger.setBlackboxPatterns' method.
           */
          interface SetBlackboxPatternsParams {
              /**
               * Array of regexps that will be used to check script url for blackbox state.
               */
              patterns: string[];
          }
          /**
           * Return value of the 'Debugger.setBlackboxPatterns' method.
           */
          interface SetBlackboxPatternsResult {
          }
          /**
           * Parameters of the 'Debugger.setBlackboxedRanges' method.
           */
          interface SetBlackboxedRangesParams {
              /**
               * Id of the script.
               */
              scriptId: Runtime.ScriptId;
              positions: ScriptPosition[];
          }
          /**
           * Return value of the 'Debugger.setBlackboxedRanges' method.
           */
          interface SetBlackboxedRangesResult {
          }
          /**
           * Parameters of the 'Debugger.setBreakpoint' method.
           */
          interface SetBreakpointParams {
              /**
               * Location to set breakpoint in.
               */
              location: Location;
              /**
               * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
               * breakpoint if this expression evaluates to true.
               */
              condition?: string;
          }
          /**
           * Return value of the 'Debugger.setBreakpoint' method.
           */
          interface SetBreakpointResult {
              /**
               * Id of the created breakpoint for further reference.
               */
              breakpointId: BreakpointId;
              /**
               * Location this breakpoint resolved into.
               */
              actualLocation: Location;
          }
          /**
           * Parameters of the 'Debugger.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointParams {
              /**
               * Instrumentation name.
               */
              instrumentation: 'beforeScriptExecution' | 'beforeScriptWithSourceMapExecution';
          }
          /**
           * Return value of the 'Debugger.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointResult {
              /**
               * Id of the created breakpoint for further reference.
               */
              breakpointId: BreakpointId;
          }
          /**
           * Parameters of the 'Debugger.setBreakpointByUrl' method.
           */
          interface SetBreakpointByUrlParams {
              /**
               * Line number to set breakpoint at.
               */
              lineNumber: integer;
              /**
               * URL of the resources to set breakpoint on.
               */
              url?: string;
              /**
               * Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
               * `urlRegex` must be specified.
               */
              urlRegex?: string;
              /**
               * Script hash of the resources to set breakpoint on.
               */
              scriptHash?: string;
              /**
               * Offset in the line to set breakpoint at.
               */
              columnNumber?: integer;
              /**
               * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
               * breakpoint if this expression evaluates to true.
               */
              condition?: string;
          }
          /**
           * Return value of the 'Debugger.setBreakpointByUrl' method.
           */
          interface SetBreakpointByUrlResult {
              /**
               * Id of the created breakpoint for further reference.
               */
              breakpointId: BreakpointId;
              /**
               * List of the locations this breakpoint resolved into upon addition.
               */
              locations: Location[];
          }
          /**
           * Parameters of the 'Debugger.setBreakpointOnFunctionCall' method.
           */
          interface SetBreakpointOnFunctionCallParams {
              /**
               * Function object id.
               */
              objectId: Runtime.RemoteObjectId;
              /**
               * Expression to use as a breakpoint condition. When specified, debugger will
               * stop on the breakpoint if this expression evaluates to true.
               */
              condition?: string;
          }
          /**
           * Return value of the 'Debugger.setBreakpointOnFunctionCall' method.
           */
          interface SetBreakpointOnFunctionCallResult {
              /**
               * Id of the created breakpoint for further reference.
               */
              breakpointId: BreakpointId;
          }
          /**
           * Parameters of the 'Debugger.setBreakpointsActive' method.
           */
          interface SetBreakpointsActiveParams {
              /**
               * New value for breakpoints active state.
               */
              active: boolean;
          }
          /**
           * Return value of the 'Debugger.setBreakpointsActive' method.
           */
          interface SetBreakpointsActiveResult {
          }
          /**
           * Parameters of the 'Debugger.setPauseOnExceptions' method.
           */
          interface SetPauseOnExceptionsParams {
              /**
               * Pause on exceptions mode.
               */
              state: 'none' | 'caught' | 'uncaught' | 'all';
          }
          /**
           * Return value of the 'Debugger.setPauseOnExceptions' method.
           */
          interface SetPauseOnExceptionsResult {
          }
          /**
           * Parameters of the 'Debugger.setReturnValue' method.
           */
          interface SetReturnValueParams {
              /**
               * New return value.
               */
              newValue: Runtime.CallArgument;
          }
          /**
           * Return value of the 'Debugger.setReturnValue' method.
           */
          interface SetReturnValueResult {
          }
          /**
           * Parameters of the 'Debugger.setScriptSource' method.
           */
          interface SetScriptSourceParams {
              /**
               * Id of the script to edit.
               */
              scriptId: Runtime.ScriptId;
              /**
               * New content of the script.
               */
              scriptSource: string;
              /**
               * If true the change will not actually be applied. Dry run may be used to get result
               * description without actually modifying the code.
               */
              dryRun?: boolean;
              /**
               * If true, then `scriptSource` is allowed to change the function on top of the stack
               * as long as the top-most stack frame is the only activation of that function.
               */
              allowTopFrameEditing?: boolean;
          }
          /**
           * Return value of the 'Debugger.setScriptSource' method.
           */
          interface SetScriptSourceResult {
              /**
               * New stack trace in case editing has happened while VM was stopped.
               * @deprecated
               */
              callFrames?: CallFrame[];
              /**
               * Whether current call stack  was modified after applying the changes.
               * @deprecated
               */
              stackChanged?: boolean;
              /**
               * Async stack trace, if any.
               * @deprecated
               */
              asyncStackTrace?: Runtime.StackTrace;
              /**
               * Async stack trace, if any.
               * @deprecated
               */
              asyncStackTraceId?: Runtime.StackTraceId;
              /**
               * Whether the operation was successful or not. Only `Ok` denotes a
               * successful live edit while the other enum variants denote why
               * the live edit failed.
               */
              status: 'Ok' | 'CompileError' | 'BlockedByActiveGenerator' | 'BlockedByActiveFunction' | 'BlockedByTopLevelEsModuleChange';
              /**
               * Exception details if any. Only present when `status` is `CompileError`.
               */
              exceptionDetails?: Runtime.ExceptionDetails;
          }
          /**
           * Parameters of the 'Debugger.setSkipAllPauses' method.
           */
          interface SetSkipAllPausesParams {
              /**
               * New value for skip pauses state.
               */
              skip: boolean;
          }
          /**
           * Return value of the 'Debugger.setSkipAllPauses' method.
           */
          interface SetSkipAllPausesResult {
          }
          /**
           * Parameters of the 'Debugger.setVariableValue' method.
           */
          interface SetVariableValueParams {
              /**
               * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
               * scope types are allowed. Other scopes could be manipulated manually.
               */
              scopeNumber: integer;
              /**
               * Variable name.
               */
              variableName: string;
              /**
               * New variable value.
               */
              newValue: Runtime.CallArgument;
              /**
               * Id of callframe that holds variable.
               */
              callFrameId: CallFrameId;
          }
          /**
           * Return value of the 'Debugger.setVariableValue' method.
           */
          interface SetVariableValueResult {
          }
          /**
           * Parameters of the 'Debugger.stepInto' method.
           */
          interface StepIntoParams {
              /**
               * Debugger will pause on the execution of the first async task which was scheduled
               * before next pause.
               */
              breakOnAsyncCall?: boolean;
              /**
               * The skipList specifies location ranges that should be skipped on step into.
               */
              skipList?: LocationRange[];
          }
          /**
           * Return value of the 'Debugger.stepInto' method.
           */
          interface StepIntoResult {
          }
          /**
           * Parameters of the 'Debugger.stepOut' method.
           */
          interface StepOutParams {
          }
          /**
           * Return value of the 'Debugger.stepOut' method.
           */
          interface StepOutResult {
          }
          /**
           * Parameters of the 'Debugger.stepOver' method.
           */
          interface StepOverParams {
              /**
               * The skipList specifies location ranges that should be skipped on step over.
               */
              skipList?: LocationRange[];
          }
          /**
           * Return value of the 'Debugger.stepOver' method.
           */
          interface StepOverResult {
          }
          /**
           * Parameters of the 'Debugger.breakpointResolved' event.
           */
          interface BreakpointResolvedEvent {
              /**
               * Breakpoint unique identifier.
               */
              breakpointId: BreakpointId;
              /**
               * Actual breakpoint location.
               */
              location: Location;
          }
          /**
           * Parameters of the 'Debugger.paused' event.
           */
          interface PausedEvent {
              /**
               * Call stack the virtual machine stopped on.
               */
              callFrames: CallFrame[];
              /**
               * Pause reason.
               */
              reason: 'ambiguous' | 'assert' | 'CSPViolation' | 'debugCommand' | 'DOM' | 'EventListener' | 'exception' | 'instrumentation' | 'OOM' | 'other' | 'promiseRejection' | 'XHR' | 'step';
              /**
               * Object containing break-specific auxiliary properties.
               */
              data?: Record<string, unknown>;
              /**
               * Hit breakpoints IDs
               */
              hitBreakpoints?: string[];
              /**
               * Async stack trace, if any.
               */
              asyncStackTrace?: Runtime.StackTrace;
              /**
               * Async stack trace, if any.
               */
              asyncStackTraceId?: Runtime.StackTraceId;
              /**
               * Never present, will be removed.
               * @deprecated
               */
              asyncCallStackTraceId?: Runtime.StackTraceId;
          }
          /**
           * Parameters of the 'Debugger.resumed' event.
           */
          interface ResumedEvent {
          }
          /**
           * Parameters of the 'Debugger.scriptFailedToParse' event.
           */
          interface ScriptFailedToParseEvent {
              /**
               * Identifier of the script parsed.
               */
              scriptId: Runtime.ScriptId;
              /**
               * URL or name of the script parsed (if any).
               */
              url: string;
              /**
               * Line offset of the script within the resource with given URL (for script tags).
               */
              startLine: integer;
              /**
               * Column offset of the script within the resource with given URL.
               */
              startColumn: integer;
              /**
               * Last line of the script.
               */
              endLine: integer;
              /**
               * Length of the last line of the script.
               */
              endColumn: integer;
              /**
               * Specifies script creation context.
               */
              executionContextId: Runtime.ExecutionContextId;
              /**
               * Content hash of the script, SHA-256.
               */
              hash: string;
              /**
               * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
               */
              executionContextAuxData?: Record<string, unknown>;
              /**
               * URL of source map associated with script (if any).
               */
              sourceMapURL?: string;
              /**
               * True, if this script has sourceURL.
               */
              hasSourceURL?: boolean;
              /**
               * True, if this script is ES6 module.
               */
              isModule?: boolean;
              /**
               * This script length.
               */
              length?: integer;
              /**
               * JavaScript top stack frame of where the script parsed event was triggered if available.
               */
              stackTrace?: Runtime.StackTrace;
              /**
               * If the scriptLanguage is WebAssembly, the code section offset in the module.
               */
              codeOffset?: integer;
              /**
               * The language of the script.
               */
              scriptLanguage?: Debugger.ScriptLanguage;
              /**
               * The name the embedder supplied for this script.
               */
              embedderName?: string;
          }
          /**
           * Parameters of the 'Debugger.scriptParsed' event.
           */
          interface ScriptParsedEvent {
              /**
               * Identifier of the script parsed.
               */
              scriptId: Runtime.ScriptId;
              /**
               * URL or name of the script parsed (if any).
               */
              url: string;
              /**
               * Line offset of the script within the resource with given URL (for script tags).
               */
              startLine: integer;
              /**
               * Column offset of the script within the resource with given URL.
               */
              startColumn: integer;
              /**
               * Last line of the script.
               */
              endLine: integer;
              /**
               * Length of the last line of the script.
               */
              endColumn: integer;
              /**
               * Specifies script creation context.
               */
              executionContextId: Runtime.ExecutionContextId;
              /**
               * Content hash of the script, SHA-256.
               */
              hash: string;
              /**
               * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
               */
              executionContextAuxData?: Record<string, unknown>;
              /**
               * True, if this script is generated as a result of the live edit operation.
               */
              isLiveEdit?: boolean;
              /**
               * URL of source map associated with script (if any).
               */
              sourceMapURL?: string;
              /**
               * True, if this script has sourceURL.
               */
              hasSourceURL?: boolean;
              /**
               * True, if this script is ES6 module.
               */
              isModule?: boolean;
              /**
               * This script length.
               */
              length?: integer;
              /**
               * JavaScript top stack frame of where the script parsed event was triggered if available.
               */
              stackTrace?: Runtime.StackTrace;
              /**
               * If the scriptLanguage is WebAssembly, the code section offset in the module.
               */
              codeOffset?: integer;
              /**
               * The language of the script.
               */
              scriptLanguage?: Debugger.ScriptLanguage;
              /**
               * If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
               */
              debugSymbols?: Debugger.DebugSymbols;
              /**
               * The name the embedder supplied for this script.
               */
              embedderName?: string;
          }
          /**
           * Breakpoint identifier.
           */
          type BreakpointId = string;
          /**
           * Call frame identifier.
           */
          type CallFrameId = string;
          /**
           * Location in the source code.
           */
          interface Location {
              /**
               * Script identifier as reported in the `Debugger.scriptParsed`.
               */
              scriptId: Runtime.ScriptId;
              /**
               * Line number in the script (0-based).
               */
              lineNumber: integer;
              /**
               * Column number in the script (0-based).
               */
              columnNumber?: integer;
          }
          /**
           * Location in the source code.
           */
          interface ScriptPosition {
              lineNumber: integer;
              columnNumber: integer;
          }
          /**
           * Location range within one script.
           */
          interface LocationRange {
              scriptId: Runtime.ScriptId;
              start: ScriptPosition;
              end: ScriptPosition;
          }
          /**
           * JavaScript call frame. Array of call frames form the call stack.
           */
          interface CallFrame {
              /**
               * Call frame identifier. This identifier is only valid while the virtual machine is paused.
               */
              callFrameId: CallFrameId;
              /**
               * Name of the JavaScript function called on this call frame.
               */
              functionName: string;
              /**
               * Location in the source code.
               */
              functionLocation?: Location;
              /**
               * Location in the source code.
               */
              location: Location;
              /**
               * JavaScript script name or url.
               * Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
               * sent `Debugger.scriptParsed` event.
               * @deprecated
               */
              url: string;
              /**
               * Scope chain for this call frame.
               */
              scopeChain: Scope[];
              /**
               * `this` object for this call frame.
               */
              this: Runtime.RemoteObject;
              /**
               * The value being returned, if the function is at return point.
               */
              returnValue?: Runtime.RemoteObject;
              /**
               * Valid only while the VM is paused and indicates whether this frame
               * can be restarted or not. Note that a `true` value here does not
               * guarantee that Debugger#restartFrame with this CallFrameId will be
               * successful, but it is very likely.
               */
              canBeRestarted?: boolean;
          }
          /**
           * Scope description.
           */
          interface Scope {
              /**
               * Scope type.
               */
              type: 'global' | 'local' | 'with' | 'closure' | 'catch' | 'block' | 'script' | 'eval' | 'module' | 'wasm-expression-stack';
              /**
               * Object representing the scope. For `global` and `with` scopes it represents the actual
               * object; for the rest of the scopes, it is artificial transient object enumerating scope
               * variables as its properties.
               */
              object: Runtime.RemoteObject;
              name?: string;
              /**
               * Location in the source code where scope starts
               */
              startLocation?: Location;
              /**
               * Location in the source code where scope ends
               */
              endLocation?: Location;
          }
          /**
           * Search match for resource.
           */
          interface SearchMatch {
              /**
               * Line number in resource content.
               */
              lineNumber: number;
              /**
               * Line with match content.
               */
              lineContent: string;
          }
          interface BreakLocation {
              /**
               * Script identifier as reported in the `Debugger.scriptParsed`.
               */
              scriptId: Runtime.ScriptId;
              /**
               * Line number in the script (0-based).
               */
              lineNumber: integer;
              /**
               * Column number in the script (0-based).
               */
              columnNumber?: integer;
              type?: 'debuggerStatement' | 'call' | 'return';
          }
          interface WasmDisassemblyChunk {
              /**
               * The next chunk of disassembled lines.
               */
              lines: string[];
              /**
               * The bytecode offsets describing the start of each line.
               */
              bytecodeOffsets: integer[];
          }
          /**
           * Enum of possible script languages.
           */
          type ScriptLanguage = 'JavaScript' | 'WebAssembly';
          /**
           * Debug symbols available for a wasm script.
           */
          interface DebugSymbols {
              /**
               * Type of the debug symbols.
               */
              type: 'None' | 'SourceMap' | 'EmbeddedDWARF' | 'ExternalDWARF';
              /**
               * URL of the external symbol source.
               */
              externalURL?: string;
          }
      }
      /**
       * Methods and events of the 'HeapProfiler' domain.
       */
      interface HeapProfilerApi {
          requests: {
              /**
               * Enables console to refer to the node with given id via $x (see Command Line API for more details
               * $x functions).
               */
              addInspectedHeapObject: {
                  params: HeapProfiler.AddInspectedHeapObjectParams;
                  result: HeapProfiler.AddInspectedHeapObjectResult;
              };
              collectGarbage: {
                  params: HeapProfiler.CollectGarbageParams;
                  result: HeapProfiler.CollectGarbageResult;
              };
              disable: {
                  params: HeapProfiler.DisableParams;
                  result: HeapProfiler.DisableResult;
              };
              enable: {
                  params: HeapProfiler.EnableParams;
                  result: HeapProfiler.EnableResult;
              };
              getHeapObjectId: {
                  params: HeapProfiler.GetHeapObjectIdParams;
                  result: HeapProfiler.GetHeapObjectIdResult;
              };
              getObjectByHeapObjectId: {
                  params: HeapProfiler.GetObjectByHeapObjectIdParams;
                  result: HeapProfiler.GetObjectByHeapObjectIdResult;
              };
              getSamplingProfile: {
                  params: HeapProfiler.GetSamplingProfileParams;
                  result: HeapProfiler.GetSamplingProfileResult;
              };
              startSampling: {
                  params: HeapProfiler.StartSamplingParams;
                  result: HeapProfiler.StartSamplingResult;
              };
              startTrackingHeapObjects: {
                  params: HeapProfiler.StartTrackingHeapObjectsParams;
                  result: HeapProfiler.StartTrackingHeapObjectsResult;
              };
              stopSampling: {
                  params: HeapProfiler.StopSamplingParams;
                  result: HeapProfiler.StopSamplingResult;
              };
              stopTrackingHeapObjects: {
                  params: HeapProfiler.StopTrackingHeapObjectsParams;
                  result: HeapProfiler.StopTrackingHeapObjectsResult;
              };
              takeHeapSnapshot: {
                  params: HeapProfiler.TakeHeapSnapshotParams;
                  result: HeapProfiler.TakeHeapSnapshotResult;
              };
          };
          events: {
              addHeapSnapshotChunk: {
                  params: HeapProfiler.AddHeapSnapshotChunkEvent;
              };
              /**
               * If heap objects tracking has been started then backend may send update for one or more fragments
               */
              heapStatsUpdate: {
                  params: HeapProfiler.HeapStatsUpdateEvent;
              };
              /**
               * If heap objects tracking has been started then backend regularly sends a current value for last
               * seen object id and corresponding timestamp. If the were changes in the heap since last event
               * then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
               */
              lastSeenObjectId: {
                  params: HeapProfiler.LastSeenObjectIdEvent;
              };
              reportHeapSnapshotProgress: {
                  params: HeapProfiler.ReportHeapSnapshotProgressEvent;
              };
              resetProfiles: {
                  params: HeapProfiler.ResetProfilesEvent;
              };
          };
      }
      /**
       * Types of the 'HeapProfiler' domain.
       */
      namespace HeapProfiler {
          /**
           * Parameters of the 'HeapProfiler.addInspectedHeapObject' method.
           */
          interface AddInspectedHeapObjectParams {
              /**
               * Heap snapshot object id to be accessible by means of $x command line API.
               */
              heapObjectId: HeapSnapshotObjectId;
          }
          /**
           * Return value of the 'HeapProfiler.addInspectedHeapObject' method.
           */
          interface AddInspectedHeapObjectResult {
          }
          /**
           * Parameters of the 'HeapProfiler.collectGarbage' method.
           */
          interface CollectGarbageParams {
          }
          /**
           * Return value of the 'HeapProfiler.collectGarbage' method.
           */
          interface CollectGarbageResult {
          }
          /**
           * Parameters of the 'HeapProfiler.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'HeapProfiler.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'HeapProfiler.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'HeapProfiler.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'HeapProfiler.getHeapObjectId' method.
           */
          interface GetHeapObjectIdParams {
              /**
               * Identifier of the object to get heap object id for.
               */
              objectId: Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'HeapProfiler.getHeapObjectId' method.
           */
          interface GetHeapObjectIdResult {
              /**
               * Id of the heap snapshot object corresponding to the passed remote object id.
               */
              heapSnapshotObjectId: HeapSnapshotObjectId;
          }
          /**
           * Parameters of the 'HeapProfiler.getObjectByHeapObjectId' method.
           */
          interface GetObjectByHeapObjectIdParams {
              objectId: HeapSnapshotObjectId;
              /**
               * Symbolic group name that can be used to release multiple objects.
               */
              objectGroup?: string;
          }
          /**
           * Return value of the 'HeapProfiler.getObjectByHeapObjectId' method.
           */
          interface GetObjectByHeapObjectIdResult {
              /**
               * Evaluation result.
               */
              result: Runtime.RemoteObject;
          }
          /**
           * Parameters of the 'HeapProfiler.getSamplingProfile' method.
           */
          interface GetSamplingProfileParams {
          }
          /**
           * Return value of the 'HeapProfiler.getSamplingProfile' method.
           */
          interface GetSamplingProfileResult {
              /**
               * Return the sampling profile being collected.
               */
              profile: SamplingHeapProfile;
          }
          /**
           * Parameters of the 'HeapProfiler.startSampling' method.
           */
          interface StartSamplingParams {
              /**
               * Average sample interval in bytes. Poisson distribution is used for the intervals. The
               * default value is 32768 bytes.
               */
              samplingInterval?: number;
              /**
               * By default, the sampling heap profiler reports only objects which are
               * still alive when the profile is returned via getSamplingProfile or
               * stopSampling, which is useful for determining what functions contribute
               * the most to steady-state memory usage. This flag instructs the sampling
               * heap profiler to also include information about objects discarded by
               * major GC, which will show which functions cause large temporary memory
               * usage or long GC pauses.
               */
              includeObjectsCollectedByMajorGC?: boolean;
              /**
               * By default, the sampling heap profiler reports only objects which are
               * still alive when the profile is returned via getSamplingProfile or
               * stopSampling, which is useful for determining what functions contribute
               * the most to steady-state memory usage. This flag instructs the sampling
               * heap profiler to also include information about objects discarded by
               * minor GC, which is useful when tuning a latency-sensitive application
               * for minimal GC activity.
               */
              includeObjectsCollectedByMinorGC?: boolean;
          }
          /**
           * Return value of the 'HeapProfiler.startSampling' method.
           */
          interface StartSamplingResult {
          }
          /**
           * Parameters of the 'HeapProfiler.startTrackingHeapObjects' method.
           */
          interface StartTrackingHeapObjectsParams {
              trackAllocations?: boolean;
          }
          /**
           * Return value of the 'HeapProfiler.startTrackingHeapObjects' method.
           */
          interface StartTrackingHeapObjectsResult {
          }
          /**
           * Parameters of the 'HeapProfiler.stopSampling' method.
           */
          interface StopSamplingParams {
          }
          /**
           * Return value of the 'HeapProfiler.stopSampling' method.
           */
          interface StopSamplingResult {
              /**
               * Recorded sampling heap profile.
               */
              profile: SamplingHeapProfile;
          }
          /**
           * Parameters of the 'HeapProfiler.stopTrackingHeapObjects' method.
           */
          interface StopTrackingHeapObjectsParams {
              /**
               * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
               * when the tracking is stopped.
               */
              reportProgress?: boolean;
              /**
               * Deprecated in favor of `exposeInternals`.
               * @deprecated
               */
              treatGlobalObjectsAsRoots?: boolean;
              /**
               * If true, numerical values are included in the snapshot
               */
              captureNumericValue?: boolean;
              /**
               * If true, exposes internals of the snapshot.
               */
              exposeInternals?: boolean;
          }
          /**
           * Return value of the 'HeapProfiler.stopTrackingHeapObjects' method.
           */
          interface StopTrackingHeapObjectsResult {
          }
          /**
           * Parameters of the 'HeapProfiler.takeHeapSnapshot' method.
           */
          interface TakeHeapSnapshotParams {
              /**
               * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
               */
              reportProgress?: boolean;
              /**
               * If true, a raw snapshot without artificial roots will be generated.
               * Deprecated in favor of `exposeInternals`.
               * @deprecated
               */
              treatGlobalObjectsAsRoots?: boolean;
              /**
               * If true, numerical values are included in the snapshot
               */
              captureNumericValue?: boolean;
              /**
               * If true, exposes internals of the snapshot.
               */
              exposeInternals?: boolean;
          }
          /**
           * Return value of the 'HeapProfiler.takeHeapSnapshot' method.
           */
          interface TakeHeapSnapshotResult {
          }
          /**
           * Parameters of the 'HeapProfiler.addHeapSnapshotChunk' event.
           */
          interface AddHeapSnapshotChunkEvent {
              chunk: string;
          }
          /**
           * Parameters of the 'HeapProfiler.heapStatsUpdate' event.
           */
          interface HeapStatsUpdateEvent {
              /**
               * An array of triplets. Each triplet describes a fragment. The first integer is the fragment
               * index, the second integer is a total count of objects for the fragment, the third integer is
               * a total size of the objects for the fragment.
               */
              statsUpdate: integer[];
          }
          /**
           * Parameters of the 'HeapProfiler.lastSeenObjectId' event.
           */
          interface LastSeenObjectIdEvent {
              lastSeenObjectId: integer;
              timestamp: number;
          }
          /**
           * Parameters of the 'HeapProfiler.reportHeapSnapshotProgress' event.
           */
          interface ReportHeapSnapshotProgressEvent {
              done: integer;
              total: integer;
              finished?: boolean;
          }
          /**
           * Parameters of the 'HeapProfiler.resetProfiles' event.
           */
          interface ResetProfilesEvent {
          }
          /**
           * Heap snapshot object id.
           */
          type HeapSnapshotObjectId = string;
          /**
           * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
           */
          interface SamplingHeapProfileNode {
              /**
               * Function location.
               */
              callFrame: Runtime.CallFrame;
              /**
               * Allocations size in bytes for the node excluding children.
               */
              selfSize: number;
              /**
               * Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
               */
              id: integer;
              /**
               * Child nodes.
               */
              children: SamplingHeapProfileNode[];
          }
          /**
           * A single sample from a sampling profile.
           */
          interface SamplingHeapProfileSample {
              /**
               * Allocation size in bytes attributed to the sample.
               */
              size: number;
              /**
               * Id of the corresponding profile tree node.
               */
              nodeId: integer;
              /**
               * Time-ordered sample ordinal number. It is unique across all profiles retrieved
               * between startSampling and stopSampling.
               */
              ordinal: number;
          }
          /**
           * Sampling profile.
           */
          interface SamplingHeapProfile {
              head: SamplingHeapProfileNode;
              samples: SamplingHeapProfileSample[];
          }
      }
      /**
       * Methods and events of the 'Profiler' domain.
       */
      interface ProfilerApi {
          requests: {
              disable: {
                  params: Profiler.DisableParams;
                  result: Profiler.DisableResult;
              };
              enable: {
                  params: Profiler.EnableParams;
                  result: Profiler.EnableResult;
              };
              /**
               * Collect coverage data for the current isolate. The coverage data may be incomplete due to
               * garbage collection.
               */
              getBestEffortCoverage: {
                  params: Profiler.GetBestEffortCoverageParams;
                  result: Profiler.GetBestEffortCoverageResult;
              };
              /**
               * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
               */
              setSamplingInterval: {
                  params: Profiler.SetSamplingIntervalParams;
                  result: Profiler.SetSamplingIntervalResult;
              };
              start: {
                  params: Profiler.StartParams;
                  result: Profiler.StartResult;
              };
              /**
               * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
               * coverage may be incomplete. Enabling prevents running optimized code and resets execution
               * counters.
               */
              startPreciseCoverage: {
                  params: Profiler.StartPreciseCoverageParams;
                  result: Profiler.StartPreciseCoverageResult;
              };
              stop: {
                  params: Profiler.StopParams;
                  result: Profiler.StopResult;
              };
              /**
               * Disable precise code coverage. Disabling releases unnecessary execution count records and allows
               * executing optimized code.
               */
              stopPreciseCoverage: {
                  params: Profiler.StopPreciseCoverageParams;
                  result: Profiler.StopPreciseCoverageResult;
              };
              /**
               * Collect coverage data for the current isolate, and resets execution counters. Precise code
               * coverage needs to have started.
               */
              takePreciseCoverage: {
                  params: Profiler.TakePreciseCoverageParams;
                  result: Profiler.TakePreciseCoverageResult;
              };
          };
          events: {
              consoleProfileFinished: {
                  params: Profiler.ConsoleProfileFinishedEvent;
              };
              /**
               * Sent when new profile recording is started using console.profile() call.
               */
              consoleProfileStarted: {
                  params: Profiler.ConsoleProfileStartedEvent;
              };
              /**
               * Reports coverage delta since the last poll (either from an event like this, or from
               * `takePreciseCoverage` for the current isolate. May only be sent if precise code
               * coverage has been started. This event can be trigged by the embedder to, for example,
               * trigger collection of coverage data immediately at a certain point in time.
               */
              preciseCoverageDeltaUpdate: {
                  params: Profiler.PreciseCoverageDeltaUpdateEvent;
              };
          };
      }
      /**
       * Types of the 'Profiler' domain.
       */
      namespace Profiler {
          /**
           * Parameters of the 'Profiler.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Profiler.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Profiler.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Profiler.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Profiler.getBestEffortCoverage' method.
           */
          interface GetBestEffortCoverageParams {
          }
          /**
           * Return value of the 'Profiler.getBestEffortCoverage' method.
           */
          interface GetBestEffortCoverageResult {
              /**
               * Coverage data for the current isolate.
               */
              result: ScriptCoverage[];
          }
          /**
           * Parameters of the 'Profiler.setSamplingInterval' method.
           */
          interface SetSamplingIntervalParams {
              /**
               * New sampling interval in microseconds.
               */
              interval: integer;
          }
          /**
           * Return value of the 'Profiler.setSamplingInterval' method.
           */
          interface SetSamplingIntervalResult {
          }
          /**
           * Parameters of the 'Profiler.start' method.
           */
          interface StartParams {
          }
          /**
           * Return value of the 'Profiler.start' method.
           */
          interface StartResult {
          }
          /**
           * Parameters of the 'Profiler.startPreciseCoverage' method.
           */
          interface StartPreciseCoverageParams {
              /**
               * Collect accurate call counts beyond simple 'covered' or 'not covered'.
               */
              callCount?: boolean;
              /**
               * Collect block-based coverage.
               */
              detailed?: boolean;
              /**
               * Allow the backend to send updates on its own initiative
               */
              allowTriggeredUpdates?: boolean;
          }
          /**
           * Return value of the 'Profiler.startPreciseCoverage' method.
           */
          interface StartPreciseCoverageResult {
              /**
               * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
               */
              timestamp: number;
          }
          /**
           * Parameters of the 'Profiler.stop' method.
           */
          interface StopParams {
          }
          /**
           * Return value of the 'Profiler.stop' method.
           */
          interface StopResult {
              /**
               * Recorded profile.
               */
              profile: Profile;
          }
          /**
           * Parameters of the 'Profiler.stopPreciseCoverage' method.
           */
          interface StopPreciseCoverageParams {
          }
          /**
           * Return value of the 'Profiler.stopPreciseCoverage' method.
           */
          interface StopPreciseCoverageResult {
          }
          /**
           * Parameters of the 'Profiler.takePreciseCoverage' method.
           */
          interface TakePreciseCoverageParams {
          }
          /**
           * Return value of the 'Profiler.takePreciseCoverage' method.
           */
          interface TakePreciseCoverageResult {
              /**
               * Coverage data for the current isolate.
               */
              result: ScriptCoverage[];
              /**
               * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
               */
              timestamp: number;
          }
          /**
           * Parameters of the 'Profiler.consoleProfileFinished' event.
           */
          interface ConsoleProfileFinishedEvent {
              id: string;
              /**
               * Location of console.profileEnd().
               */
              location: Debugger.Location;
              profile: Profile;
              /**
               * Profile title passed as an argument to console.profile().
               */
              title?: string;
          }
          /**
           * Parameters of the 'Profiler.consoleProfileStarted' event.
           */
          interface ConsoleProfileStartedEvent {
              id: string;
              /**
               * Location of console.profile().
               */
              location: Debugger.Location;
              /**
               * Profile title passed as an argument to console.profile().
               */
              title?: string;
          }
          /**
           * Parameters of the 'Profiler.preciseCoverageDeltaUpdate' event.
           */
          interface PreciseCoverageDeltaUpdateEvent {
              /**
               * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
               */
              timestamp: number;
              /**
               * Identifier for distinguishing coverage events.
               */
              occasion: string;
              /**
               * Coverage data for the current isolate.
               */
              result: ScriptCoverage[];
          }
          /**
           * Profile node. Holds callsite information, execution statistics and child nodes.
           */
          interface ProfileNode {
              /**
               * Unique id of the node.
               */
              id: integer;
              /**
               * Function location.
               */
              callFrame: Runtime.CallFrame;
              /**
               * Number of samples where this node was on top of the call stack.
               */
              hitCount?: integer;
              /**
               * Child node ids.
               */
              children?: integer[];
              /**
               * The reason of being not optimized. The function may be deoptimized or marked as don't
               * optimize.
               */
              deoptReason?: string;
              /**
               * An array of source position ticks.
               */
              positionTicks?: PositionTickInfo[];
          }
          /**
           * Profile.
           */
          interface Profile {
              /**
               * The list of profile nodes. First item is the root node.
               */
              nodes: ProfileNode[];
              /**
               * Profiling start timestamp in microseconds.
               */
              startTime: number;
              /**
               * Profiling end timestamp in microseconds.
               */
              endTime: number;
              /**
               * Ids of samples top nodes.
               */
              samples?: integer[];
              /**
               * Time intervals between adjacent samples in microseconds. The first delta is relative to the
               * profile startTime.
               */
              timeDeltas?: integer[];
          }
          /**
           * Specifies a number of samples attributed to a certain source position.
           */
          interface PositionTickInfo {
              /**
               * Source line number (1-based).
               */
              line: integer;
              /**
               * Number of samples attributed to the source line.
               */
              ticks: integer;
          }
          /**
           * Coverage data for a source range.
           */
          interface CoverageRange {
              /**
               * JavaScript script source offset for the range start.
               */
              startOffset: integer;
              /**
               * JavaScript script source offset for the range end.
               */
              endOffset: integer;
              /**
               * Collected execution count of the source range.
               */
              count: integer;
          }
          /**
           * Coverage data for a JavaScript function.
           */
          interface FunctionCoverage {
              /**
               * JavaScript function name.
               */
              functionName: string;
              /**
               * Source ranges inside the function with coverage data.
               */
              ranges: CoverageRange[];
              /**
               * Whether coverage data for this function has block granularity.
               */
              isBlockCoverage: boolean;
          }
          /**
           * Coverage data for a JavaScript script.
           */
          interface ScriptCoverage {
              /**
               * JavaScript script id.
               */
              scriptId: Runtime.ScriptId;
              /**
               * JavaScript script name or url.
               */
              url: string;
              /**
               * Functions contained in the script that has coverage data.
               */
              functions: FunctionCoverage[];
          }
      }
      /**
       * Methods and events of the 'Runtime' domain.
       */
      interface RuntimeApi {
          requests: {
              /**
               * Add handler to promise with given promise object id.
               */
              awaitPromise: {
                  params: Runtime.AwaitPromiseParams;
                  result: Runtime.AwaitPromiseResult;
              };
              /**
               * Calls function with given declaration on the given object. Object group of the result is
               * inherited from the target object.
               */
              callFunctionOn: {
                  params: Runtime.CallFunctionOnParams;
                  result: Runtime.CallFunctionOnResult;
              };
              /**
               * Compiles expression.
               */
              compileScript: {
                  params: Runtime.CompileScriptParams;
                  result: Runtime.CompileScriptResult;
              };
              /**
               * Disables reporting of execution contexts creation.
               */
              disable: {
                  params: Runtime.DisableParams;
                  result: Runtime.DisableResult;
              };
              /**
               * Discards collected exceptions and console API calls.
               */
              discardConsoleEntries: {
                  params: Runtime.DiscardConsoleEntriesParams;
                  result: Runtime.DiscardConsoleEntriesResult;
              };
              /**
               * Enables reporting of execution contexts creation by means of `executionContextCreated` event.
               * When the reporting gets enabled the event will be sent immediately for each existing execution
               * context.
               */
              enable: {
                  params: Runtime.EnableParams;
                  result: Runtime.EnableResult;
              };
              /**
               * Evaluates expression on global object.
               */
              evaluate: {
                  params: Runtime.EvaluateParams;
                  result: Runtime.EvaluateResult;
              };
              /**
               * Returns the isolate id.
               */
              getIsolateId: {
                  params: Runtime.GetIsolateIdParams;
                  result: Runtime.GetIsolateIdResult;
              };
              /**
               * Returns the JavaScript heap usage.
               * It is the total usage of the corresponding isolate not scoped to a particular Runtime.
               */
              getHeapUsage: {
                  params: Runtime.GetHeapUsageParams;
                  result: Runtime.GetHeapUsageResult;
              };
              /**
               * Returns properties of a given object. Object group of the result is inherited from the target
               * object.
               */
              getProperties: {
                  params: Runtime.GetPropertiesParams;
                  result: Runtime.GetPropertiesResult;
              };
              /**
               * Returns all let, const and class variables from global scope.
               */
              globalLexicalScopeNames: {
                  params: Runtime.GlobalLexicalScopeNamesParams;
                  result: Runtime.GlobalLexicalScopeNamesResult;
              };
              queryObjects: {
                  params: Runtime.QueryObjectsParams;
                  result: Runtime.QueryObjectsResult;
              };
              /**
               * Releases remote object with given id.
               */
              releaseObject: {
                  params: Runtime.ReleaseObjectParams;
                  result: Runtime.ReleaseObjectResult;
              };
              /**
               * Releases all remote objects that belong to a given group.
               */
              releaseObjectGroup: {
                  params: Runtime.ReleaseObjectGroupParams;
                  result: Runtime.ReleaseObjectGroupResult;
              };
              /**
               * Tells inspected instance to run if it was waiting for debugger to attach.
               */
              runIfWaitingForDebugger: {
                  params: Runtime.RunIfWaitingForDebuggerParams;
                  result: Runtime.RunIfWaitingForDebuggerResult;
              };
              /**
               * Runs script with given id in a given context.
               */
              runScript: {
                  params: Runtime.RunScriptParams;
                  result: Runtime.RunScriptResult;
              };
              /**
               * Enables or disables async call stacks tracking.
               */
              setAsyncCallStackDepth: {
                  params: Runtime.SetAsyncCallStackDepthParams;
                  result: Runtime.SetAsyncCallStackDepthResult;
              };
              setCustomObjectFormatterEnabled: {
                  params: Runtime.SetCustomObjectFormatterEnabledParams;
                  result: Runtime.SetCustomObjectFormatterEnabledResult;
              };
              setMaxCallStackSizeToCapture: {
                  params: Runtime.SetMaxCallStackSizeToCaptureParams;
                  result: Runtime.SetMaxCallStackSizeToCaptureResult;
              };
              /**
               * Terminate current or next JavaScript execution.
               * Will cancel the termination when the outer-most script execution ends.
               */
              terminateExecution: {
                  params: Runtime.TerminateExecutionParams;
                  result: Runtime.TerminateExecutionResult;
              };
              /**
               * If executionContextId is empty, adds binding with the given name on the
               * global objects of all inspected contexts, including those created later,
               * bindings survive reloads.
               * Binding function takes exactly one argument, this argument should be string,
               * in case of any other input, function throws an exception.
               * Each binding function call produces Runtime.bindingCalled notification.
               */
              addBinding: {
                  params: Runtime.AddBindingParams;
                  result: Runtime.AddBindingResult;
              };
              /**
               * This method does not remove binding function from global object but
               * unsubscribes current runtime agent from Runtime.bindingCalled notifications.
               */
              removeBinding: {
                  params: Runtime.RemoveBindingParams;
                  result: Runtime.RemoveBindingResult;
              };
              /**
               * This method tries to lookup and populate exception details for a
               * JavaScript Error object.
               * Note that the stackTrace portion of the resulting exceptionDetails will
               * only be populated if the Runtime domain was enabled at the time when the
               * Error was thrown.
               */
              getExceptionDetails: {
                  params: Runtime.GetExceptionDetailsParams;
                  result: Runtime.GetExceptionDetailsResult;
              };
          };
          events: {
              /**
               * Notification is issued every time when binding is called.
               */
              bindingCalled: {
                  params: Runtime.BindingCalledEvent;
              };
              /**
               * Issued when console API was called.
               */
              consoleAPICalled: {
                  params: Runtime.ConsoleAPICalledEvent;
              };
              /**
               * Issued when unhandled exception was revoked.
               */
              exceptionRevoked: {
                  params: Runtime.ExceptionRevokedEvent;
              };
              /**
               * Issued when exception was thrown and unhandled.
               */
              exceptionThrown: {
                  params: Runtime.ExceptionThrownEvent;
              };
              /**
               * Issued when new execution context is created.
               */
              executionContextCreated: {
                  params: Runtime.ExecutionContextCreatedEvent;
              };
              /**
               * Issued when execution context is destroyed.
               */
              executionContextDestroyed: {
                  params: Runtime.ExecutionContextDestroyedEvent;
              };
              /**
               * Issued when all executionContexts were cleared in browser
               */
              executionContextsCleared: {
                  params: Runtime.ExecutionContextsClearedEvent;
              };
              /**
               * Issued when object should be inspected (for example, as a result of inspect() command line API
               * call).
               */
              inspectRequested: {
                  params: Runtime.InspectRequestedEvent;
              };
          };
      }
      /**
       * Types of the 'Runtime' domain.
       */
      namespace Runtime {
          /**
           * Parameters of the 'Runtime.awaitPromise' method.
           */
          interface AwaitPromiseParams {
              /**
               * Identifier of the promise.
               */
              promiseObjectId: RemoteObjectId;
              /**
               * Whether the result is expected to be a JSON object that should be sent by value.
               */
              returnByValue?: boolean;
              /**
               * Whether preview should be generated for the result.
               */
              generatePreview?: boolean;
          }
          /**
           * Return value of the 'Runtime.awaitPromise' method.
           */
          interface AwaitPromiseResult {
              /**
               * Promise result. Will contain rejected value if promise was rejected.
               */
              result: RemoteObject;
              /**
               * Exception details if stack strace is available.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.callFunctionOn' method.
           */
          interface CallFunctionOnParams {
              /**
               * Declaration of the function to call.
               */
              functionDeclaration: string;
              /**
               * Identifier of the object to call function on. Either objectId or executionContextId should
               * be specified.
               */
              objectId?: RemoteObjectId;
              /**
               * Call arguments. All call arguments must belong to the same JavaScript world as the target
               * object.
               */
              arguments?: CallArgument[];
              /**
               * In silent mode exceptions thrown during evaluation are not reported and do not pause
               * execution. Overrides `setPauseOnException` state.
               */
              silent?: boolean;
              /**
               * Whether the result is expected to be a JSON object which should be sent by value.
               * Can be overriden by `serializationOptions`.
               */
              returnByValue?: boolean;
              /**
               * Whether preview should be generated for the result.
               */
              generatePreview?: boolean;
              /**
               * Whether execution should be treated as initiated by user in the UI.
               */
              userGesture?: boolean;
              /**
               * Whether execution should `await` for resulting value and return once awaited promise is
               * resolved.
               */
              awaitPromise?: boolean;
              /**
               * Specifies execution context which global object will be used to call function on. Either
               * executionContextId or objectId should be specified.
               */
              executionContextId?: ExecutionContextId;
              /**
               * Symbolic group name that can be used to release multiple objects. If objectGroup is not
               * specified and objectId is, objectGroup will be inherited from object.
               */
              objectGroup?: string;
              /**
               * Whether to throw an exception if side effect cannot be ruled out during evaluation.
               */
              throwOnSideEffect?: boolean;
              /**
               * An alternative way to specify the execution context to call function on.
               * Compared to contextId that may be reused across processes, this is guaranteed to be
               * system-unique, so it can be used to prevent accidental function call
               * in context different than intended (e.g. as a result of navigation across process
               * boundaries).
               * This is mutually exclusive with `executionContextId`.
               */
              uniqueContextId?: string;
              /**
               * Specifies the result serialization. If provided, overrides
               * `generatePreview` and `returnByValue`.
               */
              serializationOptions?: SerializationOptions;
          }
          /**
           * Return value of the 'Runtime.callFunctionOn' method.
           */
          interface CallFunctionOnResult {
              /**
               * Call result.
               */
              result: RemoteObject;
              /**
               * Exception details.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.compileScript' method.
           */
          interface CompileScriptParams {
              /**
               * Expression to compile.
               */
              expression: string;
              /**
               * Source url to be set for the script.
               */
              sourceURL: string;
              /**
               * Specifies whether the compiled script should be persisted.
               */
              persistScript: boolean;
              /**
               * Specifies in which execution context to perform script run. If the parameter is omitted the
               * evaluation will be performed in the context of the inspected page.
               */
              executionContextId?: ExecutionContextId;
          }
          /**
           * Return value of the 'Runtime.compileScript' method.
           */
          interface CompileScriptResult {
              /**
               * Id of the script.
               */
              scriptId?: ScriptId;
              /**
               * Exception details.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Runtime.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Runtime.discardConsoleEntries' method.
           */
          interface DiscardConsoleEntriesParams {
          }
          /**
           * Return value of the 'Runtime.discardConsoleEntries' method.
           */
          interface DiscardConsoleEntriesResult {
          }
          /**
           * Parameters of the 'Runtime.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Runtime.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Runtime.evaluate' method.
           */
          interface EvaluateParams {
              /**
               * Expression to evaluate.
               */
              expression: string;
              /**
               * Symbolic group name that can be used to release multiple objects.
               */
              objectGroup?: string;
              /**
               * Determines whether Command Line API should be available during the evaluation.
               */
              includeCommandLineAPI?: boolean;
              /**
               * In silent mode exceptions thrown during evaluation are not reported and do not pause
               * execution. Overrides `setPauseOnException` state.
               */
              silent?: boolean;
              /**
               * Specifies in which execution context to perform evaluation. If the parameter is omitted the
               * evaluation will be performed in the context of the inspected page.
               * This is mutually exclusive with `uniqueContextId`, which offers an
               * alternative way to identify the execution context that is more reliable
               * in a multi-process environment.
               */
              contextId?: ExecutionContextId;
              /**
               * Whether the result is expected to be a JSON object that should be sent by value.
               */
              returnByValue?: boolean;
              /**
               * Whether preview should be generated for the result.
               */
              generatePreview?: boolean;
              /**
               * Whether execution should be treated as initiated by user in the UI.
               */
              userGesture?: boolean;
              /**
               * Whether execution should `await` for resulting value and return once awaited promise is
               * resolved.
               */
              awaitPromise?: boolean;
              /**
               * Whether to throw an exception if side effect cannot be ruled out during evaluation.
               * This implies `disableBreaks` below.
               */
              throwOnSideEffect?: boolean;
              /**
               * Terminate execution after timing out (number of milliseconds).
               */
              timeout?: TimeDelta;
              /**
               * Disable breakpoints during execution.
               */
              disableBreaks?: boolean;
              /**
               * Setting this flag to true enables `let` re-declaration and top-level `await`.
               * Note that `let` variables can only be re-declared if they originate from
               * `replMode` themselves.
               */
              replMode?: boolean;
              /**
               * The Content Security Policy (CSP) for the target might block 'unsafe-eval'
               * which includes eval(), Function(), setTimeout() and setInterval()
               * when called with non-callable arguments. This flag bypasses CSP for this
               * evaluation and allows unsafe-eval. Defaults to true.
               */
              allowUnsafeEvalBlockedByCSP?: boolean;
              /**
               * An alternative way to specify the execution context to evaluate in.
               * Compared to contextId that may be reused across processes, this is guaranteed to be
               * system-unique, so it can be used to prevent accidental evaluation of the expression
               * in context different than intended (e.g. as a result of navigation across process
               * boundaries).
               * This is mutually exclusive with `contextId`.
               */
              uniqueContextId?: string;
              /**
               * Specifies the result serialization. If provided, overrides
               * `generatePreview` and `returnByValue`.
               */
              serializationOptions?: SerializationOptions;
          }
          /**
           * Return value of the 'Runtime.evaluate' method.
           */
          interface EvaluateResult {
              /**
               * Evaluation result.
               */
              result: RemoteObject;
              /**
               * Exception details.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.getIsolateId' method.
           */
          interface GetIsolateIdParams {
          }
          /**
           * Return value of the 'Runtime.getIsolateId' method.
           */
          interface GetIsolateIdResult {
              /**
               * The isolate id.
               */
              id: string;
          }
          /**
           * Parameters of the 'Runtime.getHeapUsage' method.
           */
          interface GetHeapUsageParams {
          }
          /**
           * Return value of the 'Runtime.getHeapUsage' method.
           */
          interface GetHeapUsageResult {
              /**
               * Used heap size in bytes.
               */
              usedSize: number;
              /**
               * Allocated heap size in bytes.
               */
              totalSize: number;
          }
          /**
           * Parameters of the 'Runtime.getProperties' method.
           */
          interface GetPropertiesParams {
              /**
               * Identifier of the object to return properties for.
               */
              objectId: RemoteObjectId;
              /**
               * If true, returns properties belonging only to the element itself, not to its prototype
               * chain.
               */
              ownProperties?: boolean;
              /**
               * If true, returns accessor properties (with getter/setter) only; internal properties are not
               * returned either.
               */
              accessorPropertiesOnly?: boolean;
              /**
               * Whether preview should be generated for the results.
               */
              generatePreview?: boolean;
              /**
               * If true, returns non-indexed properties only.
               */
              nonIndexedPropertiesOnly?: boolean;
          }
          /**
           * Return value of the 'Runtime.getProperties' method.
           */
          interface GetPropertiesResult {
              /**
               * Object properties.
               */
              result: PropertyDescriptor[];
              /**
               * Internal object properties (only of the element itself).
               */
              internalProperties?: InternalPropertyDescriptor[];
              /**
               * Object private properties.
               */
              privateProperties?: PrivatePropertyDescriptor[];
              /**
               * Exception details.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.globalLexicalScopeNames' method.
           */
          interface GlobalLexicalScopeNamesParams {
              /**
               * Specifies in which execution context to lookup global scope variables.
               */
              executionContextId?: ExecutionContextId;
          }
          /**
           * Return value of the 'Runtime.globalLexicalScopeNames' method.
           */
          interface GlobalLexicalScopeNamesResult {
              names: string[];
          }
          /**
           * Parameters of the 'Runtime.queryObjects' method.
           */
          interface QueryObjectsParams {
              /**
               * Identifier of the prototype to return objects for.
               */
              prototypeObjectId: RemoteObjectId;
              /**
               * Symbolic group name that can be used to release the results.
               */
              objectGroup?: string;
          }
          /**
           * Return value of the 'Runtime.queryObjects' method.
           */
          interface QueryObjectsResult {
              /**
               * Array with objects.
               */
              objects: RemoteObject;
          }
          /**
           * Parameters of the 'Runtime.releaseObject' method.
           */
          interface ReleaseObjectParams {
              /**
               * Identifier of the object to release.
               */
              objectId: RemoteObjectId;
          }
          /**
           * Return value of the 'Runtime.releaseObject' method.
           */
          interface ReleaseObjectResult {
          }
          /**
           * Parameters of the 'Runtime.releaseObjectGroup' method.
           */
          interface ReleaseObjectGroupParams {
              /**
               * Symbolic object group name.
               */
              objectGroup: string;
          }
          /**
           * Return value of the 'Runtime.releaseObjectGroup' method.
           */
          interface ReleaseObjectGroupResult {
          }
          /**
           * Parameters of the 'Runtime.runIfWaitingForDebugger' method.
           */
          interface RunIfWaitingForDebuggerParams {
          }
          /**
           * Return value of the 'Runtime.runIfWaitingForDebugger' method.
           */
          interface RunIfWaitingForDebuggerResult {
          }
          /**
           * Parameters of the 'Runtime.runScript' method.
           */
          interface RunScriptParams {
              /**
               * Id of the script to run.
               */
              scriptId: ScriptId;
              /**
               * Specifies in which execution context to perform script run. If the parameter is omitted the
               * evaluation will be performed in the context of the inspected page.
               */
              executionContextId?: ExecutionContextId;
              /**
               * Symbolic group name that can be used to release multiple objects.
               */
              objectGroup?: string;
              /**
               * In silent mode exceptions thrown during evaluation are not reported and do not pause
               * execution. Overrides `setPauseOnException` state.
               */
              silent?: boolean;
              /**
               * Determines whether Command Line API should be available during the evaluation.
               */
              includeCommandLineAPI?: boolean;
              /**
               * Whether the result is expected to be a JSON object which should be sent by value.
               */
              returnByValue?: boolean;
              /**
               * Whether preview should be generated for the result.
               */
              generatePreview?: boolean;
              /**
               * Whether execution should `await` for resulting value and return once awaited promise is
               * resolved.
               */
              awaitPromise?: boolean;
          }
          /**
           * Return value of the 'Runtime.runScript' method.
           */
          interface RunScriptResult {
              /**
               * Run result.
               */
              result: RemoteObject;
              /**
               * Exception details.
               */
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.setAsyncCallStackDepth' method.
           */
          interface SetAsyncCallStackDepthParams {
              /**
               * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
               * call stacks (default).
               */
              maxDepth: integer;
          }
          /**
           * Return value of the 'Runtime.setAsyncCallStackDepth' method.
           */
          interface SetAsyncCallStackDepthResult {
          }
          /**
           * Parameters of the 'Runtime.setCustomObjectFormatterEnabled' method.
           */
          interface SetCustomObjectFormatterEnabledParams {
              enabled: boolean;
          }
          /**
           * Return value of the 'Runtime.setCustomObjectFormatterEnabled' method.
           */
          interface SetCustomObjectFormatterEnabledResult {
          }
          /**
           * Parameters of the 'Runtime.setMaxCallStackSizeToCapture' method.
           */
          interface SetMaxCallStackSizeToCaptureParams {
              size: integer;
          }
          /**
           * Return value of the 'Runtime.setMaxCallStackSizeToCapture' method.
           */
          interface SetMaxCallStackSizeToCaptureResult {
          }
          /**
           * Parameters of the 'Runtime.terminateExecution' method.
           */
          interface TerminateExecutionParams {
          }
          /**
           * Return value of the 'Runtime.terminateExecution' method.
           */
          interface TerminateExecutionResult {
          }
          /**
           * Parameters of the 'Runtime.addBinding' method.
           */
          interface AddBindingParams {
              name: string;
              /**
               * If specified, the binding would only be exposed to the specified
               * execution context. If omitted and `executionContextName` is not set,
               * the binding is exposed to all execution contexts of the target.
               * This parameter is mutually exclusive with `executionContextName`.
               * Deprecated in favor of `executionContextName` due to an unclear use case
               * and bugs in implementation (crbug.com/1169639). `executionContextId` will be
               * removed in the future.
               * @deprecated
               */
              executionContextId?: ExecutionContextId;
              /**
               * If specified, the binding is exposed to the executionContext with
               * matching name, even for contexts created after the binding is added.
               * See also `ExecutionContext.name` and `worldName` parameter to
               * `Page.addScriptToEvaluateOnNewDocument`.
               * This parameter is mutually exclusive with `executionContextId`.
               */
              executionContextName?: string;
          }
          /**
           * Return value of the 'Runtime.addBinding' method.
           */
          interface AddBindingResult {
          }
          /**
           * Parameters of the 'Runtime.removeBinding' method.
           */
          interface RemoveBindingParams {
              name: string;
          }
          /**
           * Return value of the 'Runtime.removeBinding' method.
           */
          interface RemoveBindingResult {
          }
          /**
           * Parameters of the 'Runtime.getExceptionDetails' method.
           */
          interface GetExceptionDetailsParams {
              /**
               * The error object for which to resolve the exception details.
               */
              errorObjectId: RemoteObjectId;
          }
          /**
           * Return value of the 'Runtime.getExceptionDetails' method.
           */
          interface GetExceptionDetailsResult {
              exceptionDetails?: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.bindingCalled' event.
           */
          interface BindingCalledEvent {
              name: string;
              payload: string;
              /**
               * Identifier of the context where the call was made.
               */
              executionContextId: ExecutionContextId;
          }
          /**
           * Parameters of the 'Runtime.consoleAPICalled' event.
           */
          interface ConsoleAPICalledEvent {
              /**
               * Type of the call.
               */
              type: 'log' | 'debug' | 'info' | 'error' | 'warning' | 'dir' | 'dirxml' | 'table' | 'trace' | 'clear' | 'startGroup' | 'startGroupCollapsed' | 'endGroup' | 'assert' | 'profile' | 'profileEnd' | 'count' | 'timeEnd';
              /**
               * Call arguments.
               */
              args: RemoteObject[];
              /**
               * Identifier of the context where the call was made.
               */
              executionContextId: ExecutionContextId;
              /**
               * Call timestamp.
               */
              timestamp: Timestamp;
              /**
               * Stack trace captured when the call was made. The async stack chain is automatically reported for
               * the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
               * chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
               */
              stackTrace?: StackTrace;
              /**
               * Console context descriptor for calls on non-default console context (not console.*):
               * 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
               * on named context.
               */
              context?: string;
          }
          /**
           * Parameters of the 'Runtime.exceptionRevoked' event.
           */
          interface ExceptionRevokedEvent {
              /**
               * Reason describing why exception was revoked.
               */
              reason: string;
              /**
               * The id of revoked exception, as reported in `exceptionThrown`.
               */
              exceptionId: integer;
          }
          /**
           * Parameters of the 'Runtime.exceptionThrown' event.
           */
          interface ExceptionThrownEvent {
              /**
               * Timestamp of the exception.
               */
              timestamp: Timestamp;
              exceptionDetails: ExceptionDetails;
          }
          /**
           * Parameters of the 'Runtime.executionContextCreated' event.
           */
          interface ExecutionContextCreatedEvent {
              /**
               * A newly created execution context.
               */
              context: ExecutionContextDescription;
          }
          /**
           * Parameters of the 'Runtime.executionContextDestroyed' event.
           */
          interface ExecutionContextDestroyedEvent {
              /**
               * Id of the destroyed context
               * @deprecated
               */
              executionContextId: ExecutionContextId;
              /**
               * Unique Id of the destroyed context
               */
              executionContextUniqueId: string;
          }
          /**
           * Parameters of the 'Runtime.executionContextsCleared' event.
           */
          interface ExecutionContextsClearedEvent {
          }
          /**
           * Parameters of the 'Runtime.inspectRequested' event.
           */
          interface InspectRequestedEvent {
              object: RemoteObject;
              hints: Record<string, unknown>;
              /**
               * Identifier of the context where the call was made.
               */
              executionContextId?: ExecutionContextId;
          }
          /**
           * Unique script identifier.
           */
          type ScriptId = string;
          /**
           * Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
           */
          interface SerializationOptions {
              serialization: 'deep' | 'json' | 'idOnly';
              /**
               * Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
               */
              maxDepth?: integer;
              /**
               * Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
               * serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
               * Values can be only of type string or integer.
               */
              additionalParameters?: Record<string, unknown>;
          }
          /**
           * Represents deep serialized value.
           */
          interface DeepSerializedValue {
              type: 'undefined' | 'null' | 'string' | 'number' | 'boolean' | 'bigint' | 'regexp' | 'date' | 'symbol' | 'array' | 'object' | 'function' | 'map' | 'set' | 'weakmap' | 'weakset' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'node' | 'window' | 'generator';
              value?: any;
              objectId?: string;
              /**
               * Set if value reference met more then once during serialization. In such
               * case, value is provided only to one of the serialized values. Unique
               * per value in the scope of one CDP call.
               */
              weakLocalObjectReference?: integer;
          }
          /**
           * Unique object identifier.
           */
          type RemoteObjectId = string;
          /**
           * Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
           * `-Infinity`, and bigint literals.
           */
          type UnserializableValue = string;
          /**
           * Mirror object referencing original JavaScript object.
           */
          interface RemoteObject {
              /**
               * Object type.
               */
              type: 'object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'bigint';
              /**
               * Object subtype hint. Specified for `object` type values only.
               * NOTE: If you change anything here, make sure to also update
               * `subtype` in `ObjectPreview` and `PropertyPreview` below.
               */
              subtype?: 'array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue';
              /**
               * Object class (constructor) name. Specified for `object` type values only.
               */
              className?: string;
              /**
               * Remote object value in case of primitive values or JSON values (if it was requested).
               */
              value?: any;
              /**
               * Primitive value which can not be JSON-stringified does not have `value`, but gets this
               * property.
               */
              unserializableValue?: UnserializableValue;
              /**
               * String representation of the object.
               */
              description?: string;
              /**
               * Deep serialized value.
               */
              deepSerializedValue?: DeepSerializedValue;
              /**
               * Unique object identifier (for non-primitive values).
               */
              objectId?: RemoteObjectId;
              /**
               * Preview containing abbreviated property values. Specified for `object` type values only.
               */
              preview?: ObjectPreview;
              customPreview?: CustomPreview;
          }
          interface CustomPreview {
              /**
               * The JSON-stringified result of formatter.header(object, config) call.
               * It contains json ML array that represents RemoteObject.
               */
              header: string;
              /**
               * If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
               * contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
               * The result value is json ML array.
               */
              bodyGetterId?: RemoteObjectId;
          }
          /**
           * Object containing abbreviated remote object value.
           */
          interface ObjectPreview {
              /**
               * Object type.
               */
              type: 'object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'bigint';
              /**
               * Object subtype hint. Specified for `object` type values only.
               */
              subtype?: 'array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue';
              /**
               * String representation of the object.
               */
              description?: string;
              /**
               * True iff some of the properties or entries of the original object did not fit.
               */
              overflow: boolean;
              /**
               * List of the properties.
               */
              properties: PropertyPreview[];
              /**
               * List of the entries. Specified for `map` and `set` subtype values only.
               */
              entries?: EntryPreview[];
          }
          interface PropertyPreview {
              /**
               * Property name.
               */
              name: string;
              /**
               * Object type. Accessor means that the property itself is an accessor property.
               */
              type: 'object' | 'function' | 'undefined' | 'string' | 'number' | 'boolean' | 'symbol' | 'accessor' | 'bigint';
              /**
               * User-friendly property value string.
               */
              value?: string;
              /**
               * Nested value preview.
               */
              valuePreview?: ObjectPreview;
              /**
               * Object subtype hint. Specified for `object` type values only.
               */
              subtype?: 'array' | 'null' | 'node' | 'regexp' | 'date' | 'map' | 'set' | 'weakmap' | 'weakset' | 'iterator' | 'generator' | 'error' | 'proxy' | 'promise' | 'typedarray' | 'arraybuffer' | 'dataview' | 'webassemblymemory' | 'wasmvalue';
          }
          interface EntryPreview {
              /**
               * Preview of the key. Specified for map-like collection entries.
               */
              key?: ObjectPreview;
              /**
               * Preview of the value.
               */
              value: ObjectPreview;
          }
          /**
           * Object property descriptor.
           */
          interface PropertyDescriptor {
              /**
               * Property name or symbol description.
               */
              name: string;
              /**
               * The value associated with the property.
               */
              value?: RemoteObject;
              /**
               * True if the value associated with the property may be changed (data descriptors only).
               */
              writable?: boolean;
              /**
               * A function which serves as a getter for the property, or `undefined` if there is no getter
               * (accessor descriptors only).
               */
              get?: RemoteObject;
              /**
               * A function which serves as a setter for the property, or `undefined` if there is no setter
               * (accessor descriptors only).
               */
              set?: RemoteObject;
              /**
               * True if the type of this property descriptor may be changed and if the property may be
               * deleted from the corresponding object.
               */
              configurable: boolean;
              /**
               * True if this property shows up during enumeration of the properties on the corresponding
               * object.
               */
              enumerable: boolean;
              /**
               * True if the result was thrown during the evaluation.
               */
              wasThrown?: boolean;
              /**
               * True if the property is owned for the object.
               */
              isOwn?: boolean;
              /**
               * Property symbol object, if the property is of the `symbol` type.
               */
              symbol?: RemoteObject;
          }
          /**
           * Object internal property descriptor. This property isn't normally visible in JavaScript code.
           */
          interface InternalPropertyDescriptor {
              /**
               * Conventional property name.
               */
              name: string;
              /**
               * The value associated with the property.
               */
              value?: RemoteObject;
          }
          /**
           * Object private field descriptor.
           */
          interface PrivatePropertyDescriptor {
              /**
               * Private property name.
               */
              name: string;
              /**
               * The value associated with the private property.
               */
              value?: RemoteObject;
              /**
               * A function which serves as a getter for the private property,
               * or `undefined` if there is no getter (accessor descriptors only).
               */
              get?: RemoteObject;
              /**
               * A function which serves as a setter for the private property,
               * or `undefined` if there is no setter (accessor descriptors only).
               */
              set?: RemoteObject;
          }
          /**
           * Represents function call argument. Either remote object id `objectId`, primitive `value`,
           * unserializable primitive value or neither of (for undefined) them should be specified.
           */
          interface CallArgument {
              /**
               * Primitive value or serializable javascript object.
               */
              value?: any;
              /**
               * Primitive value which can not be JSON-stringified.
               */
              unserializableValue?: UnserializableValue;
              /**
               * Remote object handle.
               */
              objectId?: RemoteObjectId;
          }
          /**
           * Id of an execution context.
           */
          type ExecutionContextId = integer;
          /**
           * Description of an isolated world.
           */
          interface ExecutionContextDescription {
              /**
               * Unique id of the execution context. It can be used to specify in which execution context
               * script evaluation should be performed.
               */
              id: ExecutionContextId;
              /**
               * Execution context origin.
               */
              origin: string;
              /**
               * Human readable name describing given context.
               */
              name: string;
              /**
               * A system-unique execution context identifier. Unlike the id, this is unique across
               * multiple processes, so can be reliably used to identify specific context while backend
               * performs a cross-process navigation.
               */
              uniqueId: string;
              /**
               * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
               */
              auxData?: Record<string, unknown>;
          }
          /**
           * Detailed information about exception (or error) that was thrown during script compilation or
           * execution.
           */
          interface ExceptionDetails {
              /**
               * Exception id.
               */
              exceptionId: integer;
              /**
               * Exception text, which should be used together with exception object when available.
               */
              text: string;
              /**
               * Line number of the exception location (0-based).
               */
              lineNumber: integer;
              /**
               * Column number of the exception location (0-based).
               */
              columnNumber: integer;
              /**
               * Script ID of the exception location.
               */
              scriptId?: ScriptId;
              /**
               * URL of the exception location, to be used when the script was not reported.
               */
              url?: string;
              /**
               * JavaScript stack trace if available.
               */
              stackTrace?: StackTrace;
              /**
               * Exception object if available.
               */
              exception?: RemoteObject;
              /**
               * Identifier of the context where exception happened.
               */
              executionContextId?: ExecutionContextId;
              /**
               * Dictionary with entries of meta data that the client associated
               * with this exception, such as information about associated network
               * requests, etc.
               */
              exceptionMetaData?: Record<string, unknown>;
          }
          /**
           * Number of milliseconds since epoch.
           */
          type Timestamp = number;
          /**
           * Number of milliseconds.
           */
          type TimeDelta = number;
          /**
           * Stack entry for runtime errors and assertions.
           */
          interface CallFrame {
              /**
               * JavaScript function name.
               */
              functionName: string;
              /**
               * JavaScript script id.
               */
              scriptId: ScriptId;
              /**
               * JavaScript script name or url.
               */
              url: string;
              /**
               * JavaScript script line number (0-based).
               */
              lineNumber: integer;
              /**
               * JavaScript script column number (0-based).
               */
              columnNumber: integer;
          }
          /**
           * Call frames for assertions or error messages.
           */
          interface StackTrace {
              /**
               * String label of this stack trace. For async traces this may be a name of the function that
               * initiated the async call.
               */
              description?: string;
              /**
               * JavaScript function name.
               */
              callFrames: CallFrame[];
              /**
               * Asynchronous JavaScript stack trace that preceded this stack, if available.
               */
              parent?: StackTrace;
              /**
               * Asynchronous JavaScript stack trace that preceded this stack, if available.
               */
              parentId?: StackTraceId;
          }
          /**
           * Unique identifier of current debugger.
           */
          type UniqueDebuggerId = string;
          /**
           * If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
           * allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
           */
          interface StackTraceId {
              id: string;
              debuggerId?: UniqueDebuggerId;
          }
      }
      /**
       * Methods and events of the 'Schema' domain.
       */
      interface SchemaApi {
          requests: {
              /**
               * Returns supported domains.
               */
              getDomains: {
                  params: Schema.GetDomainsParams;
                  result: Schema.GetDomainsResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'Schema' domain.
       */
      namespace Schema {
          /**
           * Parameters of the 'Schema.getDomains' method.
           */
          interface GetDomainsParams {
          }
          /**
           * Return value of the 'Schema.getDomains' method.
           */
          interface GetDomainsResult {
              /**
               * List of supported domains.
               */
              domains: Domain[];
          }
          /**
           * Description of the protocol domain.
           */
          interface Domain {
              /**
               * Domain name.
               */
              name: string;
              /**
               * Domain version.
               */
              version: string;
          }
      }
  }
  export namespace CdpBrowser {
      type integer = number;
      /**
       * The list of domains.
       */
      interface Domains {
          Accessibility: AccessibilityApi;
          Animation: AnimationApi;
          Audits: AuditsApi;
          Autofill: AutofillApi;
          BackgroundService: BackgroundServiceApi;
          Browser: BrowserApi;
          CSS: CSSApi;
          CacheStorage: CacheStorageApi;
          Cast: CastApi;
          DOM: DOMApi;
          DOMDebugger: DOMDebuggerApi;
          EventBreakpoints: EventBreakpointsApi;
          DOMSnapshot: DOMSnapshotApi;
          DOMStorage: DOMStorageApi;
          Database: DatabaseApi;
          DeviceOrientation: DeviceOrientationApi;
          Emulation: EmulationApi;
          HeadlessExperimental: HeadlessExperimentalApi;
          IO: IOApi;
          IndexedDB: IndexedDBApi;
          Input: InputApi;
          Inspector: InspectorApi;
          LayerTree: LayerTreeApi;
          Log: LogApi;
          Memory: MemoryApi;
          Network: NetworkApi;
          Overlay: OverlayApi;
          Page: PageApi;
          Performance: PerformanceApi;
          PerformanceTimeline: PerformanceTimelineApi;
          Security: SecurityApi;
          ServiceWorker: ServiceWorkerApi;
          Storage: StorageApi;
          SystemInfo: SystemInfoApi;
          Target: TargetApi;
          Tethering: TetheringApi;
          Tracing: TracingApi;
          Fetch: FetchApi;
          WebAudio: WebAudioApi;
          WebAuthn: WebAuthnApi;
          Media: MediaApi;
          DeviceAccess: DeviceAccessApi;
          Preload: PreloadApi;
          FedCm: FedCmApi;
      }
      /**
       * Methods and events of the 'Accessibility' domain.
       */
      interface AccessibilityApi {
          requests: {
              /**
               * Disables the accessibility domain.
               */
              disable: {
                  params: Accessibility.DisableParams;
                  result: Accessibility.DisableResult;
              };
              /**
               * Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
               * This turns on accessibility for the page, which can impact performance until accessibility is disabled.
               */
              enable: {
                  params: Accessibility.EnableParams;
                  result: Accessibility.EnableResult;
              };
              /**
               * Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
               */
              getPartialAXTree: {
                  params: Accessibility.GetPartialAXTreeParams;
                  result: Accessibility.GetPartialAXTreeResult;
              };
              /**
               * Fetches the entire accessibility tree for the root Document
               */
              getFullAXTree: {
                  params: Accessibility.GetFullAXTreeParams;
                  result: Accessibility.GetFullAXTreeResult;
              };
              /**
               * Fetches the root node.
               * Requires `enable()` to have been called previously.
               */
              getRootAXNode: {
                  params: Accessibility.GetRootAXNodeParams;
                  result: Accessibility.GetRootAXNodeResult;
              };
              /**
               * Fetches a node and all ancestors up to and including the root.
               * Requires `enable()` to have been called previously.
               */
              getAXNodeAndAncestors: {
                  params: Accessibility.GetAXNodeAndAncestorsParams;
                  result: Accessibility.GetAXNodeAndAncestorsResult;
              };
              /**
               * Fetches a particular accessibility node by AXNodeId.
               * Requires `enable()` to have been called previously.
               */
              getChildAXNodes: {
                  params: Accessibility.GetChildAXNodesParams;
                  result: Accessibility.GetChildAXNodesResult;
              };
              /**
               * Query a DOM node's accessibility subtree for accessible name and role.
               * This command computes the name and role for all nodes in the subtree, including those that are
               * ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
               * node is specified, or the DOM node does not exist, the command returns an error. If neither
               * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
               */
              queryAXTree: {
                  params: Accessibility.QueryAXTreeParams;
                  result: Accessibility.QueryAXTreeResult;
              };
          };
          events: {
              /**
               * The loadComplete event mirrors the load complete event sent by the browser to assistive
               * technology when the web page has finished loading.
               */
              loadComplete: {
                  params: Accessibility.LoadCompleteEvent;
              };
              /**
               * The nodesUpdated event is sent every time a previously requested node has changed the in tree.
               */
              nodesUpdated: {
                  params: Accessibility.NodesUpdatedEvent;
              };
          };
      }
      /**
       * Types of the 'Accessibility' domain.
       */
      namespace Accessibility {
          /**
           * Parameters of the 'Accessibility.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Accessibility.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Accessibility.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Accessibility.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Accessibility.getPartialAXTree' method.
           */
          interface GetPartialAXTreeParams {
              /**
               * Identifier of the node to get the partial accessibility tree for.
               */
              nodeId?: DOM.NodeId;
              /**
               * Identifier of the backend node to get the partial accessibility tree for.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * JavaScript object id of the node wrapper to get the partial accessibility tree for.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
              /**
               * Whether to fetch this node's ancestors, siblings and children. Defaults to true.
               */
              fetchRelatives?: boolean;
          }
          /**
           * Return value of the 'Accessibility.getPartialAXTree' method.
           */
          interface GetPartialAXTreeResult {
              /**
               * The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
               * children, if requested.
               */
              nodes: AXNode[];
          }
          /**
           * Parameters of the 'Accessibility.getFullAXTree' method.
           */
          interface GetFullAXTreeParams {
              /**
               * The maximum depth at which descendants of the root node should be retrieved.
               * If omitted, the full tree is returned.
               */
              depth?: integer;
              /**
               * The frame for whose document the AX tree should be retrieved.
               * If omited, the root frame is used.
               */
              frameId?: Page.FrameId;
          }
          /**
           * Return value of the 'Accessibility.getFullAXTree' method.
           */
          interface GetFullAXTreeResult {
              nodes: AXNode[];
          }
          /**
           * Parameters of the 'Accessibility.getRootAXNode' method.
           */
          interface GetRootAXNodeParams {
              /**
               * The frame in whose document the node resides.
               * If omitted, the root frame is used.
               */
              frameId?: Page.FrameId;
          }
          /**
           * Return value of the 'Accessibility.getRootAXNode' method.
           */
          interface GetRootAXNodeResult {
              node: AXNode;
          }
          /**
           * Parameters of the 'Accessibility.getAXNodeAndAncestors' method.
           */
          interface GetAXNodeAndAncestorsParams {
              /**
               * Identifier of the node to get.
               */
              nodeId?: DOM.NodeId;
              /**
               * Identifier of the backend node to get.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * JavaScript object id of the node wrapper to get.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'Accessibility.getAXNodeAndAncestors' method.
           */
          interface GetAXNodeAndAncestorsResult {
              nodes: AXNode[];
          }
          /**
           * Parameters of the 'Accessibility.getChildAXNodes' method.
           */
          interface GetChildAXNodesParams {
              id: AXNodeId;
              /**
               * The frame in whose document the node resides.
               * If omitted, the root frame is used.
               */
              frameId?: Page.FrameId;
          }
          /**
           * Return value of the 'Accessibility.getChildAXNodes' method.
           */
          interface GetChildAXNodesResult {
              nodes: AXNode[];
          }
          /**
           * Parameters of the 'Accessibility.queryAXTree' method.
           */
          interface QueryAXTreeParams {
              /**
               * Identifier of the node for the root to query.
               */
              nodeId?: DOM.NodeId;
              /**
               * Identifier of the backend node for the root to query.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * JavaScript object id of the node wrapper for the root to query.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
              /**
               * Find nodes with this computed name.
               */
              accessibleName?: string;
              /**
               * Find nodes with this computed role.
               */
              role?: string;
          }
          /**
           * Return value of the 'Accessibility.queryAXTree' method.
           */
          interface QueryAXTreeResult {
              /**
               * A list of `Accessibility.AXNode` matching the specified attributes,
               * including nodes that are ignored for accessibility.
               */
              nodes: AXNode[];
          }
          /**
           * Parameters of the 'Accessibility.loadComplete' event.
           */
          interface LoadCompleteEvent {
              /**
               * New document root node.
               */
              root: AXNode;
          }
          /**
           * Parameters of the 'Accessibility.nodesUpdated' event.
           */
          interface NodesUpdatedEvent {
              /**
               * Updated node data.
               */
              nodes: AXNode[];
          }
          /**
           * Unique accessibility node identifier.
           */
          type AXNodeId = string;
          /**
           * Enum of possible property types.
           */
          type AXValueType = 'boolean' | 'tristate' | 'booleanOrUndefined' | 'idref' | 'idrefList' | 'integer' | 'node' | 'nodeList' | 'number' | 'string' | 'computedString' | 'token' | 'tokenList' | 'domRelation' | 'role' | 'internalRole' | 'valueUndefined';
          /**
           * Enum of possible property sources.
           */
          type AXValueSourceType = 'attribute' | 'implicit' | 'style' | 'contents' | 'placeholder' | 'relatedElement';
          /**
           * Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
           */
          type AXValueNativeSourceType = 'description' | 'figcaption' | 'label' | 'labelfor' | 'labelwrapped' | 'legend' | 'rubyannotation' | 'tablecaption' | 'title' | 'other';
          /**
           * A single source for a computed AX property.
           */
          interface AXValueSource {
              /**
               * What type of source this is.
               */
              type: AXValueSourceType;
              /**
               * The value of this property source.
               */
              value?: AXValue;
              /**
               * The name of the relevant attribute, if any.
               */
              attribute?: string;
              /**
               * The value of the relevant attribute, if any.
               */
              attributeValue?: AXValue;
              /**
               * Whether this source is superseded by a higher priority source.
               */
              superseded?: boolean;
              /**
               * The native markup source for this value, e.g. a `<label>` element.
               */
              nativeSource?: AXValueNativeSourceType;
              /**
               * The value, such as a node or node list, of the native source.
               */
              nativeSourceValue?: AXValue;
              /**
               * Whether the value for this property is invalid.
               */
              invalid?: boolean;
              /**
               * Reason for the value being invalid, if it is.
               */
              invalidReason?: string;
          }
          interface AXRelatedNode {
              /**
               * The BackendNodeId of the related DOM node.
               */
              backendDOMNodeId: DOM.BackendNodeId;
              /**
               * The IDRef value provided, if any.
               */
              idref?: string;
              /**
               * The text alternative of this node in the current context.
               */
              text?: string;
          }
          interface AXProperty {
              /**
               * The name of this property.
               */
              name: AXPropertyName;
              /**
               * The value of this property.
               */
              value: AXValue;
          }
          /**
           * A single computed AX property.
           */
          interface AXValue {
              /**
               * The type of this value.
               */
              type: AXValueType;
              /**
               * The computed value of this property.
               */
              value?: any;
              /**
               * One or more related nodes, if applicable.
               */
              relatedNodes?: AXRelatedNode[];
              /**
               * The sources which contributed to the computation of this property.
               */
              sources?: AXValueSource[];
          }
          /**
           * Values of AXProperty name:
           * - from 'busy' to 'roledescription': states which apply to every AX node
           * - from 'live' to 'root': attributes which apply to nodes in live regions
           * - from 'autocomplete' to 'valuetext': attributes which apply to widgets
           * - from 'checked' to 'selected': states which apply to widgets
           * - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
           */
          type AXPropertyName = 'busy' | 'disabled' | 'editable' | 'focusable' | 'focused' | 'hidden' | 'hiddenRoot' | 'invalid' | 'keyshortcuts' | 'settable' | 'roledescription' | 'live' | 'atomic' | 'relevant' | 'root' | 'autocomplete' | 'hasPopup' | 'level' | 'multiselectable' | 'orientation' | 'multiline' | 'readonly' | 'required' | 'valuemin' | 'valuemax' | 'valuetext' | 'checked' | 'expanded' | 'modal' | 'pressed' | 'selected' | 'activedescendant' | 'controls' | 'describedby' | 'details' | 'errormessage' | 'flowto' | 'labelledby' | 'owns';
          /**
           * A node in the accessibility tree.
           */
          interface AXNode {
              /**
               * Unique identifier for this node.
               */
              nodeId: AXNodeId;
              /**
               * Whether this node is ignored for accessibility
               */
              ignored: boolean;
              /**
               * Collection of reasons why this node is hidden.
               */
              ignoredReasons?: AXProperty[];
              /**
               * This `Node`'s role, whether explicit or implicit.
               */
              role?: AXValue;
              /**
               * This `Node`'s Chrome raw role.
               */
              chromeRole?: AXValue;
              /**
               * The accessible name for this `Node`.
               */
              name?: AXValue;
              /**
               * The accessible description for this `Node`.
               */
              description?: AXValue;
              /**
               * The value for this `Node`.
               */
              value?: AXValue;
              /**
               * All other properties
               */
              properties?: AXProperty[];
              /**
               * ID for this node's parent.
               */
              parentId?: AXNodeId;
              /**
               * IDs for each of this node's child nodes.
               */
              childIds?: AXNodeId[];
              /**
               * The backend ID for the associated DOM node, if any.
               */
              backendDOMNodeId?: DOM.BackendNodeId;
              /**
               * The frame ID for the frame associated with this nodes document.
               */
              frameId?: Page.FrameId;
          }
      }
      /**
       * Methods and events of the 'Animation' domain.
       */
      interface AnimationApi {
          requests: {
              /**
               * Disables animation domain notifications.
               */
              disable: {
                  params: Animation.DisableParams;
                  result: Animation.DisableResult;
              };
              /**
               * Enables animation domain notifications.
               */
              enable: {
                  params: Animation.EnableParams;
                  result: Animation.EnableResult;
              };
              /**
               * Returns the current time of the an animation.
               */
              getCurrentTime: {
                  params: Animation.GetCurrentTimeParams;
                  result: Animation.GetCurrentTimeResult;
              };
              /**
               * Gets the playback rate of the document timeline.
               */
              getPlaybackRate: {
                  params: Animation.GetPlaybackRateParams;
                  result: Animation.GetPlaybackRateResult;
              };
              /**
               * Releases a set of animations to no longer be manipulated.
               */
              releaseAnimations: {
                  params: Animation.ReleaseAnimationsParams;
                  result: Animation.ReleaseAnimationsResult;
              };
              /**
               * Gets the remote object of the Animation.
               */
              resolveAnimation: {
                  params: Animation.ResolveAnimationParams;
                  result: Animation.ResolveAnimationResult;
              };
              /**
               * Seek a set of animations to a particular time within each animation.
               */
              seekAnimations: {
                  params: Animation.SeekAnimationsParams;
                  result: Animation.SeekAnimationsResult;
              };
              /**
               * Sets the paused state of a set of animations.
               */
              setPaused: {
                  params: Animation.SetPausedParams;
                  result: Animation.SetPausedResult;
              };
              /**
               * Sets the playback rate of the document timeline.
               */
              setPlaybackRate: {
                  params: Animation.SetPlaybackRateParams;
                  result: Animation.SetPlaybackRateResult;
              };
              /**
               * Sets the timing of an animation node.
               */
              setTiming: {
                  params: Animation.SetTimingParams;
                  result: Animation.SetTimingResult;
              };
          };
          events: {
              /**
               * Event for when an animation has been cancelled.
               */
              animationCanceled: {
                  params: Animation.AnimationCanceledEvent;
              };
              /**
               * Event for each animation that has been created.
               */
              animationCreated: {
                  params: Animation.AnimationCreatedEvent;
              };
              /**
               * Event for animation that has been started.
               */
              animationStarted: {
                  params: Animation.AnimationStartedEvent;
              };
          };
      }
      /**
       * Types of the 'Animation' domain.
       */
      namespace Animation {
          /**
           * Parameters of the 'Animation.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Animation.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Animation.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Animation.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Animation.getCurrentTime' method.
           */
          interface GetCurrentTimeParams {
              /**
               * Id of animation.
               */
              id: string;
          }
          /**
           * Return value of the 'Animation.getCurrentTime' method.
           */
          interface GetCurrentTimeResult {
              /**
               * Current time of the page.
               */
              currentTime: number;
          }
          /**
           * Parameters of the 'Animation.getPlaybackRate' method.
           */
          interface GetPlaybackRateParams {
          }
          /**
           * Return value of the 'Animation.getPlaybackRate' method.
           */
          interface GetPlaybackRateResult {
              /**
               * Playback rate for animations on page.
               */
              playbackRate: number;
          }
          /**
           * Parameters of the 'Animation.releaseAnimations' method.
           */
          interface ReleaseAnimationsParams {
              /**
               * List of animation ids to seek.
               */
              animations: string[];
          }
          /**
           * Return value of the 'Animation.releaseAnimations' method.
           */
          interface ReleaseAnimationsResult {
          }
          /**
           * Parameters of the 'Animation.resolveAnimation' method.
           */
          interface ResolveAnimationParams {
              /**
               * Animation id.
               */
              animationId: string;
          }
          /**
           * Return value of the 'Animation.resolveAnimation' method.
           */
          interface ResolveAnimationResult {
              /**
               * Corresponding remote object.
               */
              remoteObject: CdpV8.Runtime.RemoteObject;
          }
          /**
           * Parameters of the 'Animation.seekAnimations' method.
           */
          interface SeekAnimationsParams {
              /**
               * List of animation ids to seek.
               */
              animations: string[];
              /**
               * Set the current time of each animation.
               */
              currentTime: number;
          }
          /**
           * Return value of the 'Animation.seekAnimations' method.
           */
          interface SeekAnimationsResult {
          }
          /**
           * Parameters of the 'Animation.setPaused' method.
           */
          interface SetPausedParams {
              /**
               * Animations to set the pause state of.
               */
              animations: string[];
              /**
               * Paused state to set to.
               */
              paused: boolean;
          }
          /**
           * Return value of the 'Animation.setPaused' method.
           */
          interface SetPausedResult {
          }
          /**
           * Parameters of the 'Animation.setPlaybackRate' method.
           */
          interface SetPlaybackRateParams {
              /**
               * Playback rate for animations on page
               */
              playbackRate: number;
          }
          /**
           * Return value of the 'Animation.setPlaybackRate' method.
           */
          interface SetPlaybackRateResult {
          }
          /**
           * Parameters of the 'Animation.setTiming' method.
           */
          interface SetTimingParams {
              /**
               * Animation id.
               */
              animationId: string;
              /**
               * Duration of the animation.
               */
              duration: number;
              /**
               * Delay of the animation.
               */
              delay: number;
          }
          /**
           * Return value of the 'Animation.setTiming' method.
           */
          interface SetTimingResult {
          }
          /**
           * Parameters of the 'Animation.animationCanceled' event.
           */
          interface AnimationCanceledEvent {
              /**
               * Id of the animation that was cancelled.
               */
              id: string;
          }
          /**
           * Parameters of the 'Animation.animationCreated' event.
           */
          interface AnimationCreatedEvent {
              /**
               * Id of the animation that was created.
               */
              id: string;
          }
          /**
           * Parameters of the 'Animation.animationStarted' event.
           */
          interface AnimationStartedEvent {
              /**
               * Animation that was started.
               */
              animation: Animation;
          }
          /**
           * Animation instance.
           */
          interface Animation {
              /**
               * `Animation`'s id.
               */
              id: string;
              /**
               * `Animation`'s name.
               */
              name: string;
              /**
               * `Animation`'s internal paused state.
               */
              pausedState: boolean;
              /**
               * `Animation`'s play state.
               */
              playState: string;
              /**
               * `Animation`'s playback rate.
               */
              playbackRate: number;
              /**
               * `Animation`'s start time.
               */
              startTime: number;
              /**
               * `Animation`'s current time.
               */
              currentTime: number;
              /**
               * Animation type of `Animation`.
               */
              type: 'CSSTransition' | 'CSSAnimation' | 'WebAnimation';
              /**
               * `Animation`'s source animation node.
               */
              source?: AnimationEffect;
              /**
               * A unique ID for `Animation` representing the sources that triggered this CSS
               * animation/transition.
               */
              cssId?: string;
          }
          /**
           * AnimationEffect instance
           */
          interface AnimationEffect {
              /**
               * `AnimationEffect`'s delay.
               */
              delay: number;
              /**
               * `AnimationEffect`'s end delay.
               */
              endDelay: number;
              /**
               * `AnimationEffect`'s iteration start.
               */
              iterationStart: number;
              /**
               * `AnimationEffect`'s iterations.
               */
              iterations: number;
              /**
               * `AnimationEffect`'s iteration duration.
               */
              duration: number;
              /**
               * `AnimationEffect`'s playback direction.
               */
              direction: string;
              /**
               * `AnimationEffect`'s fill mode.
               */
              fill: string;
              /**
               * `AnimationEffect`'s target node.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * `AnimationEffect`'s keyframes.
               */
              keyframesRule?: KeyframesRule;
              /**
               * `AnimationEffect`'s timing function.
               */
              easing: string;
          }
          /**
           * Keyframes Rule
           */
          interface KeyframesRule {
              /**
               * CSS keyframed animation's name.
               */
              name?: string;
              /**
               * List of animation keyframes.
               */
              keyframes: KeyframeStyle[];
          }
          /**
           * Keyframe Style
           */
          interface KeyframeStyle {
              /**
               * Keyframe's time offset.
               */
              offset: string;
              /**
               * `AnimationEffect`'s timing function.
               */
              easing: string;
          }
      }
      /**
       * Methods and events of the 'Audits' domain.
       */
      interface AuditsApi {
          requests: {
              /**
               * Returns the response body and size if it were re-encoded with the specified settings. Only
               * applies to images.
               */
              getEncodedResponse: {
                  params: Audits.GetEncodedResponseParams;
                  result: Audits.GetEncodedResponseResult;
              };
              /**
               * Disables issues domain, prevents further issues from being reported to the client.
               */
              disable: {
                  params: Audits.DisableParams;
                  result: Audits.DisableResult;
              };
              /**
               * Enables issues domain, sends the issues collected so far to the client by means of the
               * `issueAdded` event.
               */
              enable: {
                  params: Audits.EnableParams;
                  result: Audits.EnableResult;
              };
              /**
               * Runs the contrast check for the target page. Found issues are reported
               * using Audits.issueAdded event.
               */
              checkContrast: {
                  params: Audits.CheckContrastParams;
                  result: Audits.CheckContrastResult;
              };
              /**
               * Runs the form issues check for the target page. Found issues are reported
               * using Audits.issueAdded event.
               */
              checkFormsIssues: {
                  params: Audits.CheckFormsIssuesParams;
                  result: Audits.CheckFormsIssuesResult;
              };
          };
          events: {
              issueAdded: {
                  params: Audits.IssueAddedEvent;
              };
          };
      }
      /**
       * Types of the 'Audits' domain.
       */
      namespace Audits {
          /**
           * Parameters of the 'Audits.getEncodedResponse' method.
           */
          interface GetEncodedResponseParams {
              /**
               * Identifier of the network request to get content for.
               */
              requestId: Network.RequestId;
              /**
               * The encoding to use.
               */
              encoding: 'webp' | 'jpeg' | 'png';
              /**
               * The quality of the encoding (0-1). (defaults to 1)
               */
              quality?: number;
              /**
               * Whether to only return the size information (defaults to false).
               */
              sizeOnly?: boolean;
          }
          /**
           * Return value of the 'Audits.getEncodedResponse' method.
           */
          interface GetEncodedResponseResult {
              /**
               * The encoded body as a base64 string. Omitted if sizeOnly is true. (Encoded as a base64 string when passed over JSON)
               */
              body?: string;
              /**
               * Size before re-encoding.
               */
              originalSize: integer;
              /**
               * Size after re-encoding.
               */
              encodedSize: integer;
          }
          /**
           * Parameters of the 'Audits.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Audits.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Audits.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Audits.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Audits.checkContrast' method.
           */
          interface CheckContrastParams {
              /**
               * Whether to report WCAG AAA level issues. Default is false.
               */
              reportAAA?: boolean;
          }
          /**
           * Return value of the 'Audits.checkContrast' method.
           */
          interface CheckContrastResult {
          }
          /**
           * Parameters of the 'Audits.checkFormsIssues' method.
           */
          interface CheckFormsIssuesParams {
          }
          /**
           * Return value of the 'Audits.checkFormsIssues' method.
           */
          interface CheckFormsIssuesResult {
              formIssues: GenericIssueDetails[];
          }
          /**
           * Parameters of the 'Audits.issueAdded' event.
           */
          interface IssueAddedEvent {
              issue: InspectorIssue;
          }
          /**
           * Information about a cookie that is affected by an inspector issue.
           */
          interface AffectedCookie {
              /**
               * The following three properties uniquely identify a cookie
               */
              name: string;
              path: string;
              domain: string;
          }
          /**
           * Information about a request that is affected by an inspector issue.
           */
          interface AffectedRequest {
              /**
               * The unique request id.
               */
              requestId: Network.RequestId;
              url?: string;
          }
          /**
           * Information about the frame affected by an inspector issue.
           */
          interface AffectedFrame {
              frameId: Page.FrameId;
          }
          type CookieExclusionReason = 'ExcludeSameSiteUnspecifiedTreatedAsLax' | 'ExcludeSameSiteNoneInsecure' | 'ExcludeSameSiteLax' | 'ExcludeSameSiteStrict' | 'ExcludeInvalidSameParty' | 'ExcludeSamePartyCrossPartyContext' | 'ExcludeDomainNonASCII' | 'ExcludeThirdPartyCookieBlockedInFirstPartySet' | 'ExcludeThirdPartyPhaseout';
          type CookieWarningReason = 'WarnSameSiteUnspecifiedCrossSiteContext' | 'WarnSameSiteNoneInsecure' | 'WarnSameSiteUnspecifiedLaxAllowUnsafe' | 'WarnSameSiteStrictLaxDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeStrict' | 'WarnSameSiteStrictCrossDowngradeLax' | 'WarnSameSiteLaxCrossDowngradeStrict' | 'WarnSameSiteLaxCrossDowngradeLax' | 'WarnAttributeValueExceedsMaxSize' | 'WarnDomainNonASCII' | 'WarnThirdPartyPhaseout' | 'WarnCrossSiteRedirectDowngradeChangesInclusion';
          type CookieOperation = 'SetCookie' | 'ReadCookie';
          /**
           * This information is currently necessary, as the front-end has a difficult
           * time finding a specific cookie. With this, we can convey specific error
           * information without the cookie.
           */
          interface CookieIssueDetails {
              /**
               * If AffectedCookie is not set then rawCookieLine contains the raw
               * Set-Cookie header string. This hints at a problem where the
               * cookie line is syntactically or semantically malformed in a way
               * that no valid cookie could be created.
               */
              cookie?: AffectedCookie;
              rawCookieLine?: string;
              cookieWarningReasons: CookieWarningReason[];
              cookieExclusionReasons: CookieExclusionReason[];
              /**
               * Optionally identifies the site-for-cookies and the cookie url, which
               * may be used by the front-end as additional context.
               */
              operation: CookieOperation;
              siteForCookies?: string;
              cookieUrl?: string;
              request?: AffectedRequest;
          }
          type MixedContentResolutionStatus = 'MixedContentBlocked' | 'MixedContentAutomaticallyUpgraded' | 'MixedContentWarning';
          type MixedContentResourceType = 'AttributionSrc' | 'Audio' | 'Beacon' | 'CSPReport' | 'Download' | 'EventSource' | 'Favicon' | 'Font' | 'Form' | 'Frame' | 'Image' | 'Import' | 'Manifest' | 'Ping' | 'PluginData' | 'PluginResource' | 'Prefetch' | 'Resource' | 'Script' | 'ServiceWorker' | 'SharedWorker' | 'SpeculationRules' | 'Stylesheet' | 'Track' | 'Video' | 'Worker' | 'XMLHttpRequest' | 'XSLT';
          interface MixedContentIssueDetails {
              /**
               * The type of resource causing the mixed content issue (css, js, iframe,
               * form,...). Marked as optional because it is mapped to from
               * blink::mojom::RequestContextType, which will be replaced
               * by network::mojom::RequestDestination
               */
              resourceType?: MixedContentResourceType;
              /**
               * The way the mixed content issue is being resolved.
               */
              resolutionStatus: MixedContentResolutionStatus;
              /**
               * The unsafe http url causing the mixed content issue.
               */
              insecureURL: string;
              /**
               * The url responsible for the call to an unsafe url.
               */
              mainResourceURL: string;
              /**
               * The mixed content request.
               * Does not always exist (e.g. for unsafe form submission urls).
               */
              request?: AffectedRequest;
              /**
               * Optional because not every mixed content issue is necessarily linked to a frame.
               */
              frame?: AffectedFrame;
          }
          /**
           * Enum indicating the reason a response has been blocked. These reasons are
           * refinements of the net error BLOCKED_BY_RESPONSE.
           */
          type BlockedByResponseReason = 'CoepFrameResourceNeedsCoepHeader' | 'CoopSandboxedIFrameCannotNavigateToCoopPage' | 'CorpNotSameOrigin' | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep' | 'CorpNotSameSite';
          /**
           * Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
           * code. Currently only used for COEP/COOP, but may be extended to include
           * some CSP errors in the future.
           */
          interface BlockedByResponseIssueDetails {
              request: AffectedRequest;
              parentFrame?: AffectedFrame;
              blockedFrame?: AffectedFrame;
              reason: BlockedByResponseReason;
          }
          type HeavyAdResolutionStatus = 'HeavyAdBlocked' | 'HeavyAdWarning';
          type HeavyAdReason = 'NetworkTotalLimit' | 'CpuTotalLimit' | 'CpuPeakLimit';
          interface HeavyAdIssueDetails {
              /**
               * The resolution status, either blocking the content or warning.
               */
              resolution: HeavyAdResolutionStatus;
              /**
               * The reason the ad was blocked, total network or cpu or peak cpu.
               */
              reason: HeavyAdReason;
              /**
               * The frame that was blocked.
               */
              frame: AffectedFrame;
          }
          type ContentSecurityPolicyViolationType = 'kInlineViolation' | 'kEvalViolation' | 'kURLViolation' | 'kTrustedTypesSinkViolation' | 'kTrustedTypesPolicyViolation' | 'kWasmEvalViolation';
          interface SourceCodeLocation {
              scriptId?: CdpV8.Runtime.ScriptId;
              url: string;
              lineNumber: integer;
              columnNumber: integer;
          }
          interface ContentSecurityPolicyIssueDetails {
              /**
               * The url not included in allowed sources.
               */
              blockedURL?: string;
              /**
               * Specific directive that is violated, causing the CSP issue.
               */
              violatedDirective: string;
              isReportOnly: boolean;
              contentSecurityPolicyViolationType: ContentSecurityPolicyViolationType;
              frameAncestor?: AffectedFrame;
              sourceCodeLocation?: SourceCodeLocation;
              violatingNodeId?: DOM.BackendNodeId;
          }
          type SharedArrayBufferIssueType = 'TransferIssue' | 'CreationIssue';
          /**
           * Details for a issue arising from an SAB being instantiated in, or
           * transferred to a context that is not cross-origin isolated.
           */
          interface SharedArrayBufferIssueDetails {
              sourceCodeLocation: SourceCodeLocation;
              isWarning: boolean;
              type: SharedArrayBufferIssueType;
          }
          interface LowTextContrastIssueDetails {
              violatingNodeId: DOM.BackendNodeId;
              violatingNodeSelector: string;
              contrastRatio: number;
              thresholdAA: number;
              thresholdAAA: number;
              fontSize: string;
              fontWeight: string;
          }
          /**
           * Details for a CORS related issue, e.g. a warning or error related to
           * CORS RFC1918 enforcement.
           */
          interface CorsIssueDetails {
              corsErrorStatus: Network.CorsErrorStatus;
              isWarning: boolean;
              request: AffectedRequest;
              location?: SourceCodeLocation;
              initiatorOrigin?: string;
              resourceIPAddressSpace?: Network.IPAddressSpace;
              clientSecurityState?: Network.ClientSecurityState;
          }
          type AttributionReportingIssueType = 'PermissionPolicyDisabled' | 'UntrustworthyReportingOrigin' | 'InsecureContext' | 'InvalidHeader' | 'InvalidRegisterTriggerHeader' | 'SourceAndTriggerHeaders' | 'SourceIgnored' | 'TriggerIgnored' | 'OsSourceIgnored' | 'OsTriggerIgnored' | 'InvalidRegisterOsSourceHeader' | 'InvalidRegisterOsTriggerHeader' | 'WebAndOsHeaders' | 'NoWebOrOsSupport' | 'NavigationRegistrationWithoutTransientUserActivation';
          /**
           * Details for issues around "Attribution Reporting API" usage.
           * Explainer: https://github.com/WICG/attribution-reporting-api
           */
          interface AttributionReportingIssueDetails {
              violationType: AttributionReportingIssueType;
              request?: AffectedRequest;
              violatingNodeId?: DOM.BackendNodeId;
              invalidParameter?: string;
          }
          /**
           * Details for issues about documents in Quirks Mode
           * or Limited Quirks Mode that affects page layouting.
           */
          interface QuirksModeIssueDetails {
              /**
               * If false, it means the document's mode is "quirks"
               * instead of "limited-quirks".
               */
              isLimitedQuirksMode: boolean;
              documentNodeId: DOM.BackendNodeId;
              url: string;
              frameId: Page.FrameId;
              loaderId: Network.LoaderId;
          }
          /**
           *
           * @deprecated
           */
          interface NavigatorUserAgentIssueDetails {
              url: string;
              location?: SourceCodeLocation;
          }
          type GenericIssueErrorType = 'CrossOriginPortalPostMessageError' | 'FormLabelForNameError' | 'FormDuplicateIdForInputError' | 'FormInputWithNoLabelError' | 'FormAutocompleteAttributeEmptyError' | 'FormEmptyIdAndNameAttributesForInputError' | 'FormAriaLabelledByToNonExistingId' | 'FormInputAssignedAutocompleteValueToIdOrNameAttributeError' | 'FormLabelHasNeitherForNorNestedInput' | 'FormLabelForMatchesNonExistingIdError' | 'FormInputHasWrongButWellIntendedAutocompleteValueError' | 'ResponseWasBlockedByORB';
          /**
           * Depending on the concrete errorType, different properties are set.
           */
          interface GenericIssueDetails {
              /**
               * Issues with the same errorType are aggregated in the frontend.
               */
              errorType: GenericIssueErrorType;
              frameId?: Page.FrameId;
              violatingNodeId?: DOM.BackendNodeId;
              violatingNodeAttribute?: string;
              request?: AffectedRequest;
          }
          /**
           * This issue tracks information needed to print a deprecation message.
           * https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
           */
          interface DeprecationIssueDetails {
              affectedFrame?: AffectedFrame;
              sourceCodeLocation: SourceCodeLocation;
              /**
               * One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
               */
              type: string;
          }
          /**
           * This issue warns about sites in the redirect chain of a finished navigation
           * that may be flagged as trackers and have their state cleared if they don't
           * receive a user interaction. Note that in this context 'site' means eTLD+1.
           * For example, if the URL `https://example.test:80/bounce` was in the
           * redirect chain, the site reported would be `example.test`.
           */
          interface BounceTrackingIssueDetails {
              trackingSites: string[];
          }
          /**
           * This issue warns about third-party sites that are accessing cookies on the
           * current page, and have been permitted due to having a global metadata grant.
           * Note that in this context 'site' means eTLD+1. For example, if the URL
           * `https://example.test:80/web_page` was accessing cookies, the site reported
           * would be `example.test`.
           */
          interface CookieDeprecationMetadataIssueDetails {
              allowedSites: string[];
          }
          type ClientHintIssueReason = 'MetaTagAllowListInvalidOrigin' | 'MetaTagModifiedHTML';
          interface FederatedAuthRequestIssueDetails {
              federatedAuthRequestIssueReason: FederatedAuthRequestIssueReason;
          }
          /**
           * Represents the failure reason when a federated authentication reason fails.
           * Should be updated alongside RequestIdTokenStatus in
           * third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
           * all cases except for success.
           */
          type FederatedAuthRequestIssueReason = 'ShouldEmbargo' | 'TooManyRequests' | 'WellKnownHttpNotFound' | 'WellKnownNoResponse' | 'WellKnownInvalidResponse' | 'WellKnownListEmpty' | 'WellKnownInvalidContentType' | 'ConfigNotInWellKnown' | 'WellKnownTooBig' | 'ConfigHttpNotFound' | 'ConfigNoResponse' | 'ConfigInvalidResponse' | 'ConfigInvalidContentType' | 'ClientMetadataHttpNotFound' | 'ClientMetadataNoResponse' | 'ClientMetadataInvalidResponse' | 'ClientMetadataInvalidContentType' | 'DisabledInSettings' | 'ErrorFetchingSignin' | 'InvalidSigninResponse' | 'AccountsHttpNotFound' | 'AccountsNoResponse' | 'AccountsInvalidResponse' | 'AccountsListEmpty' | 'AccountsInvalidContentType' | 'IdTokenHttpNotFound' | 'IdTokenNoResponse' | 'IdTokenInvalidResponse' | 'IdTokenIdpErrorResponse' | 'IdTokenCrossSiteIdpErrorResponse' | 'IdTokenInvalidRequest' | 'IdTokenInvalidContentType' | 'ErrorIdToken' | 'Canceled' | 'RpPageNotVisible' | 'SilentMediationFailure' | 'ThirdPartyCookiesBlocked' | 'NotSignedInWithIdp';
          interface FederatedAuthUserInfoRequestIssueDetails {
              federatedAuthUserInfoRequestIssueReason: FederatedAuthUserInfoRequestIssueReason;
          }
          /**
           * Represents the failure reason when a getUserInfo() call fails.
           * Should be updated alongside FederatedAuthUserInfoRequestResult in
           * third_party/blink/public/mojom/devtools/inspector_issue.mojom.
           */
          type FederatedAuthUserInfoRequestIssueReason = 'NotSameOrigin' | 'NotIframe' | 'NotPotentiallyTrustworthy' | 'NoApiPermission' | 'NotSignedInWithIdp' | 'NoAccountSharingPermission' | 'InvalidConfigOrWellKnown' | 'InvalidAccountsResponse' | 'NoReturningUserFromFetchedAccounts';
          /**
           * This issue tracks client hints related issues. It's used to deprecate old
           * features, encourage the use of new ones, and provide general guidance.
           */
          interface ClientHintIssueDetails {
              sourceCodeLocation: SourceCodeLocation;
              clientHintIssueReason: ClientHintIssueReason;
          }
          interface FailedRequestInfo {
              /**
               * The URL that failed to load.
               */
              url: string;
              /**
               * The failure message for the failed request.
               */
              failureMessage: string;
              requestId?: Network.RequestId;
          }
          type StyleSheetLoadingIssueReason = 'LateImportRule' | 'RequestFailed';
          /**
           * This issue warns when a referenced stylesheet couldn't be loaded.
           */
          interface StylesheetLoadingIssueDetails {
              /**
               * Source code position that referenced the failing stylesheet.
               */
              sourceCodeLocation: SourceCodeLocation;
              /**
               * Reason why the stylesheet couldn't be loaded.
               */
              styleSheetLoadingIssueReason: StyleSheetLoadingIssueReason;
              /**
               * Contains additional info when the failure was due to a request.
               */
              failedRequestInfo?: FailedRequestInfo;
          }
          type PropertyRuleIssueReason = 'InvalidSyntax' | 'InvalidInitialValue' | 'InvalidInherits' | 'InvalidName';
          /**
           * This issue warns about errors in property rules that lead to property
           * registrations being ignored.
           */
          interface PropertyRuleIssueDetails {
              /**
               * Source code position of the property rule.
               */
              sourceCodeLocation: SourceCodeLocation;
              /**
               * Reason why the property rule was discarded.
               */
              propertyRuleIssueReason: PropertyRuleIssueReason;
              /**
               * The value of the property rule property that failed to parse
               */
              propertyValue?: string;
          }
          /**
           * A unique identifier for the type of issue. Each type may use one of the
           * optional fields in InspectorIssueDetails to convey more specific
           * information about the kind of issue.
           */
          type InspectorIssueCode = 'CookieIssue' | 'MixedContentIssue' | 'BlockedByResponseIssue' | 'HeavyAdIssue' | 'ContentSecurityPolicyIssue' | 'SharedArrayBufferIssue' | 'LowTextContrastIssue' | 'CorsIssue' | 'AttributionReportingIssue' | 'QuirksModeIssue' | 'NavigatorUserAgentIssue' | 'GenericIssue' | 'DeprecationIssue' | 'ClientHintIssue' | 'FederatedAuthRequestIssue' | 'BounceTrackingIssue' | 'CookieDeprecationMetadataIssue' | 'StylesheetLoadingIssue' | 'FederatedAuthUserInfoRequestIssue' | 'PropertyRuleIssue';
          /**
           * This struct holds a list of optional fields with additional information
           * specific to the kind of issue. When adding a new issue code, please also
           * add a new optional field to this type.
           */
          interface InspectorIssueDetails {
              cookieIssueDetails?: CookieIssueDetails;
              mixedContentIssueDetails?: MixedContentIssueDetails;
              blockedByResponseIssueDetails?: BlockedByResponseIssueDetails;
              heavyAdIssueDetails?: HeavyAdIssueDetails;
              contentSecurityPolicyIssueDetails?: ContentSecurityPolicyIssueDetails;
              sharedArrayBufferIssueDetails?: SharedArrayBufferIssueDetails;
              lowTextContrastIssueDetails?: LowTextContrastIssueDetails;
              corsIssueDetails?: CorsIssueDetails;
              attributionReportingIssueDetails?: AttributionReportingIssueDetails;
              quirksModeIssueDetails?: QuirksModeIssueDetails;
              /**
               *
               * @deprecated
               */
              navigatorUserAgentIssueDetails?: NavigatorUserAgentIssueDetails;
              genericIssueDetails?: GenericIssueDetails;
              deprecationIssueDetails?: DeprecationIssueDetails;
              clientHintIssueDetails?: ClientHintIssueDetails;
              federatedAuthRequestIssueDetails?: FederatedAuthRequestIssueDetails;
              bounceTrackingIssueDetails?: BounceTrackingIssueDetails;
              cookieDeprecationMetadataIssueDetails?: CookieDeprecationMetadataIssueDetails;
              stylesheetLoadingIssueDetails?: StylesheetLoadingIssueDetails;
              propertyRuleIssueDetails?: PropertyRuleIssueDetails;
              federatedAuthUserInfoRequestIssueDetails?: FederatedAuthUserInfoRequestIssueDetails;
          }
          /**
           * A unique id for a DevTools inspector issue. Allows other entities (e.g.
           * exceptions, CDP message, console messages, etc.) to reference an issue.
           */
          type IssueId = string;
          /**
           * An inspector issue reported from the back-end.
           */
          interface InspectorIssue {
              code: InspectorIssueCode;
              details: InspectorIssueDetails;
              /**
               * A unique id for this issue. May be omitted if no other entity (e.g.
               * exception, CDP message, etc.) is referencing this issue.
               */
              issueId?: IssueId;
          }
      }
      /**
       * Methods and events of the 'Autofill' domain.
       */
      interface AutofillApi {
          requests: {
              /**
               * Trigger autofill on a form identified by the fieldId.
               * If the field and related form cannot be autofilled, returns an error.
               */
              trigger: {
                  params: Autofill.TriggerParams;
                  result: Autofill.TriggerResult;
              };
              /**
               * Set addresses so that developers can verify their forms implementation.
               */
              setAddresses: {
                  params: Autofill.SetAddressesParams;
                  result: Autofill.SetAddressesResult;
              };
              /**
               * Disables autofill domain notifications.
               */
              disable: {
                  params: Autofill.DisableParams;
                  result: Autofill.DisableResult;
              };
              /**
               * Enables autofill domain notifications.
               */
              enable: {
                  params: Autofill.EnableParams;
                  result: Autofill.EnableResult;
              };
          };
          events: {
              /**
               * Emitted when an address form is filled.
               */
              addressFormFilled: {
                  params: Autofill.AddressFormFilledEvent;
              };
          };
      }
      /**
       * Types of the 'Autofill' domain.
       */
      namespace Autofill {
          /**
           * Parameters of the 'Autofill.trigger' method.
           */
          interface TriggerParams {
              /**
               * Identifies a field that serves as an anchor for autofill.
               */
              fieldId: DOM.BackendNodeId;
              /**
               * Identifies the frame that field belongs to.
               */
              frameId?: Page.FrameId;
              /**
               * Credit card information to fill out the form. Credit card data is not saved.
               */
              card: CreditCard;
          }
          /**
           * Return value of the 'Autofill.trigger' method.
           */
          interface TriggerResult {
          }
          /**
           * Parameters of the 'Autofill.setAddresses' method.
           */
          interface SetAddressesParams {
              addresses: Address[];
          }
          /**
           * Return value of the 'Autofill.setAddresses' method.
           */
          interface SetAddressesResult {
          }
          /**
           * Parameters of the 'Autofill.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Autofill.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Autofill.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Autofill.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Autofill.addressFormFilled' event.
           */
          interface AddressFormFilledEvent {
              /**
               * Information about the fields that were filled
               */
              filledFields: FilledField[];
              /**
               * An UI representation of the address used to fill the form.
               * Consists of a 2D array where each child represents an address/profile line.
               */
              addressUi: AddressUI;
          }
          interface CreditCard {
              /**
               * 16-digit credit card number.
               */
              number: string;
              /**
               * Name of the credit card owner.
               */
              name: string;
              /**
               * 2-digit expiry month.
               */
              expiryMonth: string;
              /**
               * 4-digit expiry year.
               */
              expiryYear: string;
              /**
               * 3-digit card verification code.
               */
              cvc: string;
          }
          interface AddressField {
              /**
               * address field name, for example GIVEN_NAME.
               */
              name: string;
              /**
               * address field value, for example Jon Doe.
               */
              value: string;
          }
          /**
           * A list of address fields.
           */
          interface AddressFields {
              fields: AddressField[];
          }
          interface Address {
              /**
               * fields and values defining an address.
               */
              fields: AddressField[];
          }
          /**
           * Defines how an address can be displayed like in chrome://settings/addresses.
           * Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such.
           * The following address UI for instance:
           * [[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]]
           * should allow the receiver to render:
           * Jon Doe
           * Munich 81456
           */
          interface AddressUI {
              /**
               * A two dimension array containing the repesentation of values from an address profile.
               */
              addressFields: AddressFields[];
          }
          /**
           * Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics.
           */
          type FillingStrategy = 'autocompleteAttribute' | 'autofillInferred';
          interface FilledField {
              /**
               * The type of the field, e.g text, password etc.
               */
              htmlType: string;
              /**
               * the html id
               */
              id: string;
              /**
               * the html name
               */
              name: string;
              /**
               * the field value
               */
              value: string;
              /**
               * The actual field type, e.g FAMILY_NAME
               */
              autofillType: string;
              /**
               * The filling strategy
               */
              fillingStrategy: FillingStrategy;
              /**
               * The form field's DOM node
               */
              fieldId: DOM.BackendNodeId;
          }
      }
      /**
       * Methods and events of the 'BackgroundService' domain.
       */
      interface BackgroundServiceApi {
          requests: {
              /**
               * Enables event updates for the service.
               */
              startObserving: {
                  params: BackgroundService.StartObservingParams;
                  result: BackgroundService.StartObservingResult;
              };
              /**
               * Disables event updates for the service.
               */
              stopObserving: {
                  params: BackgroundService.StopObservingParams;
                  result: BackgroundService.StopObservingResult;
              };
              /**
               * Set the recording state for the service.
               */
              setRecording: {
                  params: BackgroundService.SetRecordingParams;
                  result: BackgroundService.SetRecordingResult;
              };
              /**
               * Clears all stored data for the service.
               */
              clearEvents: {
                  params: BackgroundService.ClearEventsParams;
                  result: BackgroundService.ClearEventsResult;
              };
          };
          events: {
              /**
               * Called when the recording state for the service has been updated.
               */
              recordingStateChanged: {
                  params: BackgroundService.RecordingStateChangedEvent;
              };
              /**
               * Called with all existing backgroundServiceEvents when enabled, and all new
               * events afterwards if enabled and recording.
               */
              backgroundServiceEventReceived: {
                  params: BackgroundService.BackgroundServiceEventReceivedEvent;
              };
          };
      }
      /**
       * Types of the 'BackgroundService' domain.
       */
      namespace BackgroundService {
          /**
           * Parameters of the 'BackgroundService.startObserving' method.
           */
          interface StartObservingParams {
              service: ServiceName;
          }
          /**
           * Return value of the 'BackgroundService.startObserving' method.
           */
          interface StartObservingResult {
          }
          /**
           * Parameters of the 'BackgroundService.stopObserving' method.
           */
          interface StopObservingParams {
              service: ServiceName;
          }
          /**
           * Return value of the 'BackgroundService.stopObserving' method.
           */
          interface StopObservingResult {
          }
          /**
           * Parameters of the 'BackgroundService.setRecording' method.
           */
          interface SetRecordingParams {
              shouldRecord: boolean;
              service: ServiceName;
          }
          /**
           * Return value of the 'BackgroundService.setRecording' method.
           */
          interface SetRecordingResult {
          }
          /**
           * Parameters of the 'BackgroundService.clearEvents' method.
           */
          interface ClearEventsParams {
              service: ServiceName;
          }
          /**
           * Return value of the 'BackgroundService.clearEvents' method.
           */
          interface ClearEventsResult {
          }
          /**
           * Parameters of the 'BackgroundService.recordingStateChanged' event.
           */
          interface RecordingStateChangedEvent {
              isRecording: boolean;
              service: ServiceName;
          }
          /**
           * Parameters of the 'BackgroundService.backgroundServiceEventReceived' event.
           */
          interface BackgroundServiceEventReceivedEvent {
              backgroundServiceEvent: BackgroundServiceEvent;
          }
          /**
           * The Background Service that will be associated with the commands/events.
           * Every Background Service operates independently, but they share the same
           * API.
           */
          type ServiceName = 'backgroundFetch' | 'backgroundSync' | 'pushMessaging' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync';
          /**
           * A key-value pair for additional event information to pass along.
           */
          interface EventMetadata {
              key: string;
              value: string;
          }
          interface BackgroundServiceEvent {
              /**
               * Timestamp of the event (in seconds).
               */
              timestamp: Network.TimeSinceEpoch;
              /**
               * The origin this event belongs to.
               */
              origin: string;
              /**
               * The Service Worker ID that initiated the event.
               */
              serviceWorkerRegistrationId: ServiceWorker.RegistrationID;
              /**
               * The Background Service this event belongs to.
               */
              service: ServiceName;
              /**
               * A description of the event.
               */
              eventName: string;
              /**
               * An identifier that groups related events together.
               */
              instanceId: string;
              /**
               * A list of event-specific information.
               */
              eventMetadata: EventMetadata[];
              /**
               * Storage key this event belongs to.
               */
              storageKey: string;
          }
      }
      /**
       * Methods and events of the 'Browser' domain.
       */
      interface BrowserApi {
          requests: {
              /**
               * Set permission settings for given origin.
               */
              setPermission: {
                  params: Browser.SetPermissionParams;
                  result: Browser.SetPermissionResult;
              };
              /**
               * Grant specific permissions to the given origin and reject all others.
               */
              grantPermissions: {
                  params: Browser.GrantPermissionsParams;
                  result: Browser.GrantPermissionsResult;
              };
              /**
               * Reset all permission management for all origins.
               */
              resetPermissions: {
                  params: Browser.ResetPermissionsParams;
                  result: Browser.ResetPermissionsResult;
              };
              /**
               * Set the behavior when downloading a file.
               */
              setDownloadBehavior: {
                  params: Browser.SetDownloadBehaviorParams;
                  result: Browser.SetDownloadBehaviorResult;
              };
              /**
               * Cancel a download if in progress
               */
              cancelDownload: {
                  params: Browser.CancelDownloadParams;
                  result: Browser.CancelDownloadResult;
              };
              /**
               * Close browser gracefully.
               */
              close: {
                  params: Browser.CloseParams;
                  result: Browser.CloseResult;
              };
              /**
               * Crashes browser on the main thread.
               */
              crash: {
                  params: Browser.CrashParams;
                  result: Browser.CrashResult;
              };
              /**
               * Crashes GPU process.
               */
              crashGpuProcess: {
                  params: Browser.CrashGpuProcessParams;
                  result: Browser.CrashGpuProcessResult;
              };
              /**
               * Returns version information.
               */
              getVersion: {
                  params: Browser.GetVersionParams;
                  result: Browser.GetVersionResult;
              };
              /**
               * Returns the command line switches for the browser process if, and only if
               * --enable-automation is on the commandline.
               */
              getBrowserCommandLine: {
                  params: Browser.GetBrowserCommandLineParams;
                  result: Browser.GetBrowserCommandLineResult;
              };
              /**
               * Get Chrome histograms.
               */
              getHistograms: {
                  params: Browser.GetHistogramsParams;
                  result: Browser.GetHistogramsResult;
              };
              /**
               * Get a Chrome histogram by name.
               */
              getHistogram: {
                  params: Browser.GetHistogramParams;
                  result: Browser.GetHistogramResult;
              };
              /**
               * Get position and size of the browser window.
               */
              getWindowBounds: {
                  params: Browser.GetWindowBoundsParams;
                  result: Browser.GetWindowBoundsResult;
              };
              /**
               * Get the browser window that contains the devtools target.
               */
              getWindowForTarget: {
                  params: Browser.GetWindowForTargetParams;
                  result: Browser.GetWindowForTargetResult;
              };
              /**
               * Set position and/or size of the browser window.
               */
              setWindowBounds: {
                  params: Browser.SetWindowBoundsParams;
                  result: Browser.SetWindowBoundsResult;
              };
              /**
               * Set dock tile details, platform-specific.
               */
              setDockTile: {
                  params: Browser.SetDockTileParams;
                  result: Browser.SetDockTileResult;
              };
              /**
               * Invoke custom browser commands used by telemetry.
               */
              executeBrowserCommand: {
                  params: Browser.ExecuteBrowserCommandParams;
                  result: Browser.ExecuteBrowserCommandResult;
              };
              /**
               * Allows a site to use privacy sandbox features that require enrollment
               * without the site actually being enrolled. Only supported on page targets.
               */
              addPrivacySandboxEnrollmentOverride: {
                  params: Browser.AddPrivacySandboxEnrollmentOverrideParams;
                  result: Browser.AddPrivacySandboxEnrollmentOverrideResult;
              };
          };
          events: {
              /**
               * Fired when page is about to start a download.
               */
              downloadWillBegin: {
                  params: Browser.DownloadWillBeginEvent;
              };
              /**
               * Fired when download makes progress. Last call has |done| == true.
               */
              downloadProgress: {
                  params: Browser.DownloadProgressEvent;
              };
          };
      }
      /**
       * Types of the 'Browser' domain.
       */
      namespace Browser {
          /**
           * Parameters of the 'Browser.setPermission' method.
           */
          interface SetPermissionParams {
              /**
               * Descriptor of permission to override.
               */
              permission: PermissionDescriptor;
              /**
               * Setting of the permission.
               */
              setting: PermissionSetting;
              /**
               * Origin the permission applies to, all origins if not specified.
               */
              origin?: string;
              /**
               * Context to override. When omitted, default browser context is used.
               */
              browserContextId?: BrowserContextID;
          }
          /**
           * Return value of the 'Browser.setPermission' method.
           */
          interface SetPermissionResult {
          }
          /**
           * Parameters of the 'Browser.grantPermissions' method.
           */
          interface GrantPermissionsParams {
              permissions: PermissionType[];
              /**
               * Origin the permission applies to, all origins if not specified.
               */
              origin?: string;
              /**
               * BrowserContext to override permissions. When omitted, default browser context is used.
               */
              browserContextId?: BrowserContextID;
          }
          /**
           * Return value of the 'Browser.grantPermissions' method.
           */
          interface GrantPermissionsResult {
          }
          /**
           * Parameters of the 'Browser.resetPermissions' method.
           */
          interface ResetPermissionsParams {
              /**
               * BrowserContext to reset permissions. When omitted, default browser context is used.
               */
              browserContextId?: BrowserContextID;
          }
          /**
           * Return value of the 'Browser.resetPermissions' method.
           */
          interface ResetPermissionsResult {
          }
          /**
           * Parameters of the 'Browser.setDownloadBehavior' method.
           */
          interface SetDownloadBehaviorParams {
              /**
               * Whether to allow all or deny all download requests, or use default Chrome behavior if
               * available (otherwise deny). |allowAndName| allows download and names files according to
               * their dowmload guids.
               */
              behavior: 'deny' | 'allow' | 'allowAndName' | 'default';
              /**
               * BrowserContext to set download behavior. When omitted, default browser context is used.
               */
              browserContextId?: BrowserContextID;
              /**
               * The default path to save downloaded files to. This is required if behavior is set to 'allow'
               * or 'allowAndName'.
               */
              downloadPath?: string;
              /**
               * Whether to emit download events (defaults to false).
               */
              eventsEnabled?: boolean;
          }
          /**
           * Return value of the 'Browser.setDownloadBehavior' method.
           */
          interface SetDownloadBehaviorResult {
          }
          /**
           * Parameters of the 'Browser.cancelDownload' method.
           */
          interface CancelDownloadParams {
              /**
               * Global unique identifier of the download.
               */
              guid: string;
              /**
               * BrowserContext to perform the action in. When omitted, default browser context is used.
               */
              browserContextId?: BrowserContextID;
          }
          /**
           * Return value of the 'Browser.cancelDownload' method.
           */
          interface CancelDownloadResult {
          }
          /**
           * Parameters of the 'Browser.close' method.
           */
          interface CloseParams {
          }
          /**
           * Return value of the 'Browser.close' method.
           */
          interface CloseResult {
          }
          /**
           * Parameters of the 'Browser.crash' method.
           */
          interface CrashParams {
          }
          /**
           * Return value of the 'Browser.crash' method.
           */
          interface CrashResult {
          }
          /**
           * Parameters of the 'Browser.crashGpuProcess' method.
           */
          interface CrashGpuProcessParams {
          }
          /**
           * Return value of the 'Browser.crashGpuProcess' method.
           */
          interface CrashGpuProcessResult {
          }
          /**
           * Parameters of the 'Browser.getVersion' method.
           */
          interface GetVersionParams {
          }
          /**
           * Return value of the 'Browser.getVersion' method.
           */
          interface GetVersionResult {
              /**
               * Protocol version.
               */
              protocolVersion: string;
              /**
               * Product name.
               */
              product: string;
              /**
               * Product revision.
               */
              revision: string;
              /**
               * User-Agent.
               */
              userAgent: string;
              /**
               * V8 version.
               */
              jsVersion: string;
          }
          /**
           * Parameters of the 'Browser.getBrowserCommandLine' method.
           */
          interface GetBrowserCommandLineParams {
          }
          /**
           * Return value of the 'Browser.getBrowserCommandLine' method.
           */
          interface GetBrowserCommandLineResult {
              /**
               * Commandline parameters
               */
              arguments: string[];
          }
          /**
           * Parameters of the 'Browser.getHistograms' method.
           */
          interface GetHistogramsParams {
              /**
               * Requested substring in name. Only histograms which have query as a
               * substring in their name are extracted. An empty or absent query returns
               * all histograms.
               */
              query?: string;
              /**
               * If true, retrieve delta since last delta call.
               */
              delta?: boolean;
          }
          /**
           * Return value of the 'Browser.getHistograms' method.
           */
          interface GetHistogramsResult {
              /**
               * Histograms.
               */
              histograms: Histogram[];
          }
          /**
           * Parameters of the 'Browser.getHistogram' method.
           */
          interface GetHistogramParams {
              /**
               * Requested histogram name.
               */
              name: string;
              /**
               * If true, retrieve delta since last delta call.
               */
              delta?: boolean;
          }
          /**
           * Return value of the 'Browser.getHistogram' method.
           */
          interface GetHistogramResult {
              /**
               * Histogram.
               */
              histogram: Histogram;
          }
          /**
           * Parameters of the 'Browser.getWindowBounds' method.
           */
          interface GetWindowBoundsParams {
              /**
               * Browser window id.
               */
              windowId: WindowID;
          }
          /**
           * Return value of the 'Browser.getWindowBounds' method.
           */
          interface GetWindowBoundsResult {
              /**
               * Bounds information of the window. When window state is 'minimized', the restored window
               * position and size are returned.
               */
              bounds: Bounds;
          }
          /**
           * Parameters of the 'Browser.getWindowForTarget' method.
           */
          interface GetWindowForTargetParams {
              /**
               * Devtools agent host id. If called as a part of the session, associated targetId is used.
               */
              targetId?: Target.TargetID;
          }
          /**
           * Return value of the 'Browser.getWindowForTarget' method.
           */
          interface GetWindowForTargetResult {
              /**
               * Browser window id.
               */
              windowId: WindowID;
              /**
               * Bounds information of the window. When window state is 'minimized', the restored window
               * position and size are returned.
               */
              bounds: Bounds;
          }
          /**
           * Parameters of the 'Browser.setWindowBounds' method.
           */
          interface SetWindowBoundsParams {
              /**
               * Browser window id.
               */
              windowId: WindowID;
              /**
               * New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
               * with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
               */
              bounds: Bounds;
          }
          /**
           * Return value of the 'Browser.setWindowBounds' method.
           */
          interface SetWindowBoundsResult {
          }
          /**
           * Parameters of the 'Browser.setDockTile' method.
           */
          interface SetDockTileParams {
              badgeLabel?: string;
              /**
               * Png encoded image. (Encoded as a base64 string when passed over JSON)
               */
              image?: string;
          }
          /**
           * Return value of the 'Browser.setDockTile' method.
           */
          interface SetDockTileResult {
          }
          /**
           * Parameters of the 'Browser.executeBrowserCommand' method.
           */
          interface ExecuteBrowserCommandParams {
              commandId: BrowserCommandId;
          }
          /**
           * Return value of the 'Browser.executeBrowserCommand' method.
           */
          interface ExecuteBrowserCommandResult {
          }
          /**
           * Parameters of the 'Browser.addPrivacySandboxEnrollmentOverride' method.
           */
          interface AddPrivacySandboxEnrollmentOverrideParams {
              url: string;
          }
          /**
           * Return value of the 'Browser.addPrivacySandboxEnrollmentOverride' method.
           */
          interface AddPrivacySandboxEnrollmentOverrideResult {
          }
          /**
           * Parameters of the 'Browser.downloadWillBegin' event.
           */
          interface DownloadWillBeginEvent {
              /**
               * Id of the frame that caused the download to begin.
               */
              frameId: Page.FrameId;
              /**
               * Global unique identifier of the download.
               */
              guid: string;
              /**
               * URL of the resource being downloaded.
               */
              url: string;
              /**
               * Suggested file name of the resource (the actual name of the file saved on disk may differ).
               */
              suggestedFilename: string;
          }
          /**
           * Parameters of the 'Browser.downloadProgress' event.
           */
          interface DownloadProgressEvent {
              /**
               * Global unique identifier of the download.
               */
              guid: string;
              /**
               * Total expected bytes to download.
               */
              totalBytes: number;
              /**
               * Total bytes received.
               */
              receivedBytes: number;
              /**
               * Download status.
               */
              state: 'inProgress' | 'completed' | 'canceled';
          }
          type BrowserContextID = string;
          type WindowID = integer;
          /**
           * The state of the browser window.
           */
          type WindowState = 'normal' | 'minimized' | 'maximized' | 'fullscreen';
          /**
           * Browser window bounds information
           */
          interface Bounds {
              /**
               * The offset from the left edge of the screen to the window in pixels.
               */
              left?: integer;
              /**
               * The offset from the top edge of the screen to the window in pixels.
               */
              top?: integer;
              /**
               * The window width in pixels.
               */
              width?: integer;
              /**
               * The window height in pixels.
               */
              height?: integer;
              /**
               * The window state. Default to normal.
               */
              windowState?: WindowState;
          }
          type PermissionType = 'accessibilityEvents' | 'audioCapture' | 'backgroundSync' | 'backgroundFetch' | 'capturedSurfaceControl' | 'clipboardReadWrite' | 'clipboardSanitizedWrite' | 'displayCapture' | 'durableStorage' | 'flash' | 'geolocation' | 'idleDetection' | 'localFonts' | 'midi' | 'midiSysex' | 'nfc' | 'notifications' | 'paymentHandler' | 'periodicBackgroundSync' | 'protectedMediaIdentifier' | 'sensors' | 'storageAccess' | 'topLevelStorageAccess' | 'videoCapture' | 'videoCapturePanTiltZoom' | 'wakeLockScreen' | 'wakeLockSystem' | 'windowManagement';
          type PermissionSetting = 'granted' | 'denied' | 'prompt';
          /**
           * Definition of PermissionDescriptor defined in the Permissions API:
           * https://w3c.github.io/permissions/#dom-permissiondescriptor.
           */
          interface PermissionDescriptor {
              /**
               * Name of permission.
               * See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
               */
              name: string;
              /**
               * For "midi" permission, may also specify sysex control.
               */
              sysex?: boolean;
              /**
               * For "push" permission, may specify userVisibleOnly.
               * Note that userVisibleOnly = true is the only currently supported type.
               */
              userVisibleOnly?: boolean;
              /**
               * For "clipboard" permission, may specify allowWithoutSanitization.
               */
              allowWithoutSanitization?: boolean;
              /**
               * For "camera" permission, may specify panTiltZoom.
               */
              panTiltZoom?: boolean;
          }
          /**
           * Browser command ids used by executeBrowserCommand.
           */
          type BrowserCommandId = 'openTabSearch' | 'closeTabSearch';
          /**
           * Chrome histogram bucket.
           */
          interface Bucket {
              /**
               * Minimum value (inclusive).
               */
              low: integer;
              /**
               * Maximum value (exclusive).
               */
              high: integer;
              /**
               * Number of samples.
               */
              count: integer;
          }
          /**
           * Chrome histogram.
           */
          interface Histogram {
              /**
               * Name.
               */
              name: string;
              /**
               * Sum of sample values.
               */
              sum: integer;
              /**
               * Total number of samples.
               */
              count: integer;
              /**
               * Buckets.
               */
              buckets: Bucket[];
          }
      }
      /**
       * Methods and events of the 'CSS' domain.
       */
      interface CSSApi {
          requests: {
              /**
               * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
               * position specified by `location`.
               */
              addRule: {
                  params: CSS.AddRuleParams;
                  result: CSS.AddRuleResult;
              };
              /**
               * Returns all class names from specified stylesheet.
               */
              collectClassNames: {
                  params: CSS.CollectClassNamesParams;
                  result: CSS.CollectClassNamesResult;
              };
              /**
               * Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
               */
              createStyleSheet: {
                  params: CSS.CreateStyleSheetParams;
                  result: CSS.CreateStyleSheetResult;
              };
              /**
               * Disables the CSS agent for the given page.
               */
              disable: {
                  params: CSS.DisableParams;
                  result: CSS.DisableResult;
              };
              /**
               * Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
               * enabled until the result of this command is received.
               */
              enable: {
                  params: CSS.EnableParams;
                  result: CSS.EnableResult;
              };
              /**
               * Ensures that the given node will have specified pseudo-classes whenever its style is computed by
               * the browser.
               */
              forcePseudoState: {
                  params: CSS.ForcePseudoStateParams;
                  result: CSS.ForcePseudoStateResult;
              };
              getBackgroundColors: {
                  params: CSS.GetBackgroundColorsParams;
                  result: CSS.GetBackgroundColorsResult;
              };
              /**
               * Returns the computed style for a DOM node identified by `nodeId`.
               */
              getComputedStyleForNode: {
                  params: CSS.GetComputedStyleForNodeParams;
                  result: CSS.GetComputedStyleForNodeResult;
              };
              /**
               * Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
               * attributes) for a DOM node identified by `nodeId`.
               */
              getInlineStylesForNode: {
                  params: CSS.GetInlineStylesForNodeParams;
                  result: CSS.GetInlineStylesForNodeResult;
              };
              /**
               * Returns requested styles for a DOM node identified by `nodeId`.
               */
              getMatchedStylesForNode: {
                  params: CSS.GetMatchedStylesForNodeParams;
                  result: CSS.GetMatchedStylesForNodeResult;
              };
              /**
               * Returns all media queries parsed by the rendering engine.
               */
              getMediaQueries: {
                  params: CSS.GetMediaQueriesParams;
                  result: CSS.GetMediaQueriesResult;
              };
              /**
               * Requests information about platform fonts which we used to render child TextNodes in the given
               * node.
               */
              getPlatformFontsForNode: {
                  params: CSS.GetPlatformFontsForNodeParams;
                  result: CSS.GetPlatformFontsForNodeResult;
              };
              /**
               * Returns the current textual content for a stylesheet.
               */
              getStyleSheetText: {
                  params: CSS.GetStyleSheetTextParams;
                  result: CSS.GetStyleSheetTextResult;
              };
              /**
               * Returns all layers parsed by the rendering engine for the tree scope of a node.
               * Given a DOM element identified by nodeId, getLayersForNode returns the root
               * layer for the nearest ancestor document or shadow root. The layer root contains
               * the full layer tree for the tree scope and their ordering.
               */
              getLayersForNode: {
                  params: CSS.GetLayersForNodeParams;
                  result: CSS.GetLayersForNodeResult;
              };
              /**
               * Starts tracking the given computed styles for updates. The specified array of properties
               * replaces the one previously specified. Pass empty array to disable tracking.
               * Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
               * The changes to computed style properties are only tracked for nodes pushed to the front-end
               * by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
               * to the front-end, no updates will be issued for the node.
               */
              trackComputedStyleUpdates: {
                  params: CSS.TrackComputedStyleUpdatesParams;
                  result: CSS.TrackComputedStyleUpdatesResult;
              };
              /**
               * Polls the next batch of computed style updates.
               */
              takeComputedStyleUpdates: {
                  params: CSS.TakeComputedStyleUpdatesParams;
                  result: CSS.TakeComputedStyleUpdatesResult;
              };
              /**
               * Find a rule with the given active property for the given node and set the new value for this
               * property
               */
              setEffectivePropertyValueForNode: {
                  params: CSS.SetEffectivePropertyValueForNodeParams;
                  result: CSS.SetEffectivePropertyValueForNodeResult;
              };
              /**
               * Modifies the property rule property name.
               */
              setPropertyRulePropertyName: {
                  params: CSS.SetPropertyRulePropertyNameParams;
                  result: CSS.SetPropertyRulePropertyNameResult;
              };
              /**
               * Modifies the keyframe rule key text.
               */
              setKeyframeKey: {
                  params: CSS.SetKeyframeKeyParams;
                  result: CSS.SetKeyframeKeyResult;
              };
              /**
               * Modifies the rule selector.
               */
              setMediaText: {
                  params: CSS.SetMediaTextParams;
                  result: CSS.SetMediaTextResult;
              };
              /**
               * Modifies the expression of a container query.
               */
              setContainerQueryText: {
                  params: CSS.SetContainerQueryTextParams;
                  result: CSS.SetContainerQueryTextResult;
              };
              /**
               * Modifies the expression of a supports at-rule.
               */
              setSupportsText: {
                  params: CSS.SetSupportsTextParams;
                  result: CSS.SetSupportsTextResult;
              };
              /**
               * Modifies the expression of a scope at-rule.
               */
              setScopeText: {
                  params: CSS.SetScopeTextParams;
                  result: CSS.SetScopeTextResult;
              };
              /**
               * Modifies the rule selector.
               */
              setRuleSelector: {
                  params: CSS.SetRuleSelectorParams;
                  result: CSS.SetRuleSelectorResult;
              };
              /**
               * Sets the new stylesheet text.
               */
              setStyleSheetText: {
                  params: CSS.SetStyleSheetTextParams;
                  result: CSS.SetStyleSheetTextResult;
              };
              /**
               * Applies specified style edits one after another in the given order.
               */
              setStyleTexts: {
                  params: CSS.SetStyleTextsParams;
                  result: CSS.SetStyleTextsResult;
              };
              /**
               * Enables the selector recording.
               */
              startRuleUsageTracking: {
                  params: CSS.StartRuleUsageTrackingParams;
                  result: CSS.StartRuleUsageTrackingResult;
              };
              /**
               * Stop tracking rule usage and return the list of rules that were used since last call to
               * `takeCoverageDelta` (or since start of coverage instrumentation).
               */
              stopRuleUsageTracking: {
                  params: CSS.StopRuleUsageTrackingParams;
                  result: CSS.StopRuleUsageTrackingResult;
              };
              /**
               * Obtain list of rules that became used since last call to this method (or since start of coverage
               * instrumentation).
               */
              takeCoverageDelta: {
                  params: CSS.TakeCoverageDeltaParams;
                  result: CSS.TakeCoverageDeltaResult;
              };
              /**
               * Enables/disables rendering of local CSS fonts (enabled by default).
               */
              setLocalFontsEnabled: {
                  params: CSS.SetLocalFontsEnabledParams;
                  result: CSS.SetLocalFontsEnabledResult;
              };
          };
          events: {
              /**
               * Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
               * web font.
               */
              fontsUpdated: {
                  params: CSS.FontsUpdatedEvent;
              };
              /**
               * Fires whenever a MediaQuery result changes (for example, after a browser window has been
               * resized.) The current implementation considers only viewport-dependent media features.
               */
              mediaQueryResultChanged: {
                  params: CSS.MediaQueryResultChangedEvent;
              };
              /**
               * Fired whenever an active document stylesheet is added.
               */
              styleSheetAdded: {
                  params: CSS.StyleSheetAddedEvent;
              };
              /**
               * Fired whenever a stylesheet is changed as a result of the client operation.
               */
              styleSheetChanged: {
                  params: CSS.StyleSheetChangedEvent;
              };
              /**
               * Fired whenever an active document stylesheet is removed.
               */
              styleSheetRemoved: {
                  params: CSS.StyleSheetRemovedEvent;
              };
          };
      }
      /**
       * Types of the 'CSS' domain.
       */
      namespace CSS {
          /**
           * Parameters of the 'CSS.addRule' method.
           */
          interface AddRuleParams {
              /**
               * The css style sheet identifier where a new rule should be inserted.
               */
              styleSheetId: StyleSheetId;
              /**
               * The text of a new rule.
               */
              ruleText: string;
              /**
               * Text position of a new rule in the target style sheet.
               */
              location: SourceRange;
              /**
               * NodeId for the DOM node in whose context custom property declarations for registered properties should be
               * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
               * incorrect results if the declaration contains a var() for example.
               */
              nodeForPropertySyntaxValidation?: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.addRule' method.
           */
          interface AddRuleResult {
              /**
               * The newly created rule.
               */
              rule: CSSRule;
          }
          /**
           * Parameters of the 'CSS.collectClassNames' method.
           */
          interface CollectClassNamesParams {
              styleSheetId: StyleSheetId;
          }
          /**
           * Return value of the 'CSS.collectClassNames' method.
           */
          interface CollectClassNamesResult {
              /**
               * Class name list.
               */
              classNames: string[];
          }
          /**
           * Parameters of the 'CSS.createStyleSheet' method.
           */
          interface CreateStyleSheetParams {
              /**
               * Identifier of the frame where "via-inspector" stylesheet should be created.
               */
              frameId: Page.FrameId;
          }
          /**
           * Return value of the 'CSS.createStyleSheet' method.
           */
          interface CreateStyleSheetResult {
              /**
               * Identifier of the created "via-inspector" stylesheet.
               */
              styleSheetId: StyleSheetId;
          }
          /**
           * Parameters of the 'CSS.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'CSS.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'CSS.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'CSS.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'CSS.forcePseudoState' method.
           */
          interface ForcePseudoStateParams {
              /**
               * The element id for which to force the pseudo state.
               */
              nodeId: DOM.NodeId;
              /**
               * Element pseudo classes to force when computing the element's style.
               */
              forcedPseudoClasses: string[];
          }
          /**
           * Return value of the 'CSS.forcePseudoState' method.
           */
          interface ForcePseudoStateResult {
          }
          /**
           * Parameters of the 'CSS.getBackgroundColors' method.
           */
          interface GetBackgroundColorsParams {
              /**
               * Id of the node to get background colors for.
               */
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getBackgroundColors' method.
           */
          interface GetBackgroundColorsResult {
              /**
               * The range of background colors behind this element, if it contains any visible text. If no
               * visible text is present, this will be undefined. In the case of a flat background color,
               * this will consist of simply that color. In the case of a gradient, this will consist of each
               * of the color stops. For anything more complicated, this will be an empty array. Images will
               * be ignored (as if the image had failed to load).
               */
              backgroundColors?: string[];
              /**
               * The computed font size for this node, as a CSS computed value string (e.g. '12px').
               */
              computedFontSize?: string;
              /**
               * The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
               * '100').
               */
              computedFontWeight?: string;
          }
          /**
           * Parameters of the 'CSS.getComputedStyleForNode' method.
           */
          interface GetComputedStyleForNodeParams {
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getComputedStyleForNode' method.
           */
          interface GetComputedStyleForNodeResult {
              /**
               * Computed style for the specified DOM node.
               */
              computedStyle: CSSComputedStyleProperty[];
          }
          /**
           * Parameters of the 'CSS.getInlineStylesForNode' method.
           */
          interface GetInlineStylesForNodeParams {
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getInlineStylesForNode' method.
           */
          interface GetInlineStylesForNodeResult {
              /**
               * Inline style for the specified DOM node.
               */
              inlineStyle?: CSSStyle;
              /**
               * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
               */
              attributesStyle?: CSSStyle;
          }
          /**
           * Parameters of the 'CSS.getMatchedStylesForNode' method.
           */
          interface GetMatchedStylesForNodeParams {
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getMatchedStylesForNode' method.
           */
          interface GetMatchedStylesForNodeResult {
              /**
               * Inline style for the specified DOM node.
               */
              inlineStyle?: CSSStyle;
              /**
               * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
               */
              attributesStyle?: CSSStyle;
              /**
               * CSS rules matching this node, from all applicable stylesheets.
               */
              matchedCSSRules?: RuleMatch[];
              /**
               * Pseudo style matches for this node.
               */
              pseudoElements?: PseudoElementMatches[];
              /**
               * A chain of inherited styles (from the immediate node parent up to the DOM tree root).
               */
              inherited?: InheritedStyleEntry[];
              /**
               * A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
               */
              inheritedPseudoElements?: InheritedPseudoElementMatches[];
              /**
               * A list of CSS keyframed animations matching this node.
               */
              cssKeyframesRules?: CSSKeyframesRule[];
              /**
               * A list of CSS position fallbacks matching this node.
               */
              cssPositionFallbackRules?: CSSPositionFallbackRule[];
              /**
               * A list of CSS at-property rules matching this node.
               */
              cssPropertyRules?: CSSPropertyRule[];
              /**
               * A list of CSS property registrations matching this node.
               */
              cssPropertyRegistrations?: CSSPropertyRegistration[];
              /**
               * A font-palette-values rule matching this node.
               */
              cssFontPaletteValuesRule?: CSSFontPaletteValuesRule;
              /**
               * Id of the first parent element that does not have display: contents.
               */
              parentLayoutNodeId?: DOM.NodeId;
          }
          /**
           * Parameters of the 'CSS.getMediaQueries' method.
           */
          interface GetMediaQueriesParams {
          }
          /**
           * Return value of the 'CSS.getMediaQueries' method.
           */
          interface GetMediaQueriesResult {
              medias: CSSMedia[];
          }
          /**
           * Parameters of the 'CSS.getPlatformFontsForNode' method.
           */
          interface GetPlatformFontsForNodeParams {
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getPlatformFontsForNode' method.
           */
          interface GetPlatformFontsForNodeResult {
              /**
               * Usage statistics for every employed platform font.
               */
              fonts: PlatformFontUsage[];
          }
          /**
           * Parameters of the 'CSS.getStyleSheetText' method.
           */
          interface GetStyleSheetTextParams {
              styleSheetId: StyleSheetId;
          }
          /**
           * Return value of the 'CSS.getStyleSheetText' method.
           */
          interface GetStyleSheetTextResult {
              /**
               * The stylesheet text.
               */
              text: string;
          }
          /**
           * Parameters of the 'CSS.getLayersForNode' method.
           */
          interface GetLayersForNodeParams {
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.getLayersForNode' method.
           */
          interface GetLayersForNodeResult {
              rootLayer: CSSLayerData;
          }
          /**
           * Parameters of the 'CSS.trackComputedStyleUpdates' method.
           */
          interface TrackComputedStyleUpdatesParams {
              propertiesToTrack: CSSComputedStyleProperty[];
          }
          /**
           * Return value of the 'CSS.trackComputedStyleUpdates' method.
           */
          interface TrackComputedStyleUpdatesResult {
          }
          /**
           * Parameters of the 'CSS.takeComputedStyleUpdates' method.
           */
          interface TakeComputedStyleUpdatesParams {
          }
          /**
           * Return value of the 'CSS.takeComputedStyleUpdates' method.
           */
          interface TakeComputedStyleUpdatesResult {
              /**
               * The list of node Ids that have their tracked computed styles updated.
               */
              nodeIds: DOM.NodeId[];
          }
          /**
           * Parameters of the 'CSS.setEffectivePropertyValueForNode' method.
           */
          interface SetEffectivePropertyValueForNodeParams {
              /**
               * The element id for which to set property.
               */
              nodeId: DOM.NodeId;
              propertyName: string;
              value: string;
          }
          /**
           * Return value of the 'CSS.setEffectivePropertyValueForNode' method.
           */
          interface SetEffectivePropertyValueForNodeResult {
          }
          /**
           * Parameters of the 'CSS.setPropertyRulePropertyName' method.
           */
          interface SetPropertyRulePropertyNameParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              propertyName: string;
          }
          /**
           * Return value of the 'CSS.setPropertyRulePropertyName' method.
           */
          interface SetPropertyRulePropertyNameResult {
              /**
               * The resulting key text after modification.
               */
              propertyName: Value;
          }
          /**
           * Parameters of the 'CSS.setKeyframeKey' method.
           */
          interface SetKeyframeKeyParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              keyText: string;
          }
          /**
           * Return value of the 'CSS.setKeyframeKey' method.
           */
          interface SetKeyframeKeyResult {
              /**
               * The resulting key text after modification.
               */
              keyText: Value;
          }
          /**
           * Parameters of the 'CSS.setMediaText' method.
           */
          interface SetMediaTextParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              text: string;
          }
          /**
           * Return value of the 'CSS.setMediaText' method.
           */
          interface SetMediaTextResult {
              /**
               * The resulting CSS media rule after modification.
               */
              media: CSSMedia;
          }
          /**
           * Parameters of the 'CSS.setContainerQueryText' method.
           */
          interface SetContainerQueryTextParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              text: string;
          }
          /**
           * Return value of the 'CSS.setContainerQueryText' method.
           */
          interface SetContainerQueryTextResult {
              /**
               * The resulting CSS container query rule after modification.
               */
              containerQuery: CSSContainerQuery;
          }
          /**
           * Parameters of the 'CSS.setSupportsText' method.
           */
          interface SetSupportsTextParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              text: string;
          }
          /**
           * Return value of the 'CSS.setSupportsText' method.
           */
          interface SetSupportsTextResult {
              /**
               * The resulting CSS Supports rule after modification.
               */
              supports: CSSSupports;
          }
          /**
           * Parameters of the 'CSS.setScopeText' method.
           */
          interface SetScopeTextParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              text: string;
          }
          /**
           * Return value of the 'CSS.setScopeText' method.
           */
          interface SetScopeTextResult {
              /**
               * The resulting CSS Scope rule after modification.
               */
              scope: CSSScope;
          }
          /**
           * Parameters of the 'CSS.setRuleSelector' method.
           */
          interface SetRuleSelectorParams {
              styleSheetId: StyleSheetId;
              range: SourceRange;
              selector: string;
          }
          /**
           * Return value of the 'CSS.setRuleSelector' method.
           */
          interface SetRuleSelectorResult {
              /**
               * The resulting selector list after modification.
               */
              selectorList: SelectorList;
          }
          /**
           * Parameters of the 'CSS.setStyleSheetText' method.
           */
          interface SetStyleSheetTextParams {
              styleSheetId: StyleSheetId;
              text: string;
          }
          /**
           * Return value of the 'CSS.setStyleSheetText' method.
           */
          interface SetStyleSheetTextResult {
              /**
               * URL of source map associated with script (if any).
               */
              sourceMapURL?: string;
          }
          /**
           * Parameters of the 'CSS.setStyleTexts' method.
           */
          interface SetStyleTextsParams {
              edits: StyleDeclarationEdit[];
              /**
               * NodeId for the DOM node in whose context custom property declarations for registered properties should be
               * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
               * incorrect results if the declaration contains a var() for example.
               */
              nodeForPropertySyntaxValidation?: DOM.NodeId;
          }
          /**
           * Return value of the 'CSS.setStyleTexts' method.
           */
          interface SetStyleTextsResult {
              /**
               * The resulting styles after modification.
               */
              styles: CSSStyle[];
          }
          /**
           * Parameters of the 'CSS.startRuleUsageTracking' method.
           */
          interface StartRuleUsageTrackingParams {
          }
          /**
           * Return value of the 'CSS.startRuleUsageTracking' method.
           */
          interface StartRuleUsageTrackingResult {
          }
          /**
           * Parameters of the 'CSS.stopRuleUsageTracking' method.
           */
          interface StopRuleUsageTrackingParams {
          }
          /**
           * Return value of the 'CSS.stopRuleUsageTracking' method.
           */
          interface StopRuleUsageTrackingResult {
              ruleUsage: RuleUsage[];
          }
          /**
           * Parameters of the 'CSS.takeCoverageDelta' method.
           */
          interface TakeCoverageDeltaParams {
          }
          /**
           * Return value of the 'CSS.takeCoverageDelta' method.
           */
          interface TakeCoverageDeltaResult {
              coverage: RuleUsage[];
              /**
               * Monotonically increasing time, in seconds.
               */
              timestamp: number;
          }
          /**
           * Parameters of the 'CSS.setLocalFontsEnabled' method.
           */
          interface SetLocalFontsEnabledParams {
              /**
               * Whether rendering of local fonts is enabled.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'CSS.setLocalFontsEnabled' method.
           */
          interface SetLocalFontsEnabledResult {
          }
          /**
           * Parameters of the 'CSS.fontsUpdated' event.
           */
          interface FontsUpdatedEvent {
              /**
               * The web font that has loaded.
               */
              font?: FontFace;
          }
          /**
           * Parameters of the 'CSS.mediaQueryResultChanged' event.
           */
          interface MediaQueryResultChangedEvent {
          }
          /**
           * Parameters of the 'CSS.styleSheetAdded' event.
           */
          interface StyleSheetAddedEvent {
              /**
               * Added stylesheet metainfo.
               */
              header: CSSStyleSheetHeader;
          }
          /**
           * Parameters of the 'CSS.styleSheetChanged' event.
           */
          interface StyleSheetChangedEvent {
              styleSheetId: StyleSheetId;
          }
          /**
           * Parameters of the 'CSS.styleSheetRemoved' event.
           */
          interface StyleSheetRemovedEvent {
              /**
               * Identifier of the removed stylesheet.
               */
              styleSheetId: StyleSheetId;
          }
          type StyleSheetId = string;
          /**
           * Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
           * stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
           * inspector" rules), "regular" for regular stylesheets.
           */
          type StyleSheetOrigin = 'injected' | 'user-agent' | 'inspector' | 'regular';
          /**
           * CSS rule collection for a single pseudo style.
           */
          interface PseudoElementMatches {
              /**
               * Pseudo element type.
               */
              pseudoType: DOM.PseudoType;
              /**
               * Pseudo element custom ident.
               */
              pseudoIdentifier?: string;
              /**
               * Matches of CSS rules applicable to the pseudo style.
               */
              matches: RuleMatch[];
          }
          /**
           * Inherited CSS rule collection from ancestor node.
           */
          interface InheritedStyleEntry {
              /**
               * The ancestor node's inline style, if any, in the style inheritance chain.
               */
              inlineStyle?: CSSStyle;
              /**
               * Matches of CSS rules matching the ancestor node in the style inheritance chain.
               */
              matchedCSSRules: RuleMatch[];
          }
          /**
           * Inherited pseudo element matches from pseudos of an ancestor node.
           */
          interface InheritedPseudoElementMatches {
              /**
               * Matches of pseudo styles from the pseudos of an ancestor node.
               */
              pseudoElements: PseudoElementMatches[];
          }
          /**
           * Match data for a CSS rule.
           */
          interface RuleMatch {
              /**
               * CSS rule in the match.
               */
              rule: CSSRule;
              /**
               * Matching selector indices in the rule's selectorList selectors (0-based).
               */
              matchingSelectors: integer[];
          }
          /**
           * Data for a simple selector (these are delimited by commas in a selector list).
           */
          interface Value {
              /**
               * Value text.
               */
              text: string;
              /**
               * Value range in the underlying resource (if available).
               */
              range?: SourceRange;
              /**
               * Specificity of the selector.
               */
              specificity?: Specificity;
          }
          /**
           * Specificity:
           * https://drafts.csswg.org/selectors/#specificity-rules
           */
          interface Specificity {
              /**
               * The a component, which represents the number of ID selectors.
               */
              a: integer;
              /**
               * The b component, which represents the number of class selectors, attributes selectors, and
               * pseudo-classes.
               */
              b: integer;
              /**
               * The c component, which represents the number of type selectors and pseudo-elements.
               */
              c: integer;
          }
          /**
           * Selector list data.
           */
          interface SelectorList {
              /**
               * Selectors in the list.
               */
              selectors: Value[];
              /**
               * Rule selector text.
               */
              text: string;
          }
          /**
           * CSS stylesheet metainformation.
           */
          interface CSSStyleSheetHeader {
              /**
               * The stylesheet identifier.
               */
              styleSheetId: StyleSheetId;
              /**
               * Owner frame identifier.
               */
              frameId: Page.FrameId;
              /**
               * Stylesheet resource URL. Empty if this is a constructed stylesheet created using
               * new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
               * as a CSS module script).
               */
              sourceURL: string;
              /**
               * URL of source map associated with the stylesheet (if any).
               */
              sourceMapURL?: string;
              /**
               * Stylesheet origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Stylesheet title.
               */
              title: string;
              /**
               * The backend id for the owner node of the stylesheet.
               */
              ownerNode?: DOM.BackendNodeId;
              /**
               * Denotes whether the stylesheet is disabled.
               */
              disabled: boolean;
              /**
               * Whether the sourceURL field value comes from the sourceURL comment.
               */
              hasSourceURL?: boolean;
              /**
               * Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
               * document.written STYLE tags.
               */
              isInline: boolean;
              /**
               * Whether this stylesheet is mutable. Inline stylesheets become mutable
               * after they have been modified via CSSOM API.
               * `<link>` element's stylesheets become mutable only if DevTools modifies them.
               * Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
               */
              isMutable: boolean;
              /**
               * True if this stylesheet is created through new CSSStyleSheet() or imported as a
               * CSS module script.
               */
              isConstructed: boolean;
              /**
               * Line offset of the stylesheet within the resource (zero based).
               */
              startLine: number;
              /**
               * Column offset of the stylesheet within the resource (zero based).
               */
              startColumn: number;
              /**
               * Size of the content (in characters).
               */
              length: number;
              /**
               * Line offset of the end of the stylesheet within the resource (zero based).
               */
              endLine: number;
              /**
               * Column offset of the end of the stylesheet within the resource (zero based).
               */
              endColumn: number;
              /**
               * If the style sheet was loaded from a network resource, this indicates when the resource failed to load
               */
              loadingFailed?: boolean;
          }
          /**
           * CSS rule representation.
           */
          interface CSSRule {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * Rule selector data.
               */
              selectorList: SelectorList;
              /**
               * Array of selectors from ancestor style rules, sorted by distance from the current rule.
               */
              nestingSelectors?: string[];
              /**
               * Parent stylesheet's origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Associated style declaration.
               */
              style: CSSStyle;
              /**
               * Media list array (for rules involving media queries). The array enumerates media queries
               * starting with the innermost one, going outwards.
               */
              media?: CSSMedia[];
              /**
               * Container query list array (for rules involving container queries).
               * The array enumerates container queries starting with the innermost one, going outwards.
               */
              containerQueries?: CSSContainerQuery[];
              /**
               * @supports CSS at-rule array.
               * The array enumerates @supports at-rules starting with the innermost one, going outwards.
               */
              supports?: CSSSupports[];
              /**
               * Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
               * with the innermost layer and going outwards.
               */
              layers?: CSSLayer[];
              /**
               * @scope CSS at-rule array.
               * The array enumerates @scope at-rules starting with the innermost one, going outwards.
               */
              scopes?: CSSScope[];
              /**
               * The array keeps the types of ancestor CSSRules from the innermost going outwards.
               */
              ruleTypes?: CSSRuleType[];
          }
          /**
           * Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
           * This list only contains rule types that are collected during the ancestor rule collection.
           */
          type CSSRuleType = 'MediaRule' | 'SupportsRule' | 'ContainerRule' | 'LayerRule' | 'ScopeRule' | 'StyleRule';
          /**
           * CSS coverage information.
           */
          interface RuleUsage {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId: StyleSheetId;
              /**
               * Offset of the start of the rule (including selector) from the beginning of the stylesheet.
               */
              startOffset: number;
              /**
               * Offset of the end of the rule body from the beginning of the stylesheet.
               */
              endOffset: number;
              /**
               * Indicates whether the rule was actually used by some element in the page.
               */
              used: boolean;
          }
          /**
           * Text range within a resource. All numbers are zero-based.
           */
          interface SourceRange {
              /**
               * Start line of range.
               */
              startLine: integer;
              /**
               * Start column of range (inclusive).
               */
              startColumn: integer;
              /**
               * End line of range
               */
              endLine: integer;
              /**
               * End column of range (exclusive).
               */
              endColumn: integer;
          }
          interface ShorthandEntry {
              /**
               * Shorthand name.
               */
              name: string;
              /**
               * Shorthand value.
               */
              value: string;
              /**
               * Whether the property has "!important" annotation (implies `false` if absent).
               */
              important?: boolean;
          }
          interface CSSComputedStyleProperty {
              /**
               * Computed style property name.
               */
              name: string;
              /**
               * Computed style property value.
               */
              value: string;
          }
          /**
           * CSS style representation.
           */
          interface CSSStyle {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * CSS properties in the style.
               */
              cssProperties: CSSProperty[];
              /**
               * Computed values for all shorthands found in the style.
               */
              shorthandEntries: ShorthandEntry[];
              /**
               * Style declaration text (if available).
               */
              cssText?: string;
              /**
               * Style declaration range in the enclosing stylesheet (if available).
               */
              range?: SourceRange;
          }
          /**
           * CSS property declaration data.
           */
          interface CSSProperty {
              /**
               * The property name.
               */
              name: string;
              /**
               * The property value.
               */
              value: string;
              /**
               * Whether the property has "!important" annotation (implies `false` if absent).
               */
              important?: boolean;
              /**
               * Whether the property is implicit (implies `false` if absent).
               */
              implicit?: boolean;
              /**
               * The full property text as specified in the style.
               */
              text?: string;
              /**
               * Whether the property is understood by the browser (implies `true` if absent).
               */
              parsedOk?: boolean;
              /**
               * Whether the property is disabled by the user (present for source-based properties only).
               */
              disabled?: boolean;
              /**
               * The entire property range in the enclosing style declaration (if available).
               */
              range?: SourceRange;
              /**
               * Parsed longhand components of this property if it is a shorthand.
               * This field will be empty if the given property is not a shorthand.
               */
              longhandProperties?: CSSProperty[];
          }
          /**
           * CSS media rule descriptor.
           */
          interface CSSMedia {
              /**
               * Media query text.
               */
              text: string;
              /**
               * Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
               * specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
               * stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
               * stylesheet's STYLE tag.
               */
              source: 'mediaRule' | 'importRule' | 'linkedSheet' | 'inlineSheet';
              /**
               * URL of the document containing the media query description.
               */
              sourceURL?: string;
              /**
               * The associated rule (@media or @import) header range in the enclosing stylesheet (if
               * available).
               */
              range?: SourceRange;
              /**
               * Identifier of the stylesheet containing this object (if exists).
               */
              styleSheetId?: StyleSheetId;
              /**
               * Array of media queries.
               */
              mediaList?: MediaQuery[];
          }
          /**
           * Media query descriptor.
           */
          interface MediaQuery {
              /**
               * Array of media query expressions.
               */
              expressions: MediaQueryExpression[];
              /**
               * Whether the media query condition is satisfied.
               */
              active: boolean;
          }
          /**
           * Media query expression descriptor.
           */
          interface MediaQueryExpression {
              /**
               * Media query expression value.
               */
              value: number;
              /**
               * Media query expression units.
               */
              unit: string;
              /**
               * Media query expression feature.
               */
              feature: string;
              /**
               * The associated range of the value text in the enclosing stylesheet (if available).
               */
              valueRange?: SourceRange;
              /**
               * Computed length of media query expression (if applicable).
               */
              computedLength?: number;
          }
          /**
           * CSS container query rule descriptor.
           */
          interface CSSContainerQuery {
              /**
               * Container query text.
               */
              text: string;
              /**
               * The associated rule header range in the enclosing stylesheet (if
               * available).
               */
              range?: SourceRange;
              /**
               * Identifier of the stylesheet containing this object (if exists).
               */
              styleSheetId?: StyleSheetId;
              /**
               * Optional name for the container.
               */
              name?: string;
              /**
               * Optional physical axes queried for the container.
               */
              physicalAxes?: DOM.PhysicalAxes;
              /**
               * Optional logical axes queried for the container.
               */
              logicalAxes?: DOM.LogicalAxes;
          }
          /**
           * CSS Supports at-rule descriptor.
           */
          interface CSSSupports {
              /**
               * Supports rule text.
               */
              text: string;
              /**
               * Whether the supports condition is satisfied.
               */
              active: boolean;
              /**
               * The associated rule header range in the enclosing stylesheet (if
               * available).
               */
              range?: SourceRange;
              /**
               * Identifier of the stylesheet containing this object (if exists).
               */
              styleSheetId?: StyleSheetId;
          }
          /**
           * CSS Scope at-rule descriptor.
           */
          interface CSSScope {
              /**
               * Scope rule text.
               */
              text: string;
              /**
               * The associated rule header range in the enclosing stylesheet (if
               * available).
               */
              range?: SourceRange;
              /**
               * Identifier of the stylesheet containing this object (if exists).
               */
              styleSheetId?: StyleSheetId;
          }
          /**
           * CSS Layer at-rule descriptor.
           */
          interface CSSLayer {
              /**
               * Layer name.
               */
              text: string;
              /**
               * The associated rule header range in the enclosing stylesheet (if
               * available).
               */
              range?: SourceRange;
              /**
               * Identifier of the stylesheet containing this object (if exists).
               */
              styleSheetId?: StyleSheetId;
          }
          /**
           * CSS Layer data.
           */
          interface CSSLayerData {
              /**
               * Layer name.
               */
              name: string;
              /**
               * Direct sub-layers
               */
              subLayers?: CSSLayerData[];
              /**
               * Layer order. The order determines the order of the layer in the cascade order.
               * A higher number has higher priority in the cascade order.
               */
              order: number;
          }
          /**
           * Information about amount of glyphs that were rendered with given font.
           */
          interface PlatformFontUsage {
              /**
               * Font's family name reported by platform.
               */
              familyName: string;
              /**
               * Font's PostScript name reported by platform.
               */
              postScriptName: string;
              /**
               * Indicates if the font was downloaded or resolved locally.
               */
              isCustomFont: boolean;
              /**
               * Amount of glyphs that were rendered with this font.
               */
              glyphCount: number;
          }
          /**
           * Information about font variation axes for variable fonts
           */
          interface FontVariationAxis {
              /**
               * The font-variation-setting tag (a.k.a. "axis tag").
               */
              tag: string;
              /**
               * Human-readable variation name in the default language (normally, "en").
               */
              name: string;
              /**
               * The minimum value (inclusive) the font supports for this tag.
               */
              minValue: number;
              /**
               * The maximum value (inclusive) the font supports for this tag.
               */
              maxValue: number;
              /**
               * The default value.
               */
              defaultValue: number;
          }
          /**
           * Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
           * and additional information such as platformFontFamily and fontVariationAxes.
           */
          interface FontFace {
              /**
               * The font-family.
               */
              fontFamily: string;
              /**
               * The font-style.
               */
              fontStyle: string;
              /**
               * The font-variant.
               */
              fontVariant: string;
              /**
               * The font-weight.
               */
              fontWeight: string;
              /**
               * The font-stretch.
               */
              fontStretch: string;
              /**
               * The font-display.
               */
              fontDisplay: string;
              /**
               * The unicode-range.
               */
              unicodeRange: string;
              /**
               * The src.
               */
              src: string;
              /**
               * The resolved platform font family
               */
              platformFontFamily: string;
              /**
               * Available variation settings (a.k.a. "axes").
               */
              fontVariationAxes?: FontVariationAxis[];
          }
          /**
           * CSS try rule representation.
           */
          interface CSSTryRule {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * Parent stylesheet's origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Associated style declaration.
               */
              style: CSSStyle;
          }
          /**
           * CSS position-fallback rule representation.
           */
          interface CSSPositionFallbackRule {
              name: Value;
              /**
               * List of keyframes.
               */
              tryRules: CSSTryRule[];
          }
          /**
           * CSS keyframes rule representation.
           */
          interface CSSKeyframesRule {
              /**
               * Animation name.
               */
              animationName: Value;
              /**
               * List of keyframes.
               */
              keyframes: CSSKeyframeRule[];
          }
          /**
           * Representation of a custom property registration through CSS.registerProperty
           */
          interface CSSPropertyRegistration {
              propertyName: string;
              initialValue?: Value;
              inherits: boolean;
              syntax: string;
          }
          /**
           * CSS font-palette-values rule representation.
           */
          interface CSSFontPaletteValuesRule {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * Parent stylesheet's origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Associated font palette name.
               */
              fontPaletteName: Value;
              /**
               * Associated style declaration.
               */
              style: CSSStyle;
          }
          /**
           * CSS property at-rule representation.
           */
          interface CSSPropertyRule {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * Parent stylesheet's origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Associated property name.
               */
              propertyName: Value;
              /**
               * Associated style declaration.
               */
              style: CSSStyle;
          }
          /**
           * CSS keyframe rule representation.
           */
          interface CSSKeyframeRule {
              /**
               * The css style sheet identifier (absent for user agent stylesheet and user-specified
               * stylesheet rules) this rule came from.
               */
              styleSheetId?: StyleSheetId;
              /**
               * Parent stylesheet's origin.
               */
              origin: StyleSheetOrigin;
              /**
               * Associated key text.
               */
              keyText: Value;
              /**
               * Associated style declaration.
               */
              style: CSSStyle;
          }
          /**
           * A descriptor of operation to mutate style declaration text.
           */
          interface StyleDeclarationEdit {
              /**
               * The css style sheet identifier.
               */
              styleSheetId: StyleSheetId;
              /**
               * The range of the style text in the enclosing stylesheet.
               */
              range: SourceRange;
              /**
               * New style text.
               */
              text: string;
          }
      }
      /**
       * Methods and events of the 'CacheStorage' domain.
       */
      interface CacheStorageApi {
          requests: {
              /**
               * Deletes a cache.
               */
              deleteCache: {
                  params: CacheStorage.DeleteCacheParams;
                  result: CacheStorage.DeleteCacheResult;
              };
              /**
               * Deletes a cache entry.
               */
              deleteEntry: {
                  params: CacheStorage.DeleteEntryParams;
                  result: CacheStorage.DeleteEntryResult;
              };
              /**
               * Requests cache names.
               */
              requestCacheNames: {
                  params: CacheStorage.RequestCacheNamesParams;
                  result: CacheStorage.RequestCacheNamesResult;
              };
              /**
               * Fetches cache entry.
               */
              requestCachedResponse: {
                  params: CacheStorage.RequestCachedResponseParams;
                  result: CacheStorage.RequestCachedResponseResult;
              };
              /**
               * Requests data from cache.
               */
              requestEntries: {
                  params: CacheStorage.RequestEntriesParams;
                  result: CacheStorage.RequestEntriesResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'CacheStorage' domain.
       */
      namespace CacheStorage {
          /**
           * Parameters of the 'CacheStorage.deleteCache' method.
           */
          interface DeleteCacheParams {
              /**
               * Id of cache for deletion.
               */
              cacheId: CacheId;
          }
          /**
           * Return value of the 'CacheStorage.deleteCache' method.
           */
          interface DeleteCacheResult {
          }
          /**
           * Parameters of the 'CacheStorage.deleteEntry' method.
           */
          interface DeleteEntryParams {
              /**
               * Id of cache where the entry will be deleted.
               */
              cacheId: CacheId;
              /**
               * URL spec of the request.
               */
              request: string;
          }
          /**
           * Return value of the 'CacheStorage.deleteEntry' method.
           */
          interface DeleteEntryResult {
          }
          /**
           * Parameters of the 'CacheStorage.requestCacheNames' method.
           */
          interface RequestCacheNamesParams {
              /**
               * At least and at most one of securityOrigin, storageKey, storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
          }
          /**
           * Return value of the 'CacheStorage.requestCacheNames' method.
           */
          interface RequestCacheNamesResult {
              /**
               * Caches for the security origin.
               */
              caches: Cache[];
          }
          /**
           * Parameters of the 'CacheStorage.requestCachedResponse' method.
           */
          interface RequestCachedResponseParams {
              /**
               * Id of cache that contains the entry.
               */
              cacheId: CacheId;
              /**
               * URL spec of the request.
               */
              requestURL: string;
              /**
               * headers of the request.
               */
              requestHeaders: Header[];
          }
          /**
           * Return value of the 'CacheStorage.requestCachedResponse' method.
           */
          interface RequestCachedResponseResult {
              /**
               * Response read from the cache.
               */
              response: CachedResponse;
          }
          /**
           * Parameters of the 'CacheStorage.requestEntries' method.
           */
          interface RequestEntriesParams {
              /**
               * ID of cache to get entries from.
               */
              cacheId: CacheId;
              /**
               * Number of records to skip.
               */
              skipCount?: integer;
              /**
               * Number of records to fetch.
               */
              pageSize?: integer;
              /**
               * If present, only return the entries containing this substring in the path
               */
              pathFilter?: string;
          }
          /**
           * Return value of the 'CacheStorage.requestEntries' method.
           */
          interface RequestEntriesResult {
              /**
               * Array of object store data entries.
               */
              cacheDataEntries: DataEntry[];
              /**
               * Count of returned entries from this storage. If pathFilter is empty, it
               * is the count of all entries from this storage.
               */
              returnCount: number;
          }
          /**
           * Unique identifier of the Cache object.
           */
          type CacheId = string;
          /**
           * type of HTTP response cached
           */
          type CachedResponseType = 'basic' | 'cors' | 'default' | 'error' | 'opaqueResponse' | 'opaqueRedirect';
          /**
           * Data entry.
           */
          interface DataEntry {
              /**
               * Request URL.
               */
              requestURL: string;
              /**
               * Request method.
               */
              requestMethod: string;
              /**
               * Request headers
               */
              requestHeaders: Header[];
              /**
               * Number of seconds since epoch.
               */
              responseTime: number;
              /**
               * HTTP response status code.
               */
              responseStatus: integer;
              /**
               * HTTP response status text.
               */
              responseStatusText: string;
              /**
               * HTTP response type
               */
              responseType: CachedResponseType;
              /**
               * Response headers
               */
              responseHeaders: Header[];
          }
          /**
           * Cache identifier.
           */
          interface Cache {
              /**
               * An opaque unique id of the cache.
               */
              cacheId: CacheId;
              /**
               * Security origin of the cache.
               */
              securityOrigin: string;
              /**
               * Storage key of the cache.
               */
              storageKey: string;
              /**
               * Storage bucket of the cache.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * The name of the cache.
               */
              cacheName: string;
          }
          interface Header {
              name: string;
              value: string;
          }
          /**
           * Cached response
           */
          interface CachedResponse {
              /**
               * Entry content, base64-encoded. (Encoded as a base64 string when passed over JSON)
               */
              body: string;
          }
      }
      /**
       * Methods and events of the 'Cast' domain.
       */
      interface CastApi {
          requests: {
              /**
               * Starts observing for sinks that can be used for tab mirroring, and if set,
               * sinks compatible with |presentationUrl| as well. When sinks are found, a
               * |sinksUpdated| event is fired.
               * Also starts observing for issue messages. When an issue is added or removed,
               * an |issueUpdated| event is fired.
               */
              enable: {
                  params: Cast.EnableParams;
                  result: Cast.EnableResult;
              };
              /**
               * Stops observing for sinks and issues.
               */
              disable: {
                  params: Cast.DisableParams;
                  result: Cast.DisableResult;
              };
              /**
               * Sets a sink to be used when the web page requests the browser to choose a
               * sink via Presentation API, Remote Playback API, or Cast SDK.
               */
              setSinkToUse: {
                  params: Cast.SetSinkToUseParams;
                  result: Cast.SetSinkToUseResult;
              };
              /**
               * Starts mirroring the desktop to the sink.
               */
              startDesktopMirroring: {
                  params: Cast.StartDesktopMirroringParams;
                  result: Cast.StartDesktopMirroringResult;
              };
              /**
               * Starts mirroring the tab to the sink.
               */
              startTabMirroring: {
                  params: Cast.StartTabMirroringParams;
                  result: Cast.StartTabMirroringResult;
              };
              /**
               * Stops the active Cast session on the sink.
               */
              stopCasting: {
                  params: Cast.StopCastingParams;
                  result: Cast.StopCastingResult;
              };
          };
          events: {
              /**
               * This is fired whenever the list of available sinks changes. A sink is a
               * device or a software surface that you can cast to.
               */
              sinksUpdated: {
                  params: Cast.SinksUpdatedEvent;
              };
              /**
               * This is fired whenever the outstanding issue/error message changes.
               * |issueMessage| is empty if there is no issue.
               */
              issueUpdated: {
                  params: Cast.IssueUpdatedEvent;
              };
          };
      }
      /**
       * Types of the 'Cast' domain.
       */
      namespace Cast {
          /**
           * Parameters of the 'Cast.enable' method.
           */
          interface EnableParams {
              presentationUrl?: string;
          }
          /**
           * Return value of the 'Cast.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Cast.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Cast.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Cast.setSinkToUse' method.
           */
          interface SetSinkToUseParams {
              sinkName: string;
          }
          /**
           * Return value of the 'Cast.setSinkToUse' method.
           */
          interface SetSinkToUseResult {
          }
          /**
           * Parameters of the 'Cast.startDesktopMirroring' method.
           */
          interface StartDesktopMirroringParams {
              sinkName: string;
          }
          /**
           * Return value of the 'Cast.startDesktopMirroring' method.
           */
          interface StartDesktopMirroringResult {
          }
          /**
           * Parameters of the 'Cast.startTabMirroring' method.
           */
          interface StartTabMirroringParams {
              sinkName: string;
          }
          /**
           * Return value of the 'Cast.startTabMirroring' method.
           */
          interface StartTabMirroringResult {
          }
          /**
           * Parameters of the 'Cast.stopCasting' method.
           */
          interface StopCastingParams {
              sinkName: string;
          }
          /**
           * Return value of the 'Cast.stopCasting' method.
           */
          interface StopCastingResult {
          }
          /**
           * Parameters of the 'Cast.sinksUpdated' event.
           */
          interface SinksUpdatedEvent {
              sinks: Sink[];
          }
          /**
           * Parameters of the 'Cast.issueUpdated' event.
           */
          interface IssueUpdatedEvent {
              issueMessage: string;
          }
          interface Sink {
              name: string;
              id: string;
              /**
               * Text describing the current session. Present only if there is an active
               * session on the sink.
               */
              session?: string;
          }
      }
      /**
       * Methods and events of the 'DOM' domain.
       */
      interface DOMApi {
          requests: {
              /**
               * Collects class names for the node with given id and all of it's child nodes.
               */
              collectClassNamesFromSubtree: {
                  params: DOM.CollectClassNamesFromSubtreeParams;
                  result: DOM.CollectClassNamesFromSubtreeResult;
              };
              /**
               * Creates a deep copy of the specified node and places it into the target container before the
               * given anchor.
               */
              copyTo: {
                  params: DOM.CopyToParams;
                  result: DOM.CopyToResult;
              };
              /**
               * Describes node given its id, does not require domain to be enabled. Does not start tracking any
               * objects, can be used for automation.
               */
              describeNode: {
                  params: DOM.DescribeNodeParams;
                  result: DOM.DescribeNodeResult;
              };
              /**
               * Scrolls the specified rect of the given node into view if not already visible.
               * Note: exactly one between nodeId, backendNodeId and objectId should be passed
               * to identify the node.
               */
              scrollIntoViewIfNeeded: {
                  params: DOM.ScrollIntoViewIfNeededParams;
                  result: DOM.ScrollIntoViewIfNeededResult;
              };
              /**
               * Disables DOM agent for the given page.
               */
              disable: {
                  params: DOM.DisableParams;
                  result: DOM.DisableResult;
              };
              /**
               * Discards search results from the session with the given id. `getSearchResults` should no longer
               * be called for that search.
               */
              discardSearchResults: {
                  params: DOM.DiscardSearchResultsParams;
                  result: DOM.DiscardSearchResultsResult;
              };
              /**
               * Enables DOM agent for the given page.
               */
              enable: {
                  params: DOM.EnableParams;
                  result: DOM.EnableResult;
              };
              /**
               * Focuses the given element.
               */
              focus: {
                  params: DOM.FocusParams;
                  result: DOM.FocusResult;
              };
              /**
               * Returns attributes for the specified node.
               */
              getAttributes: {
                  params: DOM.GetAttributesParams;
                  result: DOM.GetAttributesResult;
              };
              /**
               * Returns boxes for the given node.
               */
              getBoxModel: {
                  params: DOM.GetBoxModelParams;
                  result: DOM.GetBoxModelResult;
              };
              /**
               * Returns quads that describe node position on the page. This method
               * might return multiple quads for inline nodes.
               */
              getContentQuads: {
                  params: DOM.GetContentQuadsParams;
                  result: DOM.GetContentQuadsResult;
              };
              /**
               * Returns the root DOM node (and optionally the subtree) to the caller.
               * Implicitly enables the DOM domain events for the current target.
               */
              getDocument: {
                  params: DOM.GetDocumentParams;
                  result: DOM.GetDocumentResult;
              };
              /**
               * Returns the root DOM node (and optionally the subtree) to the caller.
               * Deprecated, as it is not designed to work well with the rest of the DOM agent.
               * Use DOMSnapshot.captureSnapshot instead.
               * @deprecated
               */
              getFlattenedDocument: {
                  params: DOM.GetFlattenedDocumentParams;
                  result: DOM.GetFlattenedDocumentResult;
              };
              /**
               * Finds nodes with a given computed style in a subtree.
               */
              getNodesForSubtreeByStyle: {
                  params: DOM.GetNodesForSubtreeByStyleParams;
                  result: DOM.GetNodesForSubtreeByStyleResult;
              };
              /**
               * Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
               * either returned or not.
               */
              getNodeForLocation: {
                  params: DOM.GetNodeForLocationParams;
                  result: DOM.GetNodeForLocationResult;
              };
              /**
               * Returns node's HTML markup.
               */
              getOuterHTML: {
                  params: DOM.GetOuterHTMLParams;
                  result: DOM.GetOuterHTMLResult;
              };
              /**
               * Returns the id of the nearest ancestor that is a relayout boundary.
               */
              getRelayoutBoundary: {
                  params: DOM.GetRelayoutBoundaryParams;
                  result: DOM.GetRelayoutBoundaryResult;
              };
              /**
               * Returns search results from given `fromIndex` to given `toIndex` from the search with the given
               * identifier.
               */
              getSearchResults: {
                  params: DOM.GetSearchResultsParams;
                  result: DOM.GetSearchResultsResult;
              };
              /**
               * Hides any highlight.
               */
              hideHighlight: {
                  params: DOM.HideHighlightParams;
                  result: DOM.HideHighlightResult;
              };
              /**
               * Highlights DOM node.
               */
              highlightNode: {
                  params: DOM.HighlightNodeParams;
                  result: DOM.HighlightNodeResult;
              };
              /**
               * Highlights given rectangle.
               */
              highlightRect: {
                  params: DOM.HighlightRectParams;
                  result: DOM.HighlightRectResult;
              };
              /**
               * Marks last undoable state.
               */
              markUndoableState: {
                  params: DOM.MarkUndoableStateParams;
                  result: DOM.MarkUndoableStateResult;
              };
              /**
               * Moves node into the new container, places it before the given anchor.
               */
              moveTo: {
                  params: DOM.MoveToParams;
                  result: DOM.MoveToResult;
              };
              /**
               * Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
               * `cancelSearch` to end this search session.
               */
              performSearch: {
                  params: DOM.PerformSearchParams;
                  result: DOM.PerformSearchResult;
              };
              /**
               * Requests that the node is sent to the caller given its path. // FIXME, use XPath
               */
              pushNodeByPathToFrontend: {
                  params: DOM.PushNodeByPathToFrontendParams;
                  result: DOM.PushNodeByPathToFrontendResult;
              };
              /**
               * Requests that a batch of nodes is sent to the caller given their backend node ids.
               */
              pushNodesByBackendIdsToFrontend: {
                  params: DOM.PushNodesByBackendIdsToFrontendParams;
                  result: DOM.PushNodesByBackendIdsToFrontendResult;
              };
              /**
               * Executes `querySelector` on a given node.
               */
              querySelector: {
                  params: DOM.QuerySelectorParams;
                  result: DOM.QuerySelectorResult;
              };
              /**
               * Executes `querySelectorAll` on a given node.
               */
              querySelectorAll: {
                  params: DOM.QuerySelectorAllParams;
                  result: DOM.QuerySelectorAllResult;
              };
              /**
               * Returns NodeIds of current top layer elements.
               * Top layer is rendered closest to the user within a viewport, therefore its elements always
               * appear on top of all other content.
               */
              getTopLayerElements: {
                  params: DOM.GetTopLayerElementsParams;
                  result: DOM.GetTopLayerElementsResult;
              };
              /**
               * Re-does the last undone action.
               */
              redo: {
                  params: DOM.RedoParams;
                  result: DOM.RedoResult;
              };
              /**
               * Removes attribute with given name from an element with given id.
               */
              removeAttribute: {
                  params: DOM.RemoveAttributeParams;
                  result: DOM.RemoveAttributeResult;
              };
              /**
               * Removes node with given id.
               */
              removeNode: {
                  params: DOM.RemoveNodeParams;
                  result: DOM.RemoveNodeResult;
              };
              /**
               * Requests that children of the node with given id are returned to the caller in form of
               * `setChildNodes` events where not only immediate children are retrieved, but all children down to
               * the specified depth.
               */
              requestChildNodes: {
                  params: DOM.RequestChildNodesParams;
                  result: DOM.RequestChildNodesResult;
              };
              /**
               * Requests that the node is sent to the caller given the JavaScript node object reference. All
               * nodes that form the path from the node to the root are also sent to the client as a series of
               * `setChildNodes` notifications.
               */
              requestNode: {
                  params: DOM.RequestNodeParams;
                  result: DOM.RequestNodeResult;
              };
              /**
               * Resolves the JavaScript node object for a given NodeId or BackendNodeId.
               */
              resolveNode: {
                  params: DOM.ResolveNodeParams;
                  result: DOM.ResolveNodeResult;
              };
              /**
               * Sets attribute for an element with given id.
               */
              setAttributeValue: {
                  params: DOM.SetAttributeValueParams;
                  result: DOM.SetAttributeValueResult;
              };
              /**
               * Sets attributes on element with given id. This method is useful when user edits some existing
               * attribute value and types in several attribute name/value pairs.
               */
              setAttributesAsText: {
                  params: DOM.SetAttributesAsTextParams;
                  result: DOM.SetAttributesAsTextResult;
              };
              /**
               * Sets files for the given file input element.
               */
              setFileInputFiles: {
                  params: DOM.SetFileInputFilesParams;
                  result: DOM.SetFileInputFilesResult;
              };
              /**
               * Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
               */
              setNodeStackTracesEnabled: {
                  params: DOM.SetNodeStackTracesEnabledParams;
                  result: DOM.SetNodeStackTracesEnabledResult;
              };
              /**
               * Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
               */
              getNodeStackTraces: {
                  params: DOM.GetNodeStackTracesParams;
                  result: DOM.GetNodeStackTracesResult;
              };
              /**
               * Returns file information for the given
               * File wrapper.
               */
              getFileInfo: {
                  params: DOM.GetFileInfoParams;
                  result: DOM.GetFileInfoResult;
              };
              /**
               * Enables console to refer to the node with given id via $x (see Command Line API for more details
               * $x functions).
               */
              setInspectedNode: {
                  params: DOM.SetInspectedNodeParams;
                  result: DOM.SetInspectedNodeResult;
              };
              /**
               * Sets node name for a node with given id.
               */
              setNodeName: {
                  params: DOM.SetNodeNameParams;
                  result: DOM.SetNodeNameResult;
              };
              /**
               * Sets node value for a node with given id.
               */
              setNodeValue: {
                  params: DOM.SetNodeValueParams;
                  result: DOM.SetNodeValueResult;
              };
              /**
               * Sets node HTML markup, returns new node id.
               */
              setOuterHTML: {
                  params: DOM.SetOuterHTMLParams;
                  result: DOM.SetOuterHTMLResult;
              };
              /**
               * Undoes the last performed action.
               */
              undo: {
                  params: DOM.UndoParams;
                  result: DOM.UndoResult;
              };
              /**
               * Returns iframe node that owns iframe with the given domain.
               */
              getFrameOwner: {
                  params: DOM.GetFrameOwnerParams;
                  result: DOM.GetFrameOwnerResult;
              };
              /**
               * Returns the query container of the given node based on container query
               * conditions: containerName, physical, and logical axes. If no axes are
               * provided, the style container is returned, which is the direct parent or the
               * closest element with a matching container-name.
               */
              getContainerForNode: {
                  params: DOM.GetContainerForNodeParams;
                  result: DOM.GetContainerForNodeResult;
              };
              /**
               * Returns the descendants of a container query container that have
               * container queries against this container.
               */
              getQueryingDescendantsForContainer: {
                  params: DOM.GetQueryingDescendantsForContainerParams;
                  result: DOM.GetQueryingDescendantsForContainerResult;
              };
          };
          events: {
              /**
               * Fired when `Element`'s attribute is modified.
               */
              attributeModified: {
                  params: DOM.AttributeModifiedEvent;
              };
              /**
               * Fired when `Element`'s attribute is removed.
               */
              attributeRemoved: {
                  params: DOM.AttributeRemovedEvent;
              };
              /**
               * Mirrors `DOMCharacterDataModified` event.
               */
              characterDataModified: {
                  params: DOM.CharacterDataModifiedEvent;
              };
              /**
               * Fired when `Container`'s child node count has changed.
               */
              childNodeCountUpdated: {
                  params: DOM.ChildNodeCountUpdatedEvent;
              };
              /**
               * Mirrors `DOMNodeInserted` event.
               */
              childNodeInserted: {
                  params: DOM.ChildNodeInsertedEvent;
              };
              /**
               * Mirrors `DOMNodeRemoved` event.
               */
              childNodeRemoved: {
                  params: DOM.ChildNodeRemovedEvent;
              };
              /**
               * Called when distribution is changed.
               */
              distributedNodesUpdated: {
                  params: DOM.DistributedNodesUpdatedEvent;
              };
              /**
               * Fired when `Document` has been totally updated. Node ids are no longer valid.
               */
              documentUpdated: {
                  params: DOM.DocumentUpdatedEvent;
              };
              /**
               * Fired when `Element`'s inline style is modified via a CSS property modification.
               */
              inlineStyleInvalidated: {
                  params: DOM.InlineStyleInvalidatedEvent;
              };
              /**
               * Called when a pseudo element is added to an element.
               */
              pseudoElementAdded: {
                  params: DOM.PseudoElementAddedEvent;
              };
              /**
               * Called when top layer elements are changed.
               */
              topLayerElementsUpdated: {
                  params: DOM.TopLayerElementsUpdatedEvent;
              };
              /**
               * Called when a pseudo element is removed from an element.
               */
              pseudoElementRemoved: {
                  params: DOM.PseudoElementRemovedEvent;
              };
              /**
               * Fired when backend wants to provide client with the missing DOM structure. This happens upon
               * most of the calls requesting node ids.
               */
              setChildNodes: {
                  params: DOM.SetChildNodesEvent;
              };
              /**
               * Called when shadow root is popped from the element.
               */
              shadowRootPopped: {
                  params: DOM.ShadowRootPoppedEvent;
              };
              /**
               * Called when shadow root is pushed into the element.
               */
              shadowRootPushed: {
                  params: DOM.ShadowRootPushedEvent;
              };
          };
      }
      /**
       * Types of the 'DOM' domain.
       */
      namespace DOM {
          /**
           * Parameters of the 'DOM.collectClassNamesFromSubtree' method.
           */
          interface CollectClassNamesFromSubtreeParams {
              /**
               * Id of the node to collect class names.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.collectClassNamesFromSubtree' method.
           */
          interface CollectClassNamesFromSubtreeResult {
              /**
               * Class name list.
               */
              classNames: string[];
          }
          /**
           * Parameters of the 'DOM.copyTo' method.
           */
          interface CopyToParams {
              /**
               * Id of the node to copy.
               */
              nodeId: NodeId;
              /**
               * Id of the element to drop the copy into.
               */
              targetNodeId: NodeId;
              /**
               * Drop the copy before this node (if absent, the copy becomes the last child of
               * `targetNodeId`).
               */
              insertBeforeNodeId?: NodeId;
          }
          /**
           * Return value of the 'DOM.copyTo' method.
           */
          interface CopyToResult {
              /**
               * Id of the node clone.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.describeNode' method.
           */
          interface DescribeNodeParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
              /**
               * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
               * entire subtree or provide an integer larger than 0.
               */
              depth?: integer;
              /**
               * Whether or not iframes and shadow roots should be traversed when returning the subtree
               * (default is false).
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOM.describeNode' method.
           */
          interface DescribeNodeResult {
              /**
               * Node description.
               */
              node: Node;
          }
          /**
           * Parameters of the 'DOM.scrollIntoViewIfNeeded' method.
           */
          interface ScrollIntoViewIfNeededParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
              /**
               * The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
               * When omitted, center of the node will be used, similar to Element.scrollIntoView.
               */
              rect?: Rect;
          }
          /**
           * Return value of the 'DOM.scrollIntoViewIfNeeded' method.
           */
          interface ScrollIntoViewIfNeededResult {
          }
          /**
           * Parameters of the 'DOM.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'DOM.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'DOM.discardSearchResults' method.
           */
          interface DiscardSearchResultsParams {
              /**
               * Unique search session identifier.
               */
              searchId: string;
          }
          /**
           * Return value of the 'DOM.discardSearchResults' method.
           */
          interface DiscardSearchResultsResult {
          }
          /**
           * Parameters of the 'DOM.enable' method.
           */
          interface EnableParams {
              /**
               * Whether to include whitespaces in the children array of returned Nodes.
               */
              includeWhitespace?: 'none' | 'all';
          }
          /**
           * Return value of the 'DOM.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'DOM.focus' method.
           */
          interface FocusParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.focus' method.
           */
          interface FocusResult {
          }
          /**
           * Parameters of the 'DOM.getAttributes' method.
           */
          interface GetAttributesParams {
              /**
               * Id of the node to retrieve attibutes for.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.getAttributes' method.
           */
          interface GetAttributesResult {
              /**
               * An interleaved array of node attribute names and values.
               */
              attributes: string[];
          }
          /**
           * Parameters of the 'DOM.getBoxModel' method.
           */
          interface GetBoxModelParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.getBoxModel' method.
           */
          interface GetBoxModelResult {
              /**
               * Box model for the node.
               */
              model: BoxModel;
          }
          /**
           * Parameters of the 'DOM.getContentQuads' method.
           */
          interface GetContentQuadsParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.getContentQuads' method.
           */
          interface GetContentQuadsResult {
              /**
               * Quads that describe node layout relative to viewport.
               */
              quads: Quad[];
          }
          /**
           * Parameters of the 'DOM.getDocument' method.
           */
          interface GetDocumentParams {
              /**
               * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
               * entire subtree or provide an integer larger than 0.
               */
              depth?: integer;
              /**
               * Whether or not iframes and shadow roots should be traversed when returning the subtree
               * (default is false).
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOM.getDocument' method.
           */
          interface GetDocumentResult {
              /**
               * Resulting node.
               */
              root: Node;
          }
          /**
           * Parameters of the 'DOM.getFlattenedDocument' method.
           */
          interface GetFlattenedDocumentParams {
              /**
               * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
               * entire subtree or provide an integer larger than 0.
               */
              depth?: integer;
              /**
               * Whether or not iframes and shadow roots should be traversed when returning the subtree
               * (default is false).
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOM.getFlattenedDocument' method.
           */
          interface GetFlattenedDocumentResult {
              /**
               * Resulting node.
               */
              nodes: Node[];
          }
          /**
           * Parameters of the 'DOM.getNodesForSubtreeByStyle' method.
           */
          interface GetNodesForSubtreeByStyleParams {
              /**
               * Node ID pointing to the root of a subtree.
               */
              nodeId: NodeId;
              /**
               * The style to filter nodes by (includes nodes if any of properties matches).
               */
              computedStyles: CSSComputedStyleProperty[];
              /**
               * Whether or not iframes and shadow roots in the same target should be traversed when returning the
               * results (default is false).
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOM.getNodesForSubtreeByStyle' method.
           */
          interface GetNodesForSubtreeByStyleResult {
              /**
               * Resulting nodes.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.getNodeForLocation' method.
           */
          interface GetNodeForLocationParams {
              /**
               * X coordinate.
               */
              x: integer;
              /**
               * Y coordinate.
               */
              y: integer;
              /**
               * False to skip to the nearest non-UA shadow root ancestor (default: false).
               */
              includeUserAgentShadowDOM?: boolean;
              /**
               * Whether to ignore pointer-events: none on elements and hit test them.
               */
              ignorePointerEventsNone?: boolean;
          }
          /**
           * Return value of the 'DOM.getNodeForLocation' method.
           */
          interface GetNodeForLocationResult {
              /**
               * Resulting node.
               */
              backendNodeId: BackendNodeId;
              /**
               * Frame this node belongs to.
               */
              frameId: Page.FrameId;
              /**
               * Id of the node at given coordinates, only when enabled and requested document.
               */
              nodeId?: NodeId;
          }
          /**
           * Parameters of the 'DOM.getOuterHTML' method.
           */
          interface GetOuterHTMLParams {
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.getOuterHTML' method.
           */
          interface GetOuterHTMLResult {
              /**
               * Outer HTML markup.
               */
              outerHTML: string;
          }
          /**
           * Parameters of the 'DOM.getRelayoutBoundary' method.
           */
          interface GetRelayoutBoundaryParams {
              /**
               * Id of the node.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.getRelayoutBoundary' method.
           */
          interface GetRelayoutBoundaryResult {
              /**
               * Relayout boundary node id for the given node.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.getSearchResults' method.
           */
          interface GetSearchResultsParams {
              /**
               * Unique search session identifier.
               */
              searchId: string;
              /**
               * Start index of the search result to be returned.
               */
              fromIndex: integer;
              /**
               * End index of the search result to be returned.
               */
              toIndex: integer;
          }
          /**
           * Return value of the 'DOM.getSearchResults' method.
           */
          interface GetSearchResultsResult {
              /**
               * Ids of the search result nodes.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.hideHighlight' method.
           */
          interface HideHighlightParams {
          }
          /**
           * Return value of the 'DOM.hideHighlight' method.
           */
          interface HideHighlightResult {
          }
          /**
           * Parameters of the 'DOM.highlightNode' method.
           */
          interface HighlightNodeParams {
          }
          /**
           * Return value of the 'DOM.highlightNode' method.
           */
          interface HighlightNodeResult {
          }
          /**
           * Parameters of the 'DOM.highlightRect' method.
           */
          interface HighlightRectParams {
          }
          /**
           * Return value of the 'DOM.highlightRect' method.
           */
          interface HighlightRectResult {
          }
          /**
           * Parameters of the 'DOM.markUndoableState' method.
           */
          interface MarkUndoableStateParams {
          }
          /**
           * Return value of the 'DOM.markUndoableState' method.
           */
          interface MarkUndoableStateResult {
          }
          /**
           * Parameters of the 'DOM.moveTo' method.
           */
          interface MoveToParams {
              /**
               * Id of the node to move.
               */
              nodeId: NodeId;
              /**
               * Id of the element to drop the moved node into.
               */
              targetNodeId: NodeId;
              /**
               * Drop node before this one (if absent, the moved node becomes the last child of
               * `targetNodeId`).
               */
              insertBeforeNodeId?: NodeId;
          }
          /**
           * Return value of the 'DOM.moveTo' method.
           */
          interface MoveToResult {
              /**
               * New id of the moved node.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.performSearch' method.
           */
          interface PerformSearchParams {
              /**
               * Plain text or query selector or XPath search query.
               */
              query: string;
              /**
               * True to search in user agent shadow DOM.
               */
              includeUserAgentShadowDOM?: boolean;
          }
          /**
           * Return value of the 'DOM.performSearch' method.
           */
          interface PerformSearchResult {
              /**
               * Unique search session identifier.
               */
              searchId: string;
              /**
               * Number of search results.
               */
              resultCount: integer;
          }
          /**
           * Parameters of the 'DOM.pushNodeByPathToFrontend' method.
           */
          interface PushNodeByPathToFrontendParams {
              /**
               * Path to node in the proprietary format.
               */
              path: string;
          }
          /**
           * Return value of the 'DOM.pushNodeByPathToFrontend' method.
           */
          interface PushNodeByPathToFrontendResult {
              /**
               * Id of the node for given path.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.pushNodesByBackendIdsToFrontend' method.
           */
          interface PushNodesByBackendIdsToFrontendParams {
              /**
               * The array of backend node ids.
               */
              backendNodeIds: BackendNodeId[];
          }
          /**
           * Return value of the 'DOM.pushNodesByBackendIdsToFrontend' method.
           */
          interface PushNodesByBackendIdsToFrontendResult {
              /**
               * The array of ids of pushed nodes that correspond to the backend ids specified in
               * backendNodeIds.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.querySelector' method.
           */
          interface QuerySelectorParams {
              /**
               * Id of the node to query upon.
               */
              nodeId: NodeId;
              /**
               * Selector string.
               */
              selector: string;
          }
          /**
           * Return value of the 'DOM.querySelector' method.
           */
          interface QuerySelectorResult {
              /**
               * Query selector result.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.querySelectorAll' method.
           */
          interface QuerySelectorAllParams {
              /**
               * Id of the node to query upon.
               */
              nodeId: NodeId;
              /**
               * Selector string.
               */
              selector: string;
          }
          /**
           * Return value of the 'DOM.querySelectorAll' method.
           */
          interface QuerySelectorAllResult {
              /**
               * Query selector result.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.getTopLayerElements' method.
           */
          interface GetTopLayerElementsParams {
          }
          /**
           * Return value of the 'DOM.getTopLayerElements' method.
           */
          interface GetTopLayerElementsResult {
              /**
               * NodeIds of top layer elements
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.redo' method.
           */
          interface RedoParams {
          }
          /**
           * Return value of the 'DOM.redo' method.
           */
          interface RedoResult {
          }
          /**
           * Parameters of the 'DOM.removeAttribute' method.
           */
          interface RemoveAttributeParams {
              /**
               * Id of the element to remove attribute from.
               */
              nodeId: NodeId;
              /**
               * Name of the attribute to remove.
               */
              name: string;
          }
          /**
           * Return value of the 'DOM.removeAttribute' method.
           */
          interface RemoveAttributeResult {
          }
          /**
           * Parameters of the 'DOM.removeNode' method.
           */
          interface RemoveNodeParams {
              /**
               * Id of the node to remove.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.removeNode' method.
           */
          interface RemoveNodeResult {
          }
          /**
           * Parameters of the 'DOM.requestChildNodes' method.
           */
          interface RequestChildNodesParams {
              /**
               * Id of the node to get children for.
               */
              nodeId: NodeId;
              /**
               * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
               * entire subtree or provide an integer larger than 0.
               */
              depth?: integer;
              /**
               * Whether or not iframes and shadow roots should be traversed when returning the sub-tree
               * (default is false).
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOM.requestChildNodes' method.
           */
          interface RequestChildNodesResult {
          }
          /**
           * Parameters of the 'DOM.requestNode' method.
           */
          interface RequestNodeParams {
              /**
               * JavaScript object id to convert into node.
               */
              objectId: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.requestNode' method.
           */
          interface RequestNodeResult {
              /**
               * Node id for given object.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.resolveNode' method.
           */
          interface ResolveNodeParams {
              /**
               * Id of the node to resolve.
               */
              nodeId?: NodeId;
              /**
               * Backend identifier of the node to resolve.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * Symbolic group name that can be used to release multiple objects.
               */
              objectGroup?: string;
              /**
               * Execution context in which to resolve the node.
               */
              executionContextId?: CdpV8.Runtime.ExecutionContextId;
          }
          /**
           * Return value of the 'DOM.resolveNode' method.
           */
          interface ResolveNodeResult {
              /**
               * JavaScript object wrapper for given node.
               */
              object: CdpV8.Runtime.RemoteObject;
          }
          /**
           * Parameters of the 'DOM.setAttributeValue' method.
           */
          interface SetAttributeValueParams {
              /**
               * Id of the element to set attribute for.
               */
              nodeId: NodeId;
              /**
               * Attribute name.
               */
              name: string;
              /**
               * Attribute value.
               */
              value: string;
          }
          /**
           * Return value of the 'DOM.setAttributeValue' method.
           */
          interface SetAttributeValueResult {
          }
          /**
           * Parameters of the 'DOM.setAttributesAsText' method.
           */
          interface SetAttributesAsTextParams {
              /**
               * Id of the element to set attributes for.
               */
              nodeId: NodeId;
              /**
               * Text with a number of attributes. Will parse this text using HTML parser.
               */
              text: string;
              /**
               * Attribute name to replace with new attributes derived from text in case text parsed
               * successfully.
               */
              name?: string;
          }
          /**
           * Return value of the 'DOM.setAttributesAsText' method.
           */
          interface SetAttributesAsTextResult {
          }
          /**
           * Parameters of the 'DOM.setFileInputFiles' method.
           */
          interface SetFileInputFilesParams {
              /**
               * Array of file paths to set.
               */
              files: string[];
              /**
               * Identifier of the node.
               */
              nodeId?: NodeId;
              /**
               * Identifier of the backend node.
               */
              backendNodeId?: BackendNodeId;
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.setFileInputFiles' method.
           */
          interface SetFileInputFilesResult {
          }
          /**
           * Parameters of the 'DOM.setNodeStackTracesEnabled' method.
           */
          interface SetNodeStackTracesEnabledParams {
              /**
               * Enable or disable.
               */
              enable: boolean;
          }
          /**
           * Return value of the 'DOM.setNodeStackTracesEnabled' method.
           */
          interface SetNodeStackTracesEnabledResult {
          }
          /**
           * Parameters of the 'DOM.getNodeStackTraces' method.
           */
          interface GetNodeStackTracesParams {
              /**
               * Id of the node to get stack traces for.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.getNodeStackTraces' method.
           */
          interface GetNodeStackTracesResult {
              /**
               * Creation stack trace, if available.
               */
              creation?: CdpV8.Runtime.StackTrace;
          }
          /**
           * Parameters of the 'DOM.getFileInfo' method.
           */
          interface GetFileInfoParams {
              /**
               * JavaScript object id of the node wrapper.
               */
              objectId: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'DOM.getFileInfo' method.
           */
          interface GetFileInfoResult {
              path: string;
          }
          /**
           * Parameters of the 'DOM.setInspectedNode' method.
           */
          interface SetInspectedNodeParams {
              /**
               * DOM node id to be accessible by means of $x command line API.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.setInspectedNode' method.
           */
          interface SetInspectedNodeResult {
          }
          /**
           * Parameters of the 'DOM.setNodeName' method.
           */
          interface SetNodeNameParams {
              /**
               * Id of the node to set name for.
               */
              nodeId: NodeId;
              /**
               * New node's name.
               */
              name: string;
          }
          /**
           * Return value of the 'DOM.setNodeName' method.
           */
          interface SetNodeNameResult {
              /**
               * New node's id.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.setNodeValue' method.
           */
          interface SetNodeValueParams {
              /**
               * Id of the node to set value for.
               */
              nodeId: NodeId;
              /**
               * New node's value.
               */
              value: string;
          }
          /**
           * Return value of the 'DOM.setNodeValue' method.
           */
          interface SetNodeValueResult {
          }
          /**
           * Parameters of the 'DOM.setOuterHTML' method.
           */
          interface SetOuterHTMLParams {
              /**
               * Id of the node to set markup for.
               */
              nodeId: NodeId;
              /**
               * Outer HTML markup to set.
               */
              outerHTML: string;
          }
          /**
           * Return value of the 'DOM.setOuterHTML' method.
           */
          interface SetOuterHTMLResult {
          }
          /**
           * Parameters of the 'DOM.undo' method.
           */
          interface UndoParams {
          }
          /**
           * Return value of the 'DOM.undo' method.
           */
          interface UndoResult {
          }
          /**
           * Parameters of the 'DOM.getFrameOwner' method.
           */
          interface GetFrameOwnerParams {
              frameId: Page.FrameId;
          }
          /**
           * Return value of the 'DOM.getFrameOwner' method.
           */
          interface GetFrameOwnerResult {
              /**
               * Resulting node.
               */
              backendNodeId: BackendNodeId;
              /**
               * Id of the node at given coordinates, only when enabled and requested document.
               */
              nodeId?: NodeId;
          }
          /**
           * Parameters of the 'DOM.getContainerForNode' method.
           */
          interface GetContainerForNodeParams {
              nodeId: NodeId;
              containerName?: string;
              physicalAxes?: PhysicalAxes;
              logicalAxes?: LogicalAxes;
          }
          /**
           * Return value of the 'DOM.getContainerForNode' method.
           */
          interface GetContainerForNodeResult {
              /**
               * The container node for the given node, or null if not found.
               */
              nodeId?: NodeId;
          }
          /**
           * Parameters of the 'DOM.getQueryingDescendantsForContainer' method.
           */
          interface GetQueryingDescendantsForContainerParams {
              /**
               * Id of the container node to find querying descendants from.
               */
              nodeId: NodeId;
          }
          /**
           * Return value of the 'DOM.getQueryingDescendantsForContainer' method.
           */
          interface GetQueryingDescendantsForContainerResult {
              /**
               * Descendant nodes with container queries against the given container.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.attributeModified' event.
           */
          interface AttributeModifiedEvent {
              /**
               * Id of the node that has changed.
               */
              nodeId: NodeId;
              /**
               * Attribute name.
               */
              name: string;
              /**
               * Attribute value.
               */
              value: string;
          }
          /**
           * Parameters of the 'DOM.attributeRemoved' event.
           */
          interface AttributeRemovedEvent {
              /**
               * Id of the node that has changed.
               */
              nodeId: NodeId;
              /**
               * A ttribute name.
               */
              name: string;
          }
          /**
           * Parameters of the 'DOM.characterDataModified' event.
           */
          interface CharacterDataModifiedEvent {
              /**
               * Id of the node that has changed.
               */
              nodeId: NodeId;
              /**
               * New text value.
               */
              characterData: string;
          }
          /**
           * Parameters of the 'DOM.childNodeCountUpdated' event.
           */
          interface ChildNodeCountUpdatedEvent {
              /**
               * Id of the node that has changed.
               */
              nodeId: NodeId;
              /**
               * New node count.
               */
              childNodeCount: integer;
          }
          /**
           * Parameters of the 'DOM.childNodeInserted' event.
           */
          interface ChildNodeInsertedEvent {
              /**
               * Id of the node that has changed.
               */
              parentNodeId: NodeId;
              /**
               * Id of the previous sibling.
               */
              previousNodeId: NodeId;
              /**
               * Inserted node data.
               */
              node: Node;
          }
          /**
           * Parameters of the 'DOM.childNodeRemoved' event.
           */
          interface ChildNodeRemovedEvent {
              /**
               * Parent id.
               */
              parentNodeId: NodeId;
              /**
               * Id of the node that has been removed.
               */
              nodeId: NodeId;
          }
          /**
           * Parameters of the 'DOM.distributedNodesUpdated' event.
           */
          interface DistributedNodesUpdatedEvent {
              /**
               * Insertion point where distributed nodes were updated.
               */
              insertionPointId: NodeId;
              /**
               * Distributed nodes for given insertion point.
               */
              distributedNodes: BackendNode[];
          }
          /**
           * Parameters of the 'DOM.documentUpdated' event.
           */
          interface DocumentUpdatedEvent {
          }
          /**
           * Parameters of the 'DOM.inlineStyleInvalidated' event.
           */
          interface InlineStyleInvalidatedEvent {
              /**
               * Ids of the nodes for which the inline styles have been invalidated.
               */
              nodeIds: NodeId[];
          }
          /**
           * Parameters of the 'DOM.pseudoElementAdded' event.
           */
          interface PseudoElementAddedEvent {
              /**
               * Pseudo element's parent element id.
               */
              parentId: NodeId;
              /**
               * The added pseudo element.
               */
              pseudoElement: Node;
          }
          /**
           * Parameters of the 'DOM.topLayerElementsUpdated' event.
           */
          interface TopLayerElementsUpdatedEvent {
          }
          /**
           * Parameters of the 'DOM.pseudoElementRemoved' event.
           */
          interface PseudoElementRemovedEvent {
              /**
               * Pseudo element's parent element id.
               */
              parentId: NodeId;
              /**
               * The removed pseudo element id.
               */
              pseudoElementId: NodeId;
          }
          /**
           * Parameters of the 'DOM.setChildNodes' event.
           */
          interface SetChildNodesEvent {
              /**
               * Parent node id to populate with children.
               */
              parentId: NodeId;
              /**
               * Child nodes array.
               */
              nodes: Node[];
          }
          /**
           * Parameters of the 'DOM.shadowRootPopped' event.
           */
          interface ShadowRootPoppedEvent {
              /**
               * Host element id.
               */
              hostId: NodeId;
              /**
               * Shadow root id.
               */
              rootId: NodeId;
          }
          /**
           * Parameters of the 'DOM.shadowRootPushed' event.
           */
          interface ShadowRootPushedEvent {
              /**
               * Host element id.
               */
              hostId: NodeId;
              /**
               * Shadow root.
               */
              root: Node;
          }
          /**
           * Unique DOM node identifier.
           */
          type NodeId = integer;
          /**
           * Unique DOM node identifier used to reference a node that may not have been pushed to the
           * front-end.
           */
          type BackendNodeId = integer;
          /**
           * Backend node with a friendly name.
           */
          interface BackendNode {
              /**
               * `Node`'s nodeType.
               */
              nodeType: integer;
              /**
               * `Node`'s nodeName.
               */
              nodeName: string;
              backendNodeId: BackendNodeId;
          }
          /**
           * Pseudo element type.
           */
          type PseudoType = 'first-line' | 'first-letter' | 'before' | 'after' | 'marker' | 'backdrop' | 'selection' | 'target-text' | 'spelling-error' | 'grammar-error' | 'highlight' | 'first-line-inherited' | 'scrollbar' | 'scrollbar-thumb' | 'scrollbar-button' | 'scrollbar-track' | 'scrollbar-track-piece' | 'scrollbar-corner' | 'resizer' | 'input-list-button' | 'view-transition' | 'view-transition-group' | 'view-transition-image-pair' | 'view-transition-old' | 'view-transition-new';
          /**
           * Shadow root type.
           */
          type ShadowRootType = 'user-agent' | 'open' | 'closed';
          /**
           * Document compatibility mode.
           */
          type CompatibilityMode = 'QuirksMode' | 'LimitedQuirksMode' | 'NoQuirksMode';
          /**
           * ContainerSelector physical axes
           */
          type PhysicalAxes = 'Horizontal' | 'Vertical' | 'Both';
          /**
           * ContainerSelector logical axes
           */
          type LogicalAxes = 'Inline' | 'Block' | 'Both';
          /**
           * DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
           * DOMNode is a base node mirror type.
           */
          interface Node {
              /**
               * Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
               * will only push node with given `id` once. It is aware of all requested nodes and will only
               * fire DOM events for nodes known to the client.
               */
              nodeId: NodeId;
              /**
               * The id of the parent node if any.
               */
              parentId?: NodeId;
              /**
               * The BackendNodeId for this node.
               */
              backendNodeId: BackendNodeId;
              /**
               * `Node`'s nodeType.
               */
              nodeType: integer;
              /**
               * `Node`'s nodeName.
               */
              nodeName: string;
              /**
               * `Node`'s localName.
               */
              localName: string;
              /**
               * `Node`'s nodeValue.
               */
              nodeValue: string;
              /**
               * Child count for `Container` nodes.
               */
              childNodeCount?: integer;
              /**
               * Child nodes of this node when requested with children.
               */
              children?: Node[];
              /**
               * Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
               */
              attributes?: string[];
              /**
               * Document URL that `Document` or `FrameOwner` node points to.
               */
              documentURL?: string;
              /**
               * Base URL that `Document` or `FrameOwner` node uses for URL completion.
               */
              baseURL?: string;
              /**
               * `DocumentType`'s publicId.
               */
              publicId?: string;
              /**
               * `DocumentType`'s systemId.
               */
              systemId?: string;
              /**
               * `DocumentType`'s internalSubset.
               */
              internalSubset?: string;
              /**
               * `Document`'s XML version in case of XML documents.
               */
              xmlVersion?: string;
              /**
               * `Attr`'s name.
               */
              name?: string;
              /**
               * `Attr`'s value.
               */
              value?: string;
              /**
               * Pseudo element type for this node.
               */
              pseudoType?: PseudoType;
              /**
               * Pseudo element identifier for this node. Only present if there is a
               * valid pseudoType.
               */
              pseudoIdentifier?: string;
              /**
               * Shadow root type.
               */
              shadowRootType?: ShadowRootType;
              /**
               * Frame ID for frame owner elements.
               */
              frameId?: Page.FrameId;
              /**
               * Content document for frame owner elements.
               */
              contentDocument?: Node;
              /**
               * Shadow root list for given element host.
               */
              shadowRoots?: Node[];
              /**
               * Content document fragment for template elements.
               */
              templateContent?: Node;
              /**
               * Pseudo elements associated with this node.
               */
              pseudoElements?: Node[];
              /**
               * Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
               * This property used to return the imported document for the HTMLImport links.
               * The property is always undefined now.
               * @deprecated
               */
              importedDocument?: Node;
              /**
               * Distributed nodes for given insertion point.
               */
              distributedNodes?: BackendNode[];
              /**
               * Whether the node is SVG.
               */
              isSVG?: boolean;
              compatibilityMode?: CompatibilityMode;
              assignedSlot?: BackendNode;
          }
          /**
           * A structure holding an RGBA color.
           */
          interface RGBA {
              /**
               * The red component, in the [0-255] range.
               */
              r: integer;
              /**
               * The green component, in the [0-255] range.
               */
              g: integer;
              /**
               * The blue component, in the [0-255] range.
               */
              b: integer;
              /**
               * The alpha component, in the [0-1] range (default: 1).
               */
              a?: number;
          }
          /**
           * An array of quad vertices, x immediately followed by y for each point, points clock-wise.
           */
          type Quad = number[];
          /**
           * Box model.
           */
          interface BoxModel {
              /**
               * Content box
               */
              content: Quad;
              /**
               * Padding box
               */
              padding: Quad;
              /**
               * Border box
               */
              border: Quad;
              /**
               * Margin box
               */
              margin: Quad;
              /**
               * Node width
               */
              width: integer;
              /**
               * Node height
               */
              height: integer;
              /**
               * Shape outside coordinates
               */
              shapeOutside?: ShapeOutsideInfo;
          }
          /**
           * CSS Shape Outside details.
           */
          interface ShapeOutsideInfo {
              /**
               * Shape bounds
               */
              bounds: Quad;
              /**
               * Shape coordinate details
               */
              shape: any[];
              /**
               * Margin shape bounds
               */
              marginShape: any[];
          }
          /**
           * Rectangle.
           */
          interface Rect {
              /**
               * X coordinate
               */
              x: number;
              /**
               * Y coordinate
               */
              y: number;
              /**
               * Rectangle width
               */
              width: number;
              /**
               * Rectangle height
               */
              height: number;
          }
          interface CSSComputedStyleProperty {
              /**
               * Computed style property name.
               */
              name: string;
              /**
               * Computed style property value.
               */
              value: string;
          }
      }
      /**
       * Methods and events of the 'DOMDebugger' domain.
       */
      interface DOMDebuggerApi {
          requests: {
              /**
               * Returns event listeners of the given object.
               */
              getEventListeners: {
                  params: DOMDebugger.GetEventListenersParams;
                  result: DOMDebugger.GetEventListenersResult;
              };
              /**
               * Removes DOM breakpoint that was set using `setDOMBreakpoint`.
               */
              removeDOMBreakpoint: {
                  params: DOMDebugger.RemoveDOMBreakpointParams;
                  result: DOMDebugger.RemoveDOMBreakpointResult;
              };
              /**
               * Removes breakpoint on particular DOM event.
               */
              removeEventListenerBreakpoint: {
                  params: DOMDebugger.RemoveEventListenerBreakpointParams;
                  result: DOMDebugger.RemoveEventListenerBreakpointResult;
              };
              /**
               * Removes breakpoint on particular native event.
               * @deprecated
               */
              removeInstrumentationBreakpoint: {
                  params: DOMDebugger.RemoveInstrumentationBreakpointParams;
                  result: DOMDebugger.RemoveInstrumentationBreakpointResult;
              };
              /**
               * Removes breakpoint from XMLHttpRequest.
               */
              removeXHRBreakpoint: {
                  params: DOMDebugger.RemoveXHRBreakpointParams;
                  result: DOMDebugger.RemoveXHRBreakpointResult;
              };
              /**
               * Sets breakpoint on particular CSP violations.
               */
              setBreakOnCSPViolation: {
                  params: DOMDebugger.SetBreakOnCSPViolationParams;
                  result: DOMDebugger.SetBreakOnCSPViolationResult;
              };
              /**
               * Sets breakpoint on particular operation with DOM.
               */
              setDOMBreakpoint: {
                  params: DOMDebugger.SetDOMBreakpointParams;
                  result: DOMDebugger.SetDOMBreakpointResult;
              };
              /**
               * Sets breakpoint on particular DOM event.
               */
              setEventListenerBreakpoint: {
                  params: DOMDebugger.SetEventListenerBreakpointParams;
                  result: DOMDebugger.SetEventListenerBreakpointResult;
              };
              /**
               * Sets breakpoint on particular native event.
               * @deprecated
               */
              setInstrumentationBreakpoint: {
                  params: DOMDebugger.SetInstrumentationBreakpointParams;
                  result: DOMDebugger.SetInstrumentationBreakpointResult;
              };
              /**
               * Sets breakpoint on XMLHttpRequest.
               */
              setXHRBreakpoint: {
                  params: DOMDebugger.SetXHRBreakpointParams;
                  result: DOMDebugger.SetXHRBreakpointResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'DOMDebugger' domain.
       */
      namespace DOMDebugger {
          /**
           * Parameters of the 'DOMDebugger.getEventListeners' method.
           */
          interface GetEventListenersParams {
              /**
               * Identifier of the object to return listeners for.
               */
              objectId: CdpV8.Runtime.RemoteObjectId;
              /**
               * The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
               * entire subtree or provide an integer larger than 0.
               */
              depth?: integer;
              /**
               * Whether or not iframes and shadow roots should be traversed when returning the subtree
               * (default is false). Reports listeners for all contexts if pierce is enabled.
               */
              pierce?: boolean;
          }
          /**
           * Return value of the 'DOMDebugger.getEventListeners' method.
           */
          interface GetEventListenersResult {
              /**
               * Array of relevant listeners.
               */
              listeners: EventListener[];
          }
          /**
           * Parameters of the 'DOMDebugger.removeDOMBreakpoint' method.
           */
          interface RemoveDOMBreakpointParams {
              /**
               * Identifier of the node to remove breakpoint from.
               */
              nodeId: DOM.NodeId;
              /**
               * Type of the breakpoint to remove.
               */
              type: DOMBreakpointType;
          }
          /**
           * Return value of the 'DOMDebugger.removeDOMBreakpoint' method.
           */
          interface RemoveDOMBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.removeEventListenerBreakpoint' method.
           */
          interface RemoveEventListenerBreakpointParams {
              /**
               * Event name.
               */
              eventName: string;
              /**
               * EventTarget interface name.
               */
              targetName?: string;
          }
          /**
           * Return value of the 'DOMDebugger.removeEventListenerBreakpoint' method.
           */
          interface RemoveEventListenerBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.removeInstrumentationBreakpoint' method.
           */
          interface RemoveInstrumentationBreakpointParams {
              /**
               * Instrumentation name to stop on.
               */
              eventName: string;
          }
          /**
           * Return value of the 'DOMDebugger.removeInstrumentationBreakpoint' method.
           */
          interface RemoveInstrumentationBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.removeXHRBreakpoint' method.
           */
          interface RemoveXHRBreakpointParams {
              /**
               * Resource URL substring.
               */
              url: string;
          }
          /**
           * Return value of the 'DOMDebugger.removeXHRBreakpoint' method.
           */
          interface RemoveXHRBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.setBreakOnCSPViolation' method.
           */
          interface SetBreakOnCSPViolationParams {
              /**
               * CSP Violations to stop upon.
               */
              violationTypes: CSPViolationType[];
          }
          /**
           * Return value of the 'DOMDebugger.setBreakOnCSPViolation' method.
           */
          interface SetBreakOnCSPViolationResult {
          }
          /**
           * Parameters of the 'DOMDebugger.setDOMBreakpoint' method.
           */
          interface SetDOMBreakpointParams {
              /**
               * Identifier of the node to set breakpoint on.
               */
              nodeId: DOM.NodeId;
              /**
               * Type of the operation to stop upon.
               */
              type: DOMBreakpointType;
          }
          /**
           * Return value of the 'DOMDebugger.setDOMBreakpoint' method.
           */
          interface SetDOMBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.setEventListenerBreakpoint' method.
           */
          interface SetEventListenerBreakpointParams {
              /**
               * DOM Event name to stop on (any DOM event will do).
               */
              eventName: string;
              /**
               * EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
               * EventTarget.
               */
              targetName?: string;
          }
          /**
           * Return value of the 'DOMDebugger.setEventListenerBreakpoint' method.
           */
          interface SetEventListenerBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointParams {
              /**
               * Instrumentation name to stop on.
               */
              eventName: string;
          }
          /**
           * Return value of the 'DOMDebugger.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointResult {
          }
          /**
           * Parameters of the 'DOMDebugger.setXHRBreakpoint' method.
           */
          interface SetXHRBreakpointParams {
              /**
               * Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
               */
              url: string;
          }
          /**
           * Return value of the 'DOMDebugger.setXHRBreakpoint' method.
           */
          interface SetXHRBreakpointResult {
          }
          /**
           * DOM breakpoint type.
           */
          type DOMBreakpointType = 'subtree-modified' | 'attribute-modified' | 'node-removed';
          /**
           * CSP Violation type.
           */
          type CSPViolationType = 'trustedtype-sink-violation' | 'trustedtype-policy-violation';
          /**
           * Object event listener.
           */
          interface EventListener {
              /**
               * `EventListener`'s type.
               */
              type: string;
              /**
               * `EventListener`'s useCapture.
               */
              useCapture: boolean;
              /**
               * `EventListener`'s passive flag.
               */
              passive: boolean;
              /**
               * `EventListener`'s once flag.
               */
              once: boolean;
              /**
               * Script id of the handler code.
               */
              scriptId: CdpV8.Runtime.ScriptId;
              /**
               * Line number in the script (0-based).
               */
              lineNumber: integer;
              /**
               * Column number in the script (0-based).
               */
              columnNumber: integer;
              /**
               * Event handler function value.
               */
              handler?: CdpV8.Runtime.RemoteObject;
              /**
               * Event original handler function value.
               */
              originalHandler?: CdpV8.Runtime.RemoteObject;
              /**
               * Node the listener is added to (if any).
               */
              backendNodeId?: DOM.BackendNodeId;
          }
      }
      /**
       * Methods and events of the 'EventBreakpoints' domain.
       */
      interface EventBreakpointsApi {
          requests: {
              /**
               * Sets breakpoint on particular native event.
               */
              setInstrumentationBreakpoint: {
                  params: EventBreakpoints.SetInstrumentationBreakpointParams;
                  result: EventBreakpoints.SetInstrumentationBreakpointResult;
              };
              /**
               * Removes breakpoint on particular native event.
               */
              removeInstrumentationBreakpoint: {
                  params: EventBreakpoints.RemoveInstrumentationBreakpointParams;
                  result: EventBreakpoints.RemoveInstrumentationBreakpointResult;
              };
              /**
               * Removes all breakpoints
               */
              disable: {
                  params: EventBreakpoints.DisableParams;
                  result: EventBreakpoints.DisableResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'EventBreakpoints' domain.
       */
      namespace EventBreakpoints {
          /**
           * Parameters of the 'EventBreakpoints.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointParams {
              /**
               * Instrumentation name to stop on.
               */
              eventName: string;
          }
          /**
           * Return value of the 'EventBreakpoints.setInstrumentationBreakpoint' method.
           */
          interface SetInstrumentationBreakpointResult {
          }
          /**
           * Parameters of the 'EventBreakpoints.removeInstrumentationBreakpoint' method.
           */
          interface RemoveInstrumentationBreakpointParams {
              /**
               * Instrumentation name to stop on.
               */
              eventName: string;
          }
          /**
           * Return value of the 'EventBreakpoints.removeInstrumentationBreakpoint' method.
           */
          interface RemoveInstrumentationBreakpointResult {
          }
          /**
           * Parameters of the 'EventBreakpoints.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'EventBreakpoints.disable' method.
           */
          interface DisableResult {
          }
      }
      /**
       * Methods and events of the 'DOMSnapshot' domain.
       */
      interface DOMSnapshotApi {
          requests: {
              /**
               * Disables DOM snapshot agent for the given page.
               */
              disable: {
                  params: DOMSnapshot.DisableParams;
                  result: DOMSnapshot.DisableResult;
              };
              /**
               * Enables DOM snapshot agent for the given page.
               */
              enable: {
                  params: DOMSnapshot.EnableParams;
                  result: DOMSnapshot.EnableResult;
              };
              /**
               * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
               * template contents, and imported documents) in a flattened array, as well as layout and
               * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
               * flattened.
               * @deprecated
               */
              getSnapshot: {
                  params: DOMSnapshot.GetSnapshotParams;
                  result: DOMSnapshot.GetSnapshotResult;
              };
              /**
               * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
               * template contents, and imported documents) in a flattened array, as well as layout and
               * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
               * flattened.
               */
              captureSnapshot: {
                  params: DOMSnapshot.CaptureSnapshotParams;
                  result: DOMSnapshot.CaptureSnapshotResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'DOMSnapshot' domain.
       */
      namespace DOMSnapshot {
          /**
           * Parameters of the 'DOMSnapshot.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'DOMSnapshot.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'DOMSnapshot.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'DOMSnapshot.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'DOMSnapshot.getSnapshot' method.
           */
          interface GetSnapshotParams {
              /**
               * Whitelist of computed styles to return.
               */
              computedStyleWhitelist: string[];
              /**
               * Whether or not to retrieve details of DOM listeners (default false).
               */
              includeEventListeners?: boolean;
              /**
               * Whether to determine and include the paint order index of LayoutTreeNodes (default false).
               */
              includePaintOrder?: boolean;
              /**
               * Whether to include UA shadow tree in the snapshot (default false).
               */
              includeUserAgentShadowTree?: boolean;
          }
          /**
           * Return value of the 'DOMSnapshot.getSnapshot' method.
           */
          interface GetSnapshotResult {
              /**
               * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
               */
              domNodes: DOMNode[];
              /**
               * The nodes in the layout tree.
               */
              layoutTreeNodes: LayoutTreeNode[];
              /**
               * Whitelisted ComputedStyle properties for each node in the layout tree.
               */
              computedStyles: ComputedStyle[];
          }
          /**
           * Parameters of the 'DOMSnapshot.captureSnapshot' method.
           */
          interface CaptureSnapshotParams {
              /**
               * Whitelist of computed styles to return.
               */
              computedStyles: string[];
              /**
               * Whether to include layout object paint orders into the snapshot.
               */
              includePaintOrder?: boolean;
              /**
               * Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
               */
              includeDOMRects?: boolean;
              /**
               * Whether to include blended background colors in the snapshot (default: false).
               * Blended background color is achieved by blending background colors of all elements
               * that overlap with the current element.
               */
              includeBlendedBackgroundColors?: boolean;
              /**
               * Whether to include text color opacity in the snapshot (default: false).
               * An element might have the opacity property set that affects the text color of the element.
               * The final text color opacity is computed based on the opacity of all overlapping elements.
               */
              includeTextColorOpacities?: boolean;
          }
          /**
           * Return value of the 'DOMSnapshot.captureSnapshot' method.
           */
          interface CaptureSnapshotResult {
              /**
               * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
               */
              documents: DocumentSnapshot[];
              /**
               * Shared string table that all string properties refer to with indexes.
               */
              strings: string[];
          }
          /**
           * A Node in the DOM tree.
           */
          interface DOMNode {
              /**
               * `Node`'s nodeType.
               */
              nodeType: integer;
              /**
               * `Node`'s nodeName.
               */
              nodeName: string;
              /**
               * `Node`'s nodeValue.
               */
              nodeValue: string;
              /**
               * Only set for textarea elements, contains the text value.
               */
              textValue?: string;
              /**
               * Only set for input elements, contains the input's associated text value.
               */
              inputValue?: string;
              /**
               * Only set for radio and checkbox input elements, indicates if the element has been checked
               */
              inputChecked?: boolean;
              /**
               * Only set for option elements, indicates if the element has been selected
               */
              optionSelected?: boolean;
              /**
               * `Node`'s id, corresponds to DOM.Node.backendNodeId.
               */
              backendNodeId: DOM.BackendNodeId;
              /**
               * The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
               * any.
               */
              childNodeIndexes?: integer[];
              /**
               * Attributes of an `Element` node.
               */
              attributes?: NameValue[];
              /**
               * Indexes of pseudo elements associated with this node in the `domNodes` array returned by
               * `getSnapshot`, if any.
               */
              pseudoElementIndexes?: integer[];
              /**
               * The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
               * `getSnapshot`, if any.
               */
              layoutNodeIndex?: integer;
              /**
               * Document URL that `Document` or `FrameOwner` node points to.
               */
              documentURL?: string;
              /**
               * Base URL that `Document` or `FrameOwner` node uses for URL completion.
               */
              baseURL?: string;
              /**
               * Only set for documents, contains the document's content language.
               */
              contentLanguage?: string;
              /**
               * Only set for documents, contains the document's character set encoding.
               */
              documentEncoding?: string;
              /**
               * `DocumentType` node's publicId.
               */
              publicId?: string;
              /**
               * `DocumentType` node's systemId.
               */
              systemId?: string;
              /**
               * Frame ID for frame owner elements and also for the document node.
               */
              frameId?: Page.FrameId;
              /**
               * The index of a frame owner element's content document in the `domNodes` array returned by
               * `getSnapshot`, if any.
               */
              contentDocumentIndex?: integer;
              /**
               * Type of a pseudo element node.
               */
              pseudoType?: DOM.PseudoType;
              /**
               * Shadow root type.
               */
              shadowRootType?: DOM.ShadowRootType;
              /**
               * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
               * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
               * clicked.
               */
              isClickable?: boolean;
              /**
               * Details of the node's event listeners, if any.
               */
              eventListeners?: DOMDebugger.EventListener[];
              /**
               * The selected url for nodes with a srcset attribute.
               */
              currentSourceURL?: string;
              /**
               * The url of the script (if any) that generates this node.
               */
              originURL?: string;
              /**
               * Scroll offsets, set when this node is a Document.
               */
              scrollOffsetX?: number;
              scrollOffsetY?: number;
          }
          /**
           * Details of post layout rendered text positions. The exact layout should not be regarded as
           * stable and may change between versions.
           */
          interface InlineTextBox {
              /**
               * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
               */
              boundingBox: DOM.Rect;
              /**
               * The starting index in characters, for this post layout textbox substring. Characters that
               * would be represented as a surrogate pair in UTF-16 have length 2.
               */
              startCharacterIndex: integer;
              /**
               * The number of characters in this post layout textbox substring. Characters that would be
               * represented as a surrogate pair in UTF-16 have length 2.
               */
              numCharacters: integer;
          }
          /**
           * Details of an element in the DOM tree with a LayoutObject.
           */
          interface LayoutTreeNode {
              /**
               * The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
               */
              domNodeIndex: integer;
              /**
               * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
               */
              boundingBox: DOM.Rect;
              /**
               * Contents of the LayoutText, if any.
               */
              layoutText?: string;
              /**
               * The post-layout inline text nodes, if any.
               */
              inlineTextNodes?: InlineTextBox[];
              /**
               * Index into the `computedStyles` array returned by `getSnapshot`.
               */
              styleIndex?: integer;
              /**
               * Global paint order index, which is determined by the stacking order of the nodes. Nodes
               * that are painted together will have the same index. Only provided if includePaintOrder in
               * getSnapshot was true.
               */
              paintOrder?: integer;
              /**
               * Set to true to indicate the element begins a new stacking context.
               */
              isStackingContext?: boolean;
          }
          /**
           * A subset of the full ComputedStyle as defined by the request whitelist.
           */
          interface ComputedStyle {
              /**
               * Name/value pairs of computed style properties.
               */
              properties: NameValue[];
          }
          /**
           * A name/value pair.
           */
          interface NameValue {
              /**
               * Attribute/property name.
               */
              name: string;
              /**
               * Attribute/property value.
               */
              value: string;
          }
          /**
           * Index of the string in the strings table.
           */
          type StringIndex = integer;
          /**
           * Index of the string in the strings table.
           */
          type ArrayOfStrings = StringIndex[];
          /**
           * Data that is only present on rare nodes.
           */
          interface RareStringData {
              index: integer[];
              value: StringIndex[];
          }
          interface RareBooleanData {
              index: integer[];
          }
          interface RareIntegerData {
              index: integer[];
              value: integer[];
          }
          type Rectangle = number[];
          /**
           * Document snapshot.
           */
          interface DocumentSnapshot {
              /**
               * Document URL that `Document` or `FrameOwner` node points to.
               */
              documentURL: StringIndex;
              /**
               * Document title.
               */
              title: StringIndex;
              /**
               * Base URL that `Document` or `FrameOwner` node uses for URL completion.
               */
              baseURL: StringIndex;
              /**
               * Contains the document's content language.
               */
              contentLanguage: StringIndex;
              /**
               * Contains the document's character set encoding.
               */
              encodingName: StringIndex;
              /**
               * `DocumentType` node's publicId.
               */
              publicId: StringIndex;
              /**
               * `DocumentType` node's systemId.
               */
              systemId: StringIndex;
              /**
               * Frame ID for frame owner elements and also for the document node.
               */
              frameId: StringIndex;
              /**
               * A table with dom nodes.
               */
              nodes: NodeTreeSnapshot;
              /**
               * The nodes in the layout tree.
               */
              layout: LayoutTreeSnapshot;
              /**
               * The post-layout inline text nodes.
               */
              textBoxes: TextBoxSnapshot;
              /**
               * Horizontal scroll offset.
               */
              scrollOffsetX?: number;
              /**
               * Vertical scroll offset.
               */
              scrollOffsetY?: number;
              /**
               * Document content width.
               */
              contentWidth?: number;
              /**
               * Document content height.
               */
              contentHeight?: number;
          }
          /**
           * Table containing nodes.
           */
          interface NodeTreeSnapshot {
              /**
               * Parent node index.
               */
              parentIndex?: integer[];
              /**
               * `Node`'s nodeType.
               */
              nodeType?: integer[];
              /**
               * Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
               */
              shadowRootType?: RareStringData;
              /**
               * `Node`'s nodeName.
               */
              nodeName?: StringIndex[];
              /**
               * `Node`'s nodeValue.
               */
              nodeValue?: StringIndex[];
              /**
               * `Node`'s id, corresponds to DOM.Node.backendNodeId.
               */
              backendNodeId?: DOM.BackendNodeId[];
              /**
               * Attributes of an `Element` node. Flatten name, value pairs.
               */
              attributes?: ArrayOfStrings[];
              /**
               * Only set for textarea elements, contains the text value.
               */
              textValue?: RareStringData;
              /**
               * Only set for input elements, contains the input's associated text value.
               */
              inputValue?: RareStringData;
              /**
               * Only set for radio and checkbox input elements, indicates if the element has been checked
               */
              inputChecked?: RareBooleanData;
              /**
               * Only set for option elements, indicates if the element has been selected
               */
              optionSelected?: RareBooleanData;
              /**
               * The index of the document in the list of the snapshot documents.
               */
              contentDocumentIndex?: RareIntegerData;
              /**
               * Type of a pseudo element node.
               */
              pseudoType?: RareStringData;
              /**
               * Pseudo element identifier for this node. Only present if there is a
               * valid pseudoType.
               */
              pseudoIdentifier?: RareStringData;
              /**
               * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
               * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
               * clicked.
               */
              isClickable?: RareBooleanData;
              /**
               * The selected url for nodes with a srcset attribute.
               */
              currentSourceURL?: RareStringData;
              /**
               * The url of the script (if any) that generates this node.
               */
              originURL?: RareStringData;
          }
          /**
           * Table of details of an element in the DOM tree with a LayoutObject.
           */
          interface LayoutTreeSnapshot {
              /**
               * Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
               */
              nodeIndex: integer[];
              /**
               * Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
               */
              styles: ArrayOfStrings[];
              /**
               * The absolute position bounding box.
               */
              bounds: Rectangle[];
              /**
               * Contents of the LayoutText, if any.
               */
              text: StringIndex[];
              /**
               * Stacking context information.
               */
              stackingContexts: RareBooleanData;
              /**
               * Global paint order index, which is determined by the stacking order of the nodes. Nodes
               * that are painted together will have the same index. Only provided if includePaintOrder in
               * captureSnapshot was true.
               */
              paintOrders?: integer[];
              /**
               * The offset rect of nodes. Only available when includeDOMRects is set to true
               */
              offsetRects?: Rectangle[];
              /**
               * The scroll rect of nodes. Only available when includeDOMRects is set to true
               */
              scrollRects?: Rectangle[];
              /**
               * The client rect of nodes. Only available when includeDOMRects is set to true
               */
              clientRects?: Rectangle[];
              /**
               * The list of background colors that are blended with colors of overlapping elements.
               */
              blendedBackgroundColors?: StringIndex[];
              /**
               * The list of computed text opacities.
               */
              textColorOpacities?: number[];
          }
          /**
           * Table of details of the post layout rendered text positions. The exact layout should not be regarded as
           * stable and may change between versions.
           */
          interface TextBoxSnapshot {
              /**
               * Index of the layout tree node that owns this box collection.
               */
              layoutIndex: integer[];
              /**
               * The absolute position bounding box.
               */
              bounds: Rectangle[];
              /**
               * The starting index in characters, for this post layout textbox substring. Characters that
               * would be represented as a surrogate pair in UTF-16 have length 2.
               */
              start: integer[];
              /**
               * The number of characters in this post layout textbox substring. Characters that would be
               * represented as a surrogate pair in UTF-16 have length 2.
               */
              length: integer[];
          }
      }
      /**
       * Methods and events of the 'DOMStorage' domain.
       */
      interface DOMStorageApi {
          requests: {
              clear: {
                  params: DOMStorage.ClearParams;
                  result: DOMStorage.ClearResult;
              };
              /**
               * Disables storage tracking, prevents storage events from being sent to the client.
               */
              disable: {
                  params: DOMStorage.DisableParams;
                  result: DOMStorage.DisableResult;
              };
              /**
               * Enables storage tracking, storage events will now be delivered to the client.
               */
              enable: {
                  params: DOMStorage.EnableParams;
                  result: DOMStorage.EnableResult;
              };
              getDOMStorageItems: {
                  params: DOMStorage.GetDOMStorageItemsParams;
                  result: DOMStorage.GetDOMStorageItemsResult;
              };
              removeDOMStorageItem: {
                  params: DOMStorage.RemoveDOMStorageItemParams;
                  result: DOMStorage.RemoveDOMStorageItemResult;
              };
              setDOMStorageItem: {
                  params: DOMStorage.SetDOMStorageItemParams;
                  result: DOMStorage.SetDOMStorageItemResult;
              };
          };
          events: {
              domStorageItemAdded: {
                  params: DOMStorage.DomStorageItemAddedEvent;
              };
              domStorageItemRemoved: {
                  params: DOMStorage.DomStorageItemRemovedEvent;
              };
              domStorageItemUpdated: {
                  params: DOMStorage.DomStorageItemUpdatedEvent;
              };
              domStorageItemsCleared: {
                  params: DOMStorage.DomStorageItemsClearedEvent;
              };
          };
      }
      /**
       * Types of the 'DOMStorage' domain.
       */
      namespace DOMStorage {
          /**
           * Parameters of the 'DOMStorage.clear' method.
           */
          interface ClearParams {
              storageId: StorageId;
          }
          /**
           * Return value of the 'DOMStorage.clear' method.
           */
          interface ClearResult {
          }
          /**
           * Parameters of the 'DOMStorage.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'DOMStorage.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'DOMStorage.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'DOMStorage.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'DOMStorage.getDOMStorageItems' method.
           */
          interface GetDOMStorageItemsParams {
              storageId: StorageId;
          }
          /**
           * Return value of the 'DOMStorage.getDOMStorageItems' method.
           */
          interface GetDOMStorageItemsResult {
              entries: Item[];
          }
          /**
           * Parameters of the 'DOMStorage.removeDOMStorageItem' method.
           */
          interface RemoveDOMStorageItemParams {
              storageId: StorageId;
              key: string;
          }
          /**
           * Return value of the 'DOMStorage.removeDOMStorageItem' method.
           */
          interface RemoveDOMStorageItemResult {
          }
          /**
           * Parameters of the 'DOMStorage.setDOMStorageItem' method.
           */
          interface SetDOMStorageItemParams {
              storageId: StorageId;
              key: string;
              value: string;
          }
          /**
           * Return value of the 'DOMStorage.setDOMStorageItem' method.
           */
          interface SetDOMStorageItemResult {
          }
          /**
           * Parameters of the 'DOMStorage.domStorageItemAdded' event.
           */
          interface DomStorageItemAddedEvent {
              storageId: StorageId;
              key: string;
              newValue: string;
          }
          /**
           * Parameters of the 'DOMStorage.domStorageItemRemoved' event.
           */
          interface DomStorageItemRemovedEvent {
              storageId: StorageId;
              key: string;
          }
          /**
           * Parameters of the 'DOMStorage.domStorageItemUpdated' event.
           */
          interface DomStorageItemUpdatedEvent {
              storageId: StorageId;
              key: string;
              oldValue: string;
              newValue: string;
          }
          /**
           * Parameters of the 'DOMStorage.domStorageItemsCleared' event.
           */
          interface DomStorageItemsClearedEvent {
              storageId: StorageId;
          }
          type SerializedStorageKey = string;
          /**
           * DOM Storage identifier.
           */
          interface StorageId {
              /**
               * Security origin for the storage.
               */
              securityOrigin?: string;
              /**
               * Represents a key by which DOM Storage keys its CachedStorageAreas
               */
              storageKey?: SerializedStorageKey;
              /**
               * Whether the storage is local storage (not session storage).
               */
              isLocalStorage: boolean;
          }
          /**
           * DOM Storage item.
           */
          type Item = string[];
      }
      /**
       * Methods and events of the 'Database' domain.
       */
      interface DatabaseApi {
          requests: {
              /**
               * Disables database tracking, prevents database events from being sent to the client.
               */
              disable: {
                  params: Database.DisableParams;
                  result: Database.DisableResult;
              };
              /**
               * Enables database tracking, database events will now be delivered to the client.
               */
              enable: {
                  params: Database.EnableParams;
                  result: Database.EnableResult;
              };
              executeSQL: {
                  params: Database.ExecuteSQLParams;
                  result: Database.ExecuteSQLResult;
              };
              getDatabaseTableNames: {
                  params: Database.GetDatabaseTableNamesParams;
                  result: Database.GetDatabaseTableNamesResult;
              };
          };
          events: {
              addDatabase: {
                  params: Database.AddDatabaseEvent;
              };
          };
      }
      /**
       * Types of the 'Database' domain.
       */
      namespace Database {
          /**
           * Parameters of the 'Database.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Database.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Database.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Database.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Database.executeSQL' method.
           */
          interface ExecuteSQLParams {
              databaseId: DatabaseId;
              query: string;
          }
          /**
           * Return value of the 'Database.executeSQL' method.
           */
          interface ExecuteSQLResult {
              columnNames?: string[];
              values?: any[];
              sqlError?: Error;
          }
          /**
           * Parameters of the 'Database.getDatabaseTableNames' method.
           */
          interface GetDatabaseTableNamesParams {
              databaseId: DatabaseId;
          }
          /**
           * Return value of the 'Database.getDatabaseTableNames' method.
           */
          interface GetDatabaseTableNamesResult {
              tableNames: string[];
          }
          /**
           * Parameters of the 'Database.addDatabase' event.
           */
          interface AddDatabaseEvent {
              database: Database;
          }
          /**
           * Unique identifier of Database object.
           */
          type DatabaseId = string;
          /**
           * Database object.
           */
          interface Database {
              /**
               * Database ID.
               */
              id: DatabaseId;
              /**
               * Database domain.
               */
              domain: string;
              /**
               * Database name.
               */
              name: string;
              /**
               * Database version.
               */
              version: string;
          }
          /**
           * Database error.
           */
          interface Error {
              /**
               * Error message.
               */
              message: string;
              /**
               * Error code.
               */
              code: integer;
          }
      }
      /**
       * Methods and events of the 'DeviceOrientation' domain.
       */
      interface DeviceOrientationApi {
          requests: {
              /**
               * Clears the overridden Device Orientation.
               */
              clearDeviceOrientationOverride: {
                  params: DeviceOrientation.ClearDeviceOrientationOverrideParams;
                  result: DeviceOrientation.ClearDeviceOrientationOverrideResult;
              };
              /**
               * Overrides the Device Orientation.
               */
              setDeviceOrientationOverride: {
                  params: DeviceOrientation.SetDeviceOrientationOverrideParams;
                  result: DeviceOrientation.SetDeviceOrientationOverrideResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'DeviceOrientation' domain.
       */
      namespace DeviceOrientation {
          /**
           * Parameters of the 'DeviceOrientation.clearDeviceOrientationOverride' method.
           */
          interface ClearDeviceOrientationOverrideParams {
          }
          /**
           * Return value of the 'DeviceOrientation.clearDeviceOrientationOverride' method.
           */
          interface ClearDeviceOrientationOverrideResult {
          }
          /**
           * Parameters of the 'DeviceOrientation.setDeviceOrientationOverride' method.
           */
          interface SetDeviceOrientationOverrideParams {
              /**
               * Mock alpha
               */
              alpha: number;
              /**
               * Mock beta
               */
              beta: number;
              /**
               * Mock gamma
               */
              gamma: number;
          }
          /**
           * Return value of the 'DeviceOrientation.setDeviceOrientationOverride' method.
           */
          interface SetDeviceOrientationOverrideResult {
          }
      }
      /**
       * Methods and events of the 'Emulation' domain.
       */
      interface EmulationApi {
          requests: {
              /**
               * Tells whether emulation is supported.
               */
              canEmulate: {
                  params: Emulation.CanEmulateParams;
                  result: Emulation.CanEmulateResult;
              };
              /**
               * Clears the overridden device metrics.
               */
              clearDeviceMetricsOverride: {
                  params: Emulation.ClearDeviceMetricsOverrideParams;
                  result: Emulation.ClearDeviceMetricsOverrideResult;
              };
              /**
               * Clears the overridden Geolocation Position and Error.
               */
              clearGeolocationOverride: {
                  params: Emulation.ClearGeolocationOverrideParams;
                  result: Emulation.ClearGeolocationOverrideResult;
              };
              /**
               * Requests that page scale factor is reset to initial values.
               */
              resetPageScaleFactor: {
                  params: Emulation.ResetPageScaleFactorParams;
                  result: Emulation.ResetPageScaleFactorResult;
              };
              /**
               * Enables or disables simulating a focused and active page.
               */
              setFocusEmulationEnabled: {
                  params: Emulation.SetFocusEmulationEnabledParams;
                  result: Emulation.SetFocusEmulationEnabledResult;
              };
              /**
               * Automatically render all web contents using a dark theme.
               */
              setAutoDarkModeOverride: {
                  params: Emulation.SetAutoDarkModeOverrideParams;
                  result: Emulation.SetAutoDarkModeOverrideResult;
              };
              /**
               * Enables CPU throttling to emulate slow CPUs.
               */
              setCPUThrottlingRate: {
                  params: Emulation.SetCPUThrottlingRateParams;
                  result: Emulation.SetCPUThrottlingRateResult;
              };
              /**
               * Sets or clears an override of the default background color of the frame. This override is used
               * if the content does not specify one.
               */
              setDefaultBackgroundColorOverride: {
                  params: Emulation.SetDefaultBackgroundColorOverrideParams;
                  result: Emulation.SetDefaultBackgroundColorOverrideResult;
              };
              /**
               * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
               * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
               * query results).
               */
              setDeviceMetricsOverride: {
                  params: Emulation.SetDeviceMetricsOverrideParams;
                  result: Emulation.SetDeviceMetricsOverrideResult;
              };
              setScrollbarsHidden: {
                  params: Emulation.SetScrollbarsHiddenParams;
                  result: Emulation.SetScrollbarsHiddenResult;
              };
              setDocumentCookieDisabled: {
                  params: Emulation.SetDocumentCookieDisabledParams;
                  result: Emulation.SetDocumentCookieDisabledResult;
              };
              setEmitTouchEventsForMouse: {
                  params: Emulation.SetEmitTouchEventsForMouseParams;
                  result: Emulation.SetEmitTouchEventsForMouseResult;
              };
              /**
               * Emulates the given media type or media feature for CSS media queries.
               */
              setEmulatedMedia: {
                  params: Emulation.SetEmulatedMediaParams;
                  result: Emulation.SetEmulatedMediaResult;
              };
              /**
               * Emulates the given vision deficiency.
               */
              setEmulatedVisionDeficiency: {
                  params: Emulation.SetEmulatedVisionDeficiencyParams;
                  result: Emulation.SetEmulatedVisionDeficiencyResult;
              };
              /**
               * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
               * unavailable.
               */
              setGeolocationOverride: {
                  params: Emulation.SetGeolocationOverrideParams;
                  result: Emulation.SetGeolocationOverrideResult;
              };
              getOverriddenSensorInformation: {
                  params: Emulation.GetOverriddenSensorInformationParams;
                  result: Emulation.GetOverriddenSensorInformationResult;
              };
              /**
               * Overrides a platform sensor of a given type. If |enabled| is true, calls to
               * Sensor.start() will use a virtual sensor as backend rather than fetching
               * data from a real hardware sensor. Otherwise, existing virtual
               * sensor-backend Sensor objects will fire an error event and new calls to
               * Sensor.start() will attempt to use a real sensor instead.
               */
              setSensorOverrideEnabled: {
                  params: Emulation.SetSensorOverrideEnabledParams;
                  result: Emulation.SetSensorOverrideEnabledResult;
              };
              /**
               * Updates the sensor readings reported by a sensor type previously overriden
               * by setSensorOverrideEnabled.
               */
              setSensorOverrideReadings: {
                  params: Emulation.SetSensorOverrideReadingsParams;
                  result: Emulation.SetSensorOverrideReadingsResult;
              };
              /**
               * Overrides the Idle state.
               */
              setIdleOverride: {
                  params: Emulation.SetIdleOverrideParams;
                  result: Emulation.SetIdleOverrideResult;
              };
              /**
               * Clears Idle state overrides.
               */
              clearIdleOverride: {
                  params: Emulation.ClearIdleOverrideParams;
                  result: Emulation.ClearIdleOverrideResult;
              };
              /**
               * Overrides value returned by the javascript navigator object.
               * @deprecated
               */
              setNavigatorOverrides: {
                  params: Emulation.SetNavigatorOverridesParams;
                  result: Emulation.SetNavigatorOverridesResult;
              };
              /**
               * Sets a specified page scale factor.
               */
              setPageScaleFactor: {
                  params: Emulation.SetPageScaleFactorParams;
                  result: Emulation.SetPageScaleFactorResult;
              };
              /**
               * Switches script execution in the page.
               */
              setScriptExecutionDisabled: {
                  params: Emulation.SetScriptExecutionDisabledParams;
                  result: Emulation.SetScriptExecutionDisabledResult;
              };
              /**
               * Enables touch on platforms which do not support them.
               */
              setTouchEmulationEnabled: {
                  params: Emulation.SetTouchEmulationEnabledParams;
                  result: Emulation.SetTouchEmulationEnabledResult;
              };
              /**
               * Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
               * the current virtual time policy.  Note this supersedes any previous time budget.
               */
              setVirtualTimePolicy: {
                  params: Emulation.SetVirtualTimePolicyParams;
                  result: Emulation.SetVirtualTimePolicyResult;
              };
              /**
               * Overrides default host system locale with the specified one.
               */
              setLocaleOverride: {
                  params: Emulation.SetLocaleOverrideParams;
                  result: Emulation.SetLocaleOverrideResult;
              };
              /**
               * Overrides default host system timezone with the specified one.
               */
              setTimezoneOverride: {
                  params: Emulation.SetTimezoneOverrideParams;
                  result: Emulation.SetTimezoneOverrideResult;
              };
              /**
               * Resizes the frame/viewport of the page. Note that this does not affect the frame's container
               * (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
               * on Android.
               * @deprecated
               */
              setVisibleSize: {
                  params: Emulation.SetVisibleSizeParams;
                  result: Emulation.SetVisibleSizeResult;
              };
              setDisabledImageTypes: {
                  params: Emulation.SetDisabledImageTypesParams;
                  result: Emulation.SetDisabledImageTypesResult;
              };
              setHardwareConcurrencyOverride: {
                  params: Emulation.SetHardwareConcurrencyOverrideParams;
                  result: Emulation.SetHardwareConcurrencyOverrideResult;
              };
              /**
               * Allows overriding user agent with the given string.
               */
              setUserAgentOverride: {
                  params: Emulation.SetUserAgentOverrideParams;
                  result: Emulation.SetUserAgentOverrideResult;
              };
              /**
               * Allows overriding the automation flag.
               */
              setAutomationOverride: {
                  params: Emulation.SetAutomationOverrideParams;
                  result: Emulation.SetAutomationOverrideResult;
              };
          };
          events: {
              /**
               * Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
               */
              virtualTimeBudgetExpired: {
                  params: Emulation.VirtualTimeBudgetExpiredEvent;
              };
          };
      }
      /**
       * Types of the 'Emulation' domain.
       */
      namespace Emulation {
          /**
           * Parameters of the 'Emulation.canEmulate' method.
           */
          interface CanEmulateParams {
          }
          /**
           * Return value of the 'Emulation.canEmulate' method.
           */
          interface CanEmulateResult {
              /**
               * True if emulation is supported.
               */
              result: boolean;
          }
          /**
           * Parameters of the 'Emulation.clearDeviceMetricsOverride' method.
           */
          interface ClearDeviceMetricsOverrideParams {
          }
          /**
           * Return value of the 'Emulation.clearDeviceMetricsOverride' method.
           */
          interface ClearDeviceMetricsOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.clearGeolocationOverride' method.
           */
          interface ClearGeolocationOverrideParams {
          }
          /**
           * Return value of the 'Emulation.clearGeolocationOverride' method.
           */
          interface ClearGeolocationOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.resetPageScaleFactor' method.
           */
          interface ResetPageScaleFactorParams {
          }
          /**
           * Return value of the 'Emulation.resetPageScaleFactor' method.
           */
          interface ResetPageScaleFactorResult {
          }
          /**
           * Parameters of the 'Emulation.setFocusEmulationEnabled' method.
           */
          interface SetFocusEmulationEnabledParams {
              /**
               * Whether to enable to disable focus emulation.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Emulation.setFocusEmulationEnabled' method.
           */
          interface SetFocusEmulationEnabledResult {
          }
          /**
           * Parameters of the 'Emulation.setAutoDarkModeOverride' method.
           */
          interface SetAutoDarkModeOverrideParams {
              /**
               * Whether to enable or disable automatic dark mode.
               * If not specified, any existing override will be cleared.
               */
              enabled?: boolean;
          }
          /**
           * Return value of the 'Emulation.setAutoDarkModeOverride' method.
           */
          interface SetAutoDarkModeOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setCPUThrottlingRate' method.
           */
          interface SetCPUThrottlingRateParams {
              /**
               * Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
               */
              rate: number;
          }
          /**
           * Return value of the 'Emulation.setCPUThrottlingRate' method.
           */
          interface SetCPUThrottlingRateResult {
          }
          /**
           * Parameters of the 'Emulation.setDefaultBackgroundColorOverride' method.
           */
          interface SetDefaultBackgroundColorOverrideParams {
              /**
               * RGBA of the default background color. If not specified, any existing override will be
               * cleared.
               */
              color?: DOM.RGBA;
          }
          /**
           * Return value of the 'Emulation.setDefaultBackgroundColorOverride' method.
           */
          interface SetDefaultBackgroundColorOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setDeviceMetricsOverride' method.
           */
          interface SetDeviceMetricsOverrideParams {
              /**
               * Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
               */
              width: integer;
              /**
               * Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
               */
              height: integer;
              /**
               * Overriding device scale factor value. 0 disables the override.
               */
              deviceScaleFactor: number;
              /**
               * Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
               * autosizing and more.
               */
              mobile: boolean;
              /**
               * Scale to apply to resulting view image.
               */
              scale?: number;
              /**
               * Overriding screen width value in pixels (minimum 0, maximum 10000000).
               */
              screenWidth?: integer;
              /**
               * Overriding screen height value in pixels (minimum 0, maximum 10000000).
               */
              screenHeight?: integer;
              /**
               * Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
               */
              positionX?: integer;
              /**
               * Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
               */
              positionY?: integer;
              /**
               * Do not set visible view size, rely upon explicit setVisibleSize call.
               */
              dontSetVisibleSize?: boolean;
              /**
               * Screen orientation override.
               */
              screenOrientation?: ScreenOrientation;
              /**
               * If set, the visible area of the page will be overridden to this viewport. This viewport
               * change is not observed by the page, e.g. viewport-relative elements do not change positions.
               */
              viewport?: Page.Viewport;
              /**
               * If set, the display feature of a multi-segment screen. If not set, multi-segment support
               * is turned-off.
               */
              displayFeature?: DisplayFeature;
              /**
               * If set, the posture of a foldable device. If not set the posture is set
               * to continuous.
               */
              devicePosture?: DevicePosture;
          }
          /**
           * Return value of the 'Emulation.setDeviceMetricsOverride' method.
           */
          interface SetDeviceMetricsOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setScrollbarsHidden' method.
           */
          interface SetScrollbarsHiddenParams {
              /**
               * Whether scrollbars should be always hidden.
               */
              hidden: boolean;
          }
          /**
           * Return value of the 'Emulation.setScrollbarsHidden' method.
           */
          interface SetScrollbarsHiddenResult {
          }
          /**
           * Parameters of the 'Emulation.setDocumentCookieDisabled' method.
           */
          interface SetDocumentCookieDisabledParams {
              /**
               * Whether document.coookie API should be disabled.
               */
              disabled: boolean;
          }
          /**
           * Return value of the 'Emulation.setDocumentCookieDisabled' method.
           */
          interface SetDocumentCookieDisabledResult {
          }
          /**
           * Parameters of the 'Emulation.setEmitTouchEventsForMouse' method.
           */
          interface SetEmitTouchEventsForMouseParams {
              /**
               * Whether touch emulation based on mouse input should be enabled.
               */
              enabled: boolean;
              /**
               * Touch/gesture events configuration. Default: current platform.
               */
              configuration?: 'mobile' | 'desktop';
          }
          /**
           * Return value of the 'Emulation.setEmitTouchEventsForMouse' method.
           */
          interface SetEmitTouchEventsForMouseResult {
          }
          /**
           * Parameters of the 'Emulation.setEmulatedMedia' method.
           */
          interface SetEmulatedMediaParams {
              /**
               * Media type to emulate. Empty string disables the override.
               */
              media?: string;
              /**
               * Media features to emulate.
               */
              features?: MediaFeature[];
          }
          /**
           * Return value of the 'Emulation.setEmulatedMedia' method.
           */
          interface SetEmulatedMediaResult {
          }
          /**
           * Parameters of the 'Emulation.setEmulatedVisionDeficiency' method.
           */
          interface SetEmulatedVisionDeficiencyParams {
              /**
               * Vision deficiency to emulate. Order: best-effort emulations come first, followed by any
               * physiologically accurate emulations for medically recognized color vision deficiencies.
               */
              type: 'none' | 'blurredVision' | 'reducedContrast' | 'achromatopsia' | 'deuteranopia' | 'protanopia' | 'tritanopia';
          }
          /**
           * Return value of the 'Emulation.setEmulatedVisionDeficiency' method.
           */
          interface SetEmulatedVisionDeficiencyResult {
          }
          /**
           * Parameters of the 'Emulation.setGeolocationOverride' method.
           */
          interface SetGeolocationOverrideParams {
              /**
               * Mock latitude
               */
              latitude?: number;
              /**
               * Mock longitude
               */
              longitude?: number;
              /**
               * Mock accuracy
               */
              accuracy?: number;
          }
          /**
           * Return value of the 'Emulation.setGeolocationOverride' method.
           */
          interface SetGeolocationOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.getOverriddenSensorInformation' method.
           */
          interface GetOverriddenSensorInformationParams {
              type: SensorType;
          }
          /**
           * Return value of the 'Emulation.getOverriddenSensorInformation' method.
           */
          interface GetOverriddenSensorInformationResult {
              requestedSamplingFrequency: number;
          }
          /**
           * Parameters of the 'Emulation.setSensorOverrideEnabled' method.
           */
          interface SetSensorOverrideEnabledParams {
              enabled: boolean;
              type: SensorType;
              metadata?: SensorMetadata;
          }
          /**
           * Return value of the 'Emulation.setSensorOverrideEnabled' method.
           */
          interface SetSensorOverrideEnabledResult {
          }
          /**
           * Parameters of the 'Emulation.setSensorOverrideReadings' method.
           */
          interface SetSensorOverrideReadingsParams {
              type: SensorType;
              reading: SensorReading;
          }
          /**
           * Return value of the 'Emulation.setSensorOverrideReadings' method.
           */
          interface SetSensorOverrideReadingsResult {
          }
          /**
           * Parameters of the 'Emulation.setIdleOverride' method.
           */
          interface SetIdleOverrideParams {
              /**
               * Mock isUserActive
               */
              isUserActive: boolean;
              /**
               * Mock isScreenUnlocked
               */
              isScreenUnlocked: boolean;
          }
          /**
           * Return value of the 'Emulation.setIdleOverride' method.
           */
          interface SetIdleOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.clearIdleOverride' method.
           */
          interface ClearIdleOverrideParams {
          }
          /**
           * Return value of the 'Emulation.clearIdleOverride' method.
           */
          interface ClearIdleOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setNavigatorOverrides' method.
           */
          interface SetNavigatorOverridesParams {
              /**
               * The platform navigator.platform should return.
               */
              platform: string;
          }
          /**
           * Return value of the 'Emulation.setNavigatorOverrides' method.
           */
          interface SetNavigatorOverridesResult {
          }
          /**
           * Parameters of the 'Emulation.setPageScaleFactor' method.
           */
          interface SetPageScaleFactorParams {
              /**
               * Page scale factor.
               */
              pageScaleFactor: number;
          }
          /**
           * Return value of the 'Emulation.setPageScaleFactor' method.
           */
          interface SetPageScaleFactorResult {
          }
          /**
           * Parameters of the 'Emulation.setScriptExecutionDisabled' method.
           */
          interface SetScriptExecutionDisabledParams {
              /**
               * Whether script execution should be disabled in the page.
               */
              value: boolean;
          }
          /**
           * Return value of the 'Emulation.setScriptExecutionDisabled' method.
           */
          interface SetScriptExecutionDisabledResult {
          }
          /**
           * Parameters of the 'Emulation.setTouchEmulationEnabled' method.
           */
          interface SetTouchEmulationEnabledParams {
              /**
               * Whether the touch event emulation should be enabled.
               */
              enabled: boolean;
              /**
               * Maximum touch points supported. Defaults to one.
               */
              maxTouchPoints?: integer;
          }
          /**
           * Return value of the 'Emulation.setTouchEmulationEnabled' method.
           */
          interface SetTouchEmulationEnabledResult {
          }
          /**
           * Parameters of the 'Emulation.setVirtualTimePolicy' method.
           */
          interface SetVirtualTimePolicyParams {
              policy: VirtualTimePolicy;
              /**
               * If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
               * virtualTimeBudgetExpired event is sent.
               */
              budget?: number;
              /**
               * If set this specifies the maximum number of tasks that can be run before virtual is forced
               * forwards to prevent deadlock.
               */
              maxVirtualTimeTaskStarvationCount?: integer;
              /**
               * If set, base::Time::Now will be overridden to initially return this value.
               */
              initialVirtualTime?: Network.TimeSinceEpoch;
          }
          /**
           * Return value of the 'Emulation.setVirtualTimePolicy' method.
           */
          interface SetVirtualTimePolicyResult {
              /**
               * Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
               */
              virtualTimeTicksBase: number;
          }
          /**
           * Parameters of the 'Emulation.setLocaleOverride' method.
           */
          interface SetLocaleOverrideParams {
              /**
               * ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and
               * restores default host system locale.
               */
              locale?: string;
          }
          /**
           * Return value of the 'Emulation.setLocaleOverride' method.
           */
          interface SetLocaleOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setTimezoneOverride' method.
           */
          interface SetTimezoneOverrideParams {
              /**
               * The timezone identifier. If empty, disables the override and
               * restores default host system timezone.
               */
              timezoneId: string;
          }
          /**
           * Return value of the 'Emulation.setTimezoneOverride' method.
           */
          interface SetTimezoneOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setVisibleSize' method.
           */
          interface SetVisibleSizeParams {
              /**
               * Frame width (DIP).
               */
              width: integer;
              /**
               * Frame height (DIP).
               */
              height: integer;
          }
          /**
           * Return value of the 'Emulation.setVisibleSize' method.
           */
          interface SetVisibleSizeResult {
          }
          /**
           * Parameters of the 'Emulation.setDisabledImageTypes' method.
           */
          interface SetDisabledImageTypesParams {
              /**
               * Image types to disable.
               */
              imageTypes: DisabledImageType[];
          }
          /**
           * Return value of the 'Emulation.setDisabledImageTypes' method.
           */
          interface SetDisabledImageTypesResult {
          }
          /**
           * Parameters of the 'Emulation.setHardwareConcurrencyOverride' method.
           */
          interface SetHardwareConcurrencyOverrideParams {
              /**
               * Hardware concurrency to report
               */
              hardwareConcurrency: integer;
          }
          /**
           * Return value of the 'Emulation.setHardwareConcurrencyOverride' method.
           */
          interface SetHardwareConcurrencyOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setUserAgentOverride' method.
           */
          interface SetUserAgentOverrideParams {
              /**
               * User agent to use.
               */
              userAgent: string;
              /**
               * Browser language to emulate.
               */
              acceptLanguage?: string;
              /**
               * The platform navigator.platform should return.
               */
              platform?: string;
              /**
               * To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
               */
              userAgentMetadata?: UserAgentMetadata;
          }
          /**
           * Return value of the 'Emulation.setUserAgentOverride' method.
           */
          interface SetUserAgentOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.setAutomationOverride' method.
           */
          interface SetAutomationOverrideParams {
              /**
               * Whether the override should be enabled.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Emulation.setAutomationOverride' method.
           */
          interface SetAutomationOverrideResult {
          }
          /**
           * Parameters of the 'Emulation.virtualTimeBudgetExpired' event.
           */
          interface VirtualTimeBudgetExpiredEvent {
          }
          /**
           * Screen orientation.
           */
          interface ScreenOrientation {
              /**
               * Orientation type.
               */
              type: 'portraitPrimary' | 'portraitSecondary' | 'landscapePrimary' | 'landscapeSecondary';
              /**
               * Orientation angle.
               */
              angle: integer;
          }
          interface DisplayFeature {
              /**
               * Orientation of a display feature in relation to screen
               */
              orientation: 'vertical' | 'horizontal';
              /**
               * The offset from the screen origin in either the x (for vertical
               * orientation) or y (for horizontal orientation) direction.
               */
              offset: integer;
              /**
               * A display feature may mask content such that it is not physically
               * displayed - this length along with the offset describes this area.
               * A display feature that only splits content will have a 0 mask_length.
               */
              maskLength: integer;
          }
          interface DevicePosture {
              /**
               * Current posture of the device
               */
              type: 'continuous' | 'folded';
          }
          interface MediaFeature {
              name: string;
              value: string;
          }
          /**
           * advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
           * allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
           * pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
           * resource fetches.
           */
          type VirtualTimePolicy = 'advance' | 'pause' | 'pauseIfNetworkFetchesPending';
          /**
           * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
           */
          interface UserAgentBrandVersion {
              brand: string;
              version: string;
          }
          /**
           * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
           * Missing optional values will be filled in by the target with what it would normally use.
           */
          interface UserAgentMetadata {
              /**
               * Brands appearing in Sec-CH-UA.
               */
              brands?: UserAgentBrandVersion[];
              /**
               * Brands appearing in Sec-CH-UA-Full-Version-List.
               */
              fullVersionList?: UserAgentBrandVersion[];
              /**
               *
               * @deprecated
               */
              fullVersion?: string;
              platform: string;
              platformVersion: string;
              architecture: string;
              model: string;
              mobile: boolean;
              bitness?: string;
              wow64?: boolean;
          }
          /**
           * Used to specify sensor types to emulate.
           * See https://w3c.github.io/sensors/#automation for more information.
           */
          type SensorType = 'absolute-orientation' | 'accelerometer' | 'ambient-light' | 'gravity' | 'gyroscope' | 'linear-acceleration' | 'magnetometer' | 'proximity' | 'relative-orientation';
          interface SensorMetadata {
              available?: boolean;
              minimumFrequency?: number;
              maximumFrequency?: number;
          }
          interface SensorReadingSingle {
              value: number;
          }
          interface SensorReadingXYZ {
              x: number;
              y: number;
              z: number;
          }
          interface SensorReadingQuaternion {
              x: number;
              y: number;
              z: number;
              w: number;
          }
          interface SensorReading {
              single?: SensorReadingSingle;
              xyz?: SensorReadingXYZ;
              quaternion?: SensorReadingQuaternion;
          }
          /**
           * Enum of image types that can be disabled.
           */
          type DisabledImageType = 'avif' | 'webp';
      }
      /**
       * Methods and events of the 'HeadlessExperimental' domain.
       */
      interface HeadlessExperimentalApi {
          requests: {
              /**
               * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
               * screenshot from the resulting frame. Requires that the target was created with enabled
               * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
               * https://goo.gle/chrome-headless-rendering for more background.
               */
              beginFrame: {
                  params: HeadlessExperimental.BeginFrameParams;
                  result: HeadlessExperimental.BeginFrameResult;
              };
              /**
               * Disables headless events for the target.
               * @deprecated
               */
              disable: {
                  params: HeadlessExperimental.DisableParams;
                  result: HeadlessExperimental.DisableResult;
              };
              /**
               * Enables headless events for the target.
               * @deprecated
               */
              enable: {
                  params: HeadlessExperimental.EnableParams;
                  result: HeadlessExperimental.EnableResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'HeadlessExperimental' domain.
       */
      namespace HeadlessExperimental {
          /**
           * Parameters of the 'HeadlessExperimental.beginFrame' method.
           */
          interface BeginFrameParams {
              /**
               * Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
               * the current time will be used.
               */
              frameTimeTicks?: number;
              /**
               * The interval between BeginFrames that is reported to the compositor, in milliseconds.
               * Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
               */
              interval?: number;
              /**
               * Whether updates should not be committed and drawn onto the display. False by default. If
               * true, only side effects of the BeginFrame will be run, such as layout and animations, but
               * any visual updates may not be visible on the display or in screenshots.
               */
              noDisplayUpdates?: boolean;
              /**
               * If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
               * no screenshot will be captured. Note that capturing a screenshot can fail, for example,
               * during renderer initialization. In such a case, no screenshot data will be returned.
               */
              screenshot?: ScreenshotParams;
          }
          /**
           * Return value of the 'HeadlessExperimental.beginFrame' method.
           */
          interface BeginFrameResult {
              /**
               * Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
               * display. Reported for diagnostic uses, may be removed in the future.
               */
              hasDamage: boolean;
              /**
               * Base64-encoded image data of the screenshot, if one was requested and successfully taken. (Encoded as a base64 string when passed over JSON)
               */
              screenshotData?: string;
          }
          /**
           * Parameters of the 'HeadlessExperimental.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'HeadlessExperimental.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'HeadlessExperimental.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'HeadlessExperimental.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Encoding options for a screenshot.
           */
          interface ScreenshotParams {
              /**
               * Image compression format (defaults to png).
               */
              format?: 'jpeg' | 'png' | 'webp';
              /**
               * Compression quality from range [0..100] (jpeg and webp only).
               */
              quality?: integer;
              /**
               * Optimize image encoding for speed, not for resulting size (defaults to false)
               */
              optimizeForSpeed?: boolean;
          }
      }
      /**
       * Methods and events of the 'IO' domain.
       */
      interface IOApi {
          requests: {
              /**
               * Close the stream, discard any temporary backing storage.
               */
              close: {
                  params: IO.CloseParams;
                  result: IO.CloseResult;
              };
              /**
               * Read a chunk of the stream
               */
              read: {
                  params: IO.ReadParams;
                  result: IO.ReadResult;
              };
              /**
               * Return UUID of Blob object specified by a remote object id.
               */
              resolveBlob: {
                  params: IO.ResolveBlobParams;
                  result: IO.ResolveBlobResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'IO' domain.
       */
      namespace IO {
          /**
           * Parameters of the 'IO.close' method.
           */
          interface CloseParams {
              /**
               * Handle of the stream to close.
               */
              handle: StreamHandle;
          }
          /**
           * Return value of the 'IO.close' method.
           */
          interface CloseResult {
          }
          /**
           * Parameters of the 'IO.read' method.
           */
          interface ReadParams {
              /**
               * Handle of the stream to read.
               */
              handle: StreamHandle;
              /**
               * Seek to the specified offset before reading (if not specificed, proceed with offset
               * following the last read). Some types of streams may only support sequential reads.
               */
              offset?: integer;
              /**
               * Maximum number of bytes to read (left upon the agent discretion if not specified).
               */
              size?: integer;
          }
          /**
           * Return value of the 'IO.read' method.
           */
          interface ReadResult {
              /**
               * Set if the data is base64-encoded
               */
              base64Encoded?: boolean;
              /**
               * Data that were read.
               */
              data: string;
              /**
               * Set if the end-of-file condition occurred while reading.
               */
              eof: boolean;
          }
          /**
           * Parameters of the 'IO.resolveBlob' method.
           */
          interface ResolveBlobParams {
              /**
               * Object id of a Blob object wrapper.
               */
              objectId: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'IO.resolveBlob' method.
           */
          interface ResolveBlobResult {
              /**
               * UUID of the specified Blob.
               */
              uuid: string;
          }
          /**
           * This is either obtained from another method or specified as `blob:<uuid>` where
           * `<uuid>` is an UUID of a Blob.
           */
          type StreamHandle = string;
      }
      /**
       * Methods and events of the 'IndexedDB' domain.
       */
      interface IndexedDBApi {
          requests: {
              /**
               * Clears all entries from an object store.
               */
              clearObjectStore: {
                  params: IndexedDB.ClearObjectStoreParams;
                  result: IndexedDB.ClearObjectStoreResult;
              };
              /**
               * Deletes a database.
               */
              deleteDatabase: {
                  params: IndexedDB.DeleteDatabaseParams;
                  result: IndexedDB.DeleteDatabaseResult;
              };
              /**
               * Delete a range of entries from an object store
               */
              deleteObjectStoreEntries: {
                  params: IndexedDB.DeleteObjectStoreEntriesParams;
                  result: IndexedDB.DeleteObjectStoreEntriesResult;
              };
              /**
               * Disables events from backend.
               */
              disable: {
                  params: IndexedDB.DisableParams;
                  result: IndexedDB.DisableResult;
              };
              /**
               * Enables events from backend.
               */
              enable: {
                  params: IndexedDB.EnableParams;
                  result: IndexedDB.EnableResult;
              };
              /**
               * Requests data from object store or index.
               */
              requestData: {
                  params: IndexedDB.RequestDataParams;
                  result: IndexedDB.RequestDataResult;
              };
              /**
               * Gets metadata of an object store.
               */
              getMetadata: {
                  params: IndexedDB.GetMetadataParams;
                  result: IndexedDB.GetMetadataResult;
              };
              /**
               * Requests database with given name in given frame.
               */
              requestDatabase: {
                  params: IndexedDB.RequestDatabaseParams;
                  result: IndexedDB.RequestDatabaseResult;
              };
              /**
               * Requests database names for given security origin.
               */
              requestDatabaseNames: {
                  params: IndexedDB.RequestDatabaseNamesParams;
                  result: IndexedDB.RequestDatabaseNamesResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'IndexedDB' domain.
       */
      namespace IndexedDB {
          /**
           * Parameters of the 'IndexedDB.clearObjectStore' method.
           */
          interface ClearObjectStoreParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * Database name.
               */
              databaseName: string;
              /**
               * Object store name.
               */
              objectStoreName: string;
          }
          /**
           * Return value of the 'IndexedDB.clearObjectStore' method.
           */
          interface ClearObjectStoreResult {
          }
          /**
           * Parameters of the 'IndexedDB.deleteDatabase' method.
           */
          interface DeleteDatabaseParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * Database name.
               */
              databaseName: string;
          }
          /**
           * Return value of the 'IndexedDB.deleteDatabase' method.
           */
          interface DeleteDatabaseResult {
          }
          /**
           * Parameters of the 'IndexedDB.deleteObjectStoreEntries' method.
           */
          interface DeleteObjectStoreEntriesParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              databaseName: string;
              objectStoreName: string;
              /**
               * Range of entry keys to delete
               */
              keyRange: KeyRange;
          }
          /**
           * Return value of the 'IndexedDB.deleteObjectStoreEntries' method.
           */
          interface DeleteObjectStoreEntriesResult {
          }
          /**
           * Parameters of the 'IndexedDB.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'IndexedDB.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'IndexedDB.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'IndexedDB.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'IndexedDB.requestData' method.
           */
          interface RequestDataParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * Database name.
               */
              databaseName: string;
              /**
               * Object store name.
               */
              objectStoreName: string;
              /**
               * Index name, empty string for object store data requests.
               */
              indexName: string;
              /**
               * Number of records to skip.
               */
              skipCount: integer;
              /**
               * Number of records to fetch.
               */
              pageSize: integer;
              /**
               * Key range.
               */
              keyRange?: KeyRange;
          }
          /**
           * Return value of the 'IndexedDB.requestData' method.
           */
          interface RequestDataResult {
              /**
               * Array of object store data entries.
               */
              objectStoreDataEntries: DataEntry[];
              /**
               * If true, there are more entries to fetch in the given range.
               */
              hasMore: boolean;
          }
          /**
           * Parameters of the 'IndexedDB.getMetadata' method.
           */
          interface GetMetadataParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * Database name.
               */
              databaseName: string;
              /**
               * Object store name.
               */
              objectStoreName: string;
          }
          /**
           * Return value of the 'IndexedDB.getMetadata' method.
           */
          interface GetMetadataResult {
              /**
               * the entries count
               */
              entriesCount: number;
              /**
               * the current value of key generator, to become the next inserted
               * key into the object store. Valid if objectStore.autoIncrement
               * is true.
               */
              keyGeneratorValue: number;
          }
          /**
           * Parameters of the 'IndexedDB.requestDatabase' method.
           */
          interface RequestDatabaseParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
              /**
               * Database name.
               */
              databaseName: string;
          }
          /**
           * Return value of the 'IndexedDB.requestDatabase' method.
           */
          interface RequestDatabaseResult {
              /**
               * Database with an array of object stores.
               */
              databaseWithObjectStores: DatabaseWithObjectStores;
          }
          /**
           * Parameters of the 'IndexedDB.requestDatabaseNames' method.
           */
          interface RequestDatabaseNamesParams {
              /**
               * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
               * Security origin.
               */
              securityOrigin?: string;
              /**
               * Storage key.
               */
              storageKey?: string;
              /**
               * Storage bucket. If not specified, it uses the default bucket.
               */
              storageBucket?: Storage.StorageBucket;
          }
          /**
           * Return value of the 'IndexedDB.requestDatabaseNames' method.
           */
          interface RequestDatabaseNamesResult {
              /**
               * Database names for origin.
               */
              databaseNames: string[];
          }
          /**
           * Database with an array of object stores.
           */
          interface DatabaseWithObjectStores {
              /**
               * Database name.
               */
              name: string;
              /**
               * Database version (type is not 'integer', as the standard
               * requires the version number to be 'unsigned long long')
               */
              version: number;
              /**
               * Object stores in this database.
               */
              objectStores: ObjectStore[];
          }
          /**
           * Object store.
           */
          interface ObjectStore {
              /**
               * Object store name.
               */
              name: string;
              /**
               * Object store key path.
               */
              keyPath: KeyPath;
              /**
               * If true, object store has auto increment flag set.
               */
              autoIncrement: boolean;
              /**
               * Indexes in this object store.
               */
              indexes: ObjectStoreIndex[];
          }
          /**
           * Object store index.
           */
          interface ObjectStoreIndex {
              /**
               * Index name.
               */
              name: string;
              /**
               * Index key path.
               */
              keyPath: KeyPath;
              /**
               * If true, index is unique.
               */
              unique: boolean;
              /**
               * If true, index allows multiple entries for a key.
               */
              multiEntry: boolean;
          }
          /**
           * Key.
           */
          interface Key {
              /**
               * Key type.
               */
              type: 'number' | 'string' | 'date' | 'array';
              /**
               * Number value.
               */
              number?: number;
              /**
               * String value.
               */
              string?: string;
              /**
               * Date value.
               */
              date?: number;
              /**
               * Array value.
               */
              array?: Key[];
          }
          /**
           * Key range.
           */
          interface KeyRange {
              /**
               * Lower bound.
               */
              lower?: Key;
              /**
               * Upper bound.
               */
              upper?: Key;
              /**
               * If true lower bound is open.
               */
              lowerOpen: boolean;
              /**
               * If true upper bound is open.
               */
              upperOpen: boolean;
          }
          /**
           * Data entry.
           */
          interface DataEntry {
              /**
               * Key object.
               */
              key: CdpV8.Runtime.RemoteObject;
              /**
               * Primary key object.
               */
              primaryKey: CdpV8.Runtime.RemoteObject;
              /**
               * Value object.
               */
              value: CdpV8.Runtime.RemoteObject;
          }
          /**
           * Key path.
           */
          interface KeyPath {
              /**
               * Key path type.
               */
              type: 'null' | 'string' | 'array';
              /**
               * String value.
               */
              string?: string;
              /**
               * Array value.
               */
              array?: string[];
          }
      }
      /**
       * Methods and events of the 'Input' domain.
       */
      interface InputApi {
          requests: {
              /**
               * Dispatches a drag event into the page.
               */
              dispatchDragEvent: {
                  params: Input.DispatchDragEventParams;
                  result: Input.DispatchDragEventResult;
              };
              /**
               * Dispatches a key event to the page.
               */
              dispatchKeyEvent: {
                  params: Input.DispatchKeyEventParams;
                  result: Input.DispatchKeyEventResult;
              };
              /**
               * This method emulates inserting text that doesn't come from a key press,
               * for example an emoji keyboard or an IME.
               */
              insertText: {
                  params: Input.InsertTextParams;
                  result: Input.InsertTextResult;
              };
              /**
               * This method sets the current candidate text for ime.
               * Use imeCommitComposition to commit the final text.
               * Use imeSetComposition with empty string as text to cancel composition.
               */
              imeSetComposition: {
                  params: Input.ImeSetCompositionParams;
                  result: Input.ImeSetCompositionResult;
              };
              /**
               * Dispatches a mouse event to the page.
               */
              dispatchMouseEvent: {
                  params: Input.DispatchMouseEventParams;
                  result: Input.DispatchMouseEventResult;
              };
              /**
               * Dispatches a touch event to the page.
               */
              dispatchTouchEvent: {
                  params: Input.DispatchTouchEventParams;
                  result: Input.DispatchTouchEventResult;
              };
              /**
               * Cancels any active dragging in the page.
               */
              cancelDragging: {
                  params: Input.CancelDraggingParams;
                  result: Input.CancelDraggingResult;
              };
              /**
               * Emulates touch event from the mouse event parameters.
               */
              emulateTouchFromMouseEvent: {
                  params: Input.EmulateTouchFromMouseEventParams;
                  result: Input.EmulateTouchFromMouseEventResult;
              };
              /**
               * Ignores input events (useful while auditing page).
               */
              setIgnoreInputEvents: {
                  params: Input.SetIgnoreInputEventsParams;
                  result: Input.SetIgnoreInputEventsResult;
              };
              /**
               * Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
               * Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
               */
              setInterceptDrags: {
                  params: Input.SetInterceptDragsParams;
                  result: Input.SetInterceptDragsResult;
              };
              /**
               * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
               */
              synthesizePinchGesture: {
                  params: Input.SynthesizePinchGestureParams;
                  result: Input.SynthesizePinchGestureResult;
              };
              /**
               * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
               */
              synthesizeScrollGesture: {
                  params: Input.SynthesizeScrollGestureParams;
                  result: Input.SynthesizeScrollGestureResult;
              };
              /**
               * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
               */
              synthesizeTapGesture: {
                  params: Input.SynthesizeTapGestureParams;
                  result: Input.SynthesizeTapGestureResult;
              };
          };
          events: {
              /**
               * Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
               * restore normal drag and drop behavior.
               */
              dragIntercepted: {
                  params: Input.DragInterceptedEvent;
              };
          };
      }
      /**
       * Types of the 'Input' domain.
       */
      namespace Input {
          /**
           * Parameters of the 'Input.dispatchDragEvent' method.
           */
          interface DispatchDragEventParams {
              /**
               * Type of the drag event.
               */
              type: 'dragEnter' | 'dragOver' | 'drop' | 'dragCancel';
              /**
               * X coordinate of the event relative to the main frame's viewport in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
               * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
               */
              y: number;
              data: DragData;
              /**
               * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
               * (default: 0).
               */
              modifiers?: integer;
          }
          /**
           * Return value of the 'Input.dispatchDragEvent' method.
           */
          interface DispatchDragEventResult {
          }
          /**
           * Parameters of the 'Input.dispatchKeyEvent' method.
           */
          interface DispatchKeyEventParams {
              /**
               * Type of the key event.
               */
              type: 'keyDown' | 'keyUp' | 'rawKeyDown' | 'char';
              /**
               * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
               * (default: 0).
               */
              modifiers?: integer;
              /**
               * Time at which the event occurred.
               */
              timestamp?: TimeSinceEpoch;
              /**
               * Text as generated by processing a virtual key code with a keyboard layout. Not needed for
               * for `keyUp` and `rawKeyDown` events (default: "")
               */
              text?: string;
              /**
               * Text that would have been generated by the keyboard if no modifiers were pressed (except for
               * shift). Useful for shortcut (accelerator) key handling (default: "").
               */
              unmodifiedText?: string;
              /**
               * Unique key identifier (e.g., 'U+0041') (default: "").
               */
              keyIdentifier?: string;
              /**
               * Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
               */
              code?: string;
              /**
               * Unique DOM defined string value describing the meaning of the key in the context of active
               * modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
               */
              key?: string;
              /**
               * Windows virtual key code (default: 0).
               */
              windowsVirtualKeyCode?: integer;
              /**
               * Native virtual key code (default: 0).
               */
              nativeVirtualKeyCode?: integer;
              /**
               * Whether the event was generated from auto repeat (default: false).
               */
              autoRepeat?: boolean;
              /**
               * Whether the event was generated from the keypad (default: false).
               */
              isKeypad?: boolean;
              /**
               * Whether the event was a system key event (default: false).
               */
              isSystemKey?: boolean;
              /**
               * Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
               * 0).
               */
              location?: integer;
              /**
               * Editing commands to send with the key event (e.g., 'selectAll') (default: []).
               * These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
               * See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
               */
              commands?: string[];
          }
          /**
           * Return value of the 'Input.dispatchKeyEvent' method.
           */
          interface DispatchKeyEventResult {
          }
          /**
           * Parameters of the 'Input.insertText' method.
           */
          interface InsertTextParams {
              /**
               * The text to insert.
               */
              text: string;
          }
          /**
           * Return value of the 'Input.insertText' method.
           */
          interface InsertTextResult {
          }
          /**
           * Parameters of the 'Input.imeSetComposition' method.
           */
          interface ImeSetCompositionParams {
              /**
               * The text to insert
               */
              text: string;
              /**
               * selection start
               */
              selectionStart: integer;
              /**
               * selection end
               */
              selectionEnd: integer;
              /**
               * replacement start
               */
              replacementStart?: integer;
              /**
               * replacement end
               */
              replacementEnd?: integer;
          }
          /**
           * Return value of the 'Input.imeSetComposition' method.
           */
          interface ImeSetCompositionResult {
          }
          /**
           * Parameters of the 'Input.dispatchMouseEvent' method.
           */
          interface DispatchMouseEventParams {
              /**
               * Type of the mouse event.
               */
              type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';
              /**
               * X coordinate of the event relative to the main frame's viewport in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
               * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
               */
              y: number;
              /**
               * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
               * (default: 0).
               */
              modifiers?: integer;
              /**
               * Time at which the event occurred.
               */
              timestamp?: TimeSinceEpoch;
              /**
               * Mouse button (default: "none").
               */
              button?: MouseButton;
              /**
               * A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
               * Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
               */
              buttons?: integer;
              /**
               * Number of times the mouse button was clicked (default: 0).
               */
              clickCount?: integer;
              /**
               * The normalized pressure, which has a range of [0,1] (default: 0).
               */
              force?: number;
              /**
               * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
               */
              tangentialPressure?: number;
              /**
               * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
               */
              tiltX?: number;
              /**
               * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
               */
              tiltY?: number;
              /**
               * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
               */
              twist?: integer;
              /**
               * X delta in CSS pixels for mouse wheel event (default: 0).
               */
              deltaX?: number;
              /**
               * Y delta in CSS pixels for mouse wheel event (default: 0).
               */
              deltaY?: number;
              /**
               * Pointer type (default: "mouse").
               */
              pointerType?: 'mouse' | 'pen';
          }
          /**
           * Return value of the 'Input.dispatchMouseEvent' method.
           */
          interface DispatchMouseEventResult {
          }
          /**
           * Parameters of the 'Input.dispatchTouchEvent' method.
           */
          interface DispatchTouchEventParams {
              /**
               * Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
               * TouchStart and TouchMove must contains at least one.
               */
              type: 'touchStart' | 'touchEnd' | 'touchMove' | 'touchCancel';
              /**
               * Active touch points on the touch device. One event per any changed point (compared to
               * previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
               * one by one.
               */
              touchPoints: TouchPoint[];
              /**
               * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
               * (default: 0).
               */
              modifiers?: integer;
              /**
               * Time at which the event occurred.
               */
              timestamp?: TimeSinceEpoch;
          }
          /**
           * Return value of the 'Input.dispatchTouchEvent' method.
           */
          interface DispatchTouchEventResult {
          }
          /**
           * Parameters of the 'Input.cancelDragging' method.
           */
          interface CancelDraggingParams {
          }
          /**
           * Return value of the 'Input.cancelDragging' method.
           */
          interface CancelDraggingResult {
          }
          /**
           * Parameters of the 'Input.emulateTouchFromMouseEvent' method.
           */
          interface EmulateTouchFromMouseEventParams {
              /**
               * Type of the mouse event.
               */
              type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';
              /**
               * X coordinate of the mouse pointer in DIP.
               */
              x: integer;
              /**
               * Y coordinate of the mouse pointer in DIP.
               */
              y: integer;
              /**
               * Mouse button. Only "none", "left", "right" are supported.
               */
              button: MouseButton;
              /**
               * Time at which the event occurred (default: current time).
               */
              timestamp?: TimeSinceEpoch;
              /**
               * X delta in DIP for mouse wheel event (default: 0).
               */
              deltaX?: number;
              /**
               * Y delta in DIP for mouse wheel event (default: 0).
               */
              deltaY?: number;
              /**
               * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
               * (default: 0).
               */
              modifiers?: integer;
              /**
               * Number of times the mouse button was clicked (default: 0).
               */
              clickCount?: integer;
          }
          /**
           * Return value of the 'Input.emulateTouchFromMouseEvent' method.
           */
          interface EmulateTouchFromMouseEventResult {
          }
          /**
           * Parameters of the 'Input.setIgnoreInputEvents' method.
           */
          interface SetIgnoreInputEventsParams {
              /**
               * Ignores input events processing when set to true.
               */
              ignore: boolean;
          }
          /**
           * Return value of the 'Input.setIgnoreInputEvents' method.
           */
          interface SetIgnoreInputEventsResult {
          }
          /**
           * Parameters of the 'Input.setInterceptDrags' method.
           */
          interface SetInterceptDragsParams {
              enabled: boolean;
          }
          /**
           * Return value of the 'Input.setInterceptDrags' method.
           */
          interface SetInterceptDragsResult {
          }
          /**
           * Parameters of the 'Input.synthesizePinchGesture' method.
           */
          interface SynthesizePinchGestureParams {
              /**
               * X coordinate of the start of the gesture in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the start of the gesture in CSS pixels.
               */
              y: number;
              /**
               * Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
               */
              scaleFactor: number;
              /**
               * Relative pointer speed in pixels per second (default: 800).
               */
              relativeSpeed?: integer;
              /**
               * Which type of input events to be generated (default: 'default', which queries the platform
               * for the preferred input type).
               */
              gestureSourceType?: GestureSourceType;
          }
          /**
           * Return value of the 'Input.synthesizePinchGesture' method.
           */
          interface SynthesizePinchGestureResult {
          }
          /**
           * Parameters of the 'Input.synthesizeScrollGesture' method.
           */
          interface SynthesizeScrollGestureParams {
              /**
               * X coordinate of the start of the gesture in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the start of the gesture in CSS pixels.
               */
              y: number;
              /**
               * The distance to scroll along the X axis (positive to scroll left).
               */
              xDistance?: number;
              /**
               * The distance to scroll along the Y axis (positive to scroll up).
               */
              yDistance?: number;
              /**
               * The number of additional pixels to scroll back along the X axis, in addition to the given
               * distance.
               */
              xOverscroll?: number;
              /**
               * The number of additional pixels to scroll back along the Y axis, in addition to the given
               * distance.
               */
              yOverscroll?: number;
              /**
               * Prevent fling (default: true).
               */
              preventFling?: boolean;
              /**
               * Swipe speed in pixels per second (default: 800).
               */
              speed?: integer;
              /**
               * Which type of input events to be generated (default: 'default', which queries the platform
               * for the preferred input type).
               */
              gestureSourceType?: GestureSourceType;
              /**
               * The number of times to repeat the gesture (default: 0).
               */
              repeatCount?: integer;
              /**
               * The number of milliseconds delay between each repeat. (default: 250).
               */
              repeatDelayMs?: integer;
              /**
               * The name of the interaction markers to generate, if not empty (default: "").
               */
              interactionMarkerName?: string;
          }
          /**
           * Return value of the 'Input.synthesizeScrollGesture' method.
           */
          interface SynthesizeScrollGestureResult {
          }
          /**
           * Parameters of the 'Input.synthesizeTapGesture' method.
           */
          interface SynthesizeTapGestureParams {
              /**
               * X coordinate of the start of the gesture in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the start of the gesture in CSS pixels.
               */
              y: number;
              /**
               * Duration between touchdown and touchup events in ms (default: 50).
               */
              duration?: integer;
              /**
               * Number of times to perform the tap (e.g. 2 for double tap, default: 1).
               */
              tapCount?: integer;
              /**
               * Which type of input events to be generated (default: 'default', which queries the platform
               * for the preferred input type).
               */
              gestureSourceType?: GestureSourceType;
          }
          /**
           * Return value of the 'Input.synthesizeTapGesture' method.
           */
          interface SynthesizeTapGestureResult {
          }
          /**
           * Parameters of the 'Input.dragIntercepted' event.
           */
          interface DragInterceptedEvent {
              data: DragData;
          }
          interface TouchPoint {
              /**
               * X coordinate of the event relative to the main frame's viewport in CSS pixels.
               */
              x: number;
              /**
               * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
               * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
               */
              y: number;
              /**
               * X radius of the touch area (default: 1.0).
               */
              radiusX?: number;
              /**
               * Y radius of the touch area (default: 1.0).
               */
              radiusY?: number;
              /**
               * Rotation angle (default: 0.0).
               */
              rotationAngle?: number;
              /**
               * Force (default: 1.0).
               */
              force?: number;
              /**
               * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
               */
              tangentialPressure?: number;
              /**
               * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
               */
              tiltX?: number;
              /**
               * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
               */
              tiltY?: number;
              /**
               * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
               */
              twist?: integer;
              /**
               * Identifier used to track touch sources between events, must be unique within an event.
               */
              id?: number;
          }
          type GestureSourceType = 'default' | 'touch' | 'mouse';
          type MouseButton = 'none' | 'left' | 'middle' | 'right' | 'back' | 'forward';
          /**
           * UTC time in seconds, counted from January 1, 1970.
           */
          type TimeSinceEpoch = number;
          interface DragDataItem {
              /**
               * Mime type of the dragged data.
               */
              mimeType: string;
              /**
               * Depending of the value of `mimeType`, it contains the dragged link,
               * text, HTML markup or any other data.
               */
              data: string;
              /**
               * Title associated with a link. Only valid when `mimeType` == "text/uri-list".
               */
              title?: string;
              /**
               * Stores the base URL for the contained markup. Only valid when `mimeType`
               * == "text/html".
               */
              baseURL?: string;
          }
          interface DragData {
              items: DragDataItem[];
              /**
               * List of filenames that should be included when dropping
               */
              files?: string[];
              /**
               * Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
               */
              dragOperationsMask: integer;
          }
      }
      /**
       * Methods and events of the 'Inspector' domain.
       */
      interface InspectorApi {
          requests: {
              /**
               * Disables inspector domain notifications.
               */
              disable: {
                  params: Inspector.DisableParams;
                  result: Inspector.DisableResult;
              };
              /**
               * Enables inspector domain notifications.
               */
              enable: {
                  params: Inspector.EnableParams;
                  result: Inspector.EnableResult;
              };
          };
          events: {
              /**
               * Fired when remote debugging connection is about to be terminated. Contains detach reason.
               */
              detached: {
                  params: Inspector.DetachedEvent;
              };
              /**
               * Fired when debugging target has crashed
               */
              targetCrashed: {
                  params: Inspector.TargetCrashedEvent;
              };
              /**
               * Fired when debugging target has reloaded after crash
               */
              targetReloadedAfterCrash: {
                  params: Inspector.TargetReloadedAfterCrashEvent;
              };
          };
      }
      /**
       * Types of the 'Inspector' domain.
       */
      namespace Inspector {
          /**
           * Parameters of the 'Inspector.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Inspector.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Inspector.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Inspector.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Inspector.detached' event.
           */
          interface DetachedEvent {
              /**
               * The reason why connection has been terminated.
               */
              reason: string;
          }
          /**
           * Parameters of the 'Inspector.targetCrashed' event.
           */
          interface TargetCrashedEvent {
          }
          /**
           * Parameters of the 'Inspector.targetReloadedAfterCrash' event.
           */
          interface TargetReloadedAfterCrashEvent {
          }
      }
      /**
       * Methods and events of the 'LayerTree' domain.
       */
      interface LayerTreeApi {
          requests: {
              /**
               * Provides the reasons why the given layer was composited.
               */
              compositingReasons: {
                  params: LayerTree.CompositingReasonsParams;
                  result: LayerTree.CompositingReasonsResult;
              };
              /**
               * Disables compositing tree inspection.
               */
              disable: {
                  params: LayerTree.DisableParams;
                  result: LayerTree.DisableResult;
              };
              /**
               * Enables compositing tree inspection.
               */
              enable: {
                  params: LayerTree.EnableParams;
                  result: LayerTree.EnableResult;
              };
              /**
               * Returns the snapshot identifier.
               */
              loadSnapshot: {
                  params: LayerTree.LoadSnapshotParams;
                  result: LayerTree.LoadSnapshotResult;
              };
              /**
               * Returns the layer snapshot identifier.
               */
              makeSnapshot: {
                  params: LayerTree.MakeSnapshotParams;
                  result: LayerTree.MakeSnapshotResult;
              };
              profileSnapshot: {
                  params: LayerTree.ProfileSnapshotParams;
                  result: LayerTree.ProfileSnapshotResult;
              };
              /**
               * Releases layer snapshot captured by the back-end.
               */
              releaseSnapshot: {
                  params: LayerTree.ReleaseSnapshotParams;
                  result: LayerTree.ReleaseSnapshotResult;
              };
              /**
               * Replays the layer snapshot and returns the resulting bitmap.
               */
              replaySnapshot: {
                  params: LayerTree.ReplaySnapshotParams;
                  result: LayerTree.ReplaySnapshotResult;
              };
              /**
               * Replays the layer snapshot and returns canvas log.
               */
              snapshotCommandLog: {
                  params: LayerTree.SnapshotCommandLogParams;
                  result: LayerTree.SnapshotCommandLogResult;
              };
          };
          events: {
              layerPainted: {
                  params: LayerTree.LayerPaintedEvent;
              };
              layerTreeDidChange: {
                  params: LayerTree.LayerTreeDidChangeEvent;
              };
          };
      }
      /**
       * Types of the 'LayerTree' domain.
       */
      namespace LayerTree {
          /**
           * Parameters of the 'LayerTree.compositingReasons' method.
           */
          interface CompositingReasonsParams {
              /**
               * The id of the layer for which we want to get the reasons it was composited.
               */
              layerId: LayerId;
          }
          /**
           * Return value of the 'LayerTree.compositingReasons' method.
           */
          interface CompositingReasonsResult {
              /**
               * A list of strings specifying reasons for the given layer to become composited.
               */
              compositingReasons: string[];
              /**
               * A list of strings specifying reason IDs for the given layer to become composited.
               */
              compositingReasonIds: string[];
          }
          /**
           * Parameters of the 'LayerTree.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'LayerTree.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'LayerTree.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'LayerTree.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'LayerTree.loadSnapshot' method.
           */
          interface LoadSnapshotParams {
              /**
               * An array of tiles composing the snapshot.
               */
              tiles: PictureTile[];
          }
          /**
           * Return value of the 'LayerTree.loadSnapshot' method.
           */
          interface LoadSnapshotResult {
              /**
               * The id of the snapshot.
               */
              snapshotId: SnapshotId;
          }
          /**
           * Parameters of the 'LayerTree.makeSnapshot' method.
           */
          interface MakeSnapshotParams {
              /**
               * The id of the layer.
               */
              layerId: LayerId;
          }
          /**
           * Return value of the 'LayerTree.makeSnapshot' method.
           */
          interface MakeSnapshotResult {
              /**
               * The id of the layer snapshot.
               */
              snapshotId: SnapshotId;
          }
          /**
           * Parameters of the 'LayerTree.profileSnapshot' method.
           */
          interface ProfileSnapshotParams {
              /**
               * The id of the layer snapshot.
               */
              snapshotId: SnapshotId;
              /**
               * The maximum number of times to replay the snapshot (1, if not specified).
               */
              minRepeatCount?: integer;
              /**
               * The minimum duration (in seconds) to replay the snapshot.
               */
              minDuration?: number;
              /**
               * The clip rectangle to apply when replaying the snapshot.
               */
              clipRect?: DOM.Rect;
          }
          /**
           * Return value of the 'LayerTree.profileSnapshot' method.
           */
          interface ProfileSnapshotResult {
              /**
               * The array of paint profiles, one per run.
               */
              timings: PaintProfile[];
          }
          /**
           * Parameters of the 'LayerTree.releaseSnapshot' method.
           */
          interface ReleaseSnapshotParams {
              /**
               * The id of the layer snapshot.
               */
              snapshotId: SnapshotId;
          }
          /**
           * Return value of the 'LayerTree.releaseSnapshot' method.
           */
          interface ReleaseSnapshotResult {
          }
          /**
           * Parameters of the 'LayerTree.replaySnapshot' method.
           */
          interface ReplaySnapshotParams {
              /**
               * The id of the layer snapshot.
               */
              snapshotId: SnapshotId;
              /**
               * The first step to replay from (replay from the very start if not specified).
               */
              fromStep?: integer;
              /**
               * The last step to replay to (replay till the end if not specified).
               */
              toStep?: integer;
              /**
               * The scale to apply while replaying (defaults to 1).
               */
              scale?: number;
          }
          /**
           * Return value of the 'LayerTree.replaySnapshot' method.
           */
          interface ReplaySnapshotResult {
              /**
               * A data: URL for resulting image.
               */
              dataURL: string;
          }
          /**
           * Parameters of the 'LayerTree.snapshotCommandLog' method.
           */
          interface SnapshotCommandLogParams {
              /**
               * The id of the layer snapshot.
               */
              snapshotId: SnapshotId;
          }
          /**
           * Return value of the 'LayerTree.snapshotCommandLog' method.
           */
          interface SnapshotCommandLogResult {
              /**
               * The array of canvas function calls.
               */
              commandLog: Record<string, unknown>[];
          }
          /**
           * Parameters of the 'LayerTree.layerPainted' event.
           */
          interface LayerPaintedEvent {
              /**
               * The id of the painted layer.
               */
              layerId: LayerId;
              /**
               * Clip rectangle.
               */
              clip: DOM.Rect;
          }
          /**
           * Parameters of the 'LayerTree.layerTreeDidChange' event.
           */
          interface LayerTreeDidChangeEvent {
              /**
               * Layer tree, absent if not in the comspositing mode.
               */
              layers?: Layer[];
          }
          /**
           * Unique Layer identifier.
           */
          type LayerId = string;
          /**
           * Unique snapshot identifier.
           */
          type SnapshotId = string;
          /**
           * Rectangle where scrolling happens on the main thread.
           */
          interface ScrollRect {
              /**
               * Rectangle itself.
               */
              rect: DOM.Rect;
              /**
               * Reason for rectangle to force scrolling on the main thread
               */
              type: 'RepaintsOnScroll' | 'TouchEventHandler' | 'WheelEventHandler';
          }
          /**
           * Sticky position constraints.
           */
          interface StickyPositionConstraint {
              /**
               * Layout rectangle of the sticky element before being shifted
               */
              stickyBoxRect: DOM.Rect;
              /**
               * Layout rectangle of the containing block of the sticky element
               */
              containingBlockRect: DOM.Rect;
              /**
               * The nearest sticky layer that shifts the sticky box
               */
              nearestLayerShiftingStickyBox?: LayerId;
              /**
               * The nearest sticky layer that shifts the containing block
               */
              nearestLayerShiftingContainingBlock?: LayerId;
          }
          /**
           * Serialized fragment of layer picture along with its offset within the layer.
           */
          interface PictureTile {
              /**
               * Offset from owning layer left boundary
               */
              x: number;
              /**
               * Offset from owning layer top boundary
               */
              y: number;
              /**
               * Base64-encoded snapshot data. (Encoded as a base64 string when passed over JSON)
               */
              picture: string;
          }
          /**
           * Information about a compositing layer.
           */
          interface Layer {
              /**
               * The unique id for this layer.
               */
              layerId: LayerId;
              /**
               * The id of parent (not present for root).
               */
              parentLayerId?: LayerId;
              /**
               * The backend id for the node associated with this layer.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * Offset from parent layer, X coordinate.
               */
              offsetX: number;
              /**
               * Offset from parent layer, Y coordinate.
               */
              offsetY: number;
              /**
               * Layer width.
               */
              width: number;
              /**
               * Layer height.
               */
              height: number;
              /**
               * Transformation matrix for layer, default is identity matrix
               */
              transform?: number[];
              /**
               * Transform anchor point X, absent if no transform specified
               */
              anchorX?: number;
              /**
               * Transform anchor point Y, absent if no transform specified
               */
              anchorY?: number;
              /**
               * Transform anchor point Z, absent if no transform specified
               */
              anchorZ?: number;
              /**
               * Indicates how many time this layer has painted.
               */
              paintCount: integer;
              /**
               * Indicates whether this layer hosts any content, rather than being used for
               * transform/scrolling purposes only.
               */
              drawsContent: boolean;
              /**
               * Set if layer is not visible.
               */
              invisible?: boolean;
              /**
               * Rectangles scrolling on main thread only.
               */
              scrollRects?: ScrollRect[];
              /**
               * Sticky position constraint information
               */
              stickyPositionConstraint?: StickyPositionConstraint;
          }
          /**
           * Array of timings, one per paint step.
           */
          type PaintProfile = number[];
      }
      /**
       * Methods and events of the 'Log' domain.
       */
      interface LogApi {
          requests: {
              /**
               * Clears the log.
               */
              clear: {
                  params: Log.ClearParams;
                  result: Log.ClearResult;
              };
              /**
               * Disables log domain, prevents further log entries from being reported to the client.
               */
              disable: {
                  params: Log.DisableParams;
                  result: Log.DisableResult;
              };
              /**
               * Enables log domain, sends the entries collected so far to the client by means of the
               * `entryAdded` notification.
               */
              enable: {
                  params: Log.EnableParams;
                  result: Log.EnableResult;
              };
              /**
               * start violation reporting.
               */
              startViolationsReport: {
                  params: Log.StartViolationsReportParams;
                  result: Log.StartViolationsReportResult;
              };
              /**
               * Stop violation reporting.
               */
              stopViolationsReport: {
                  params: Log.StopViolationsReportParams;
                  result: Log.StopViolationsReportResult;
              };
          };
          events: {
              /**
               * Issued when new message was logged.
               */
              entryAdded: {
                  params: Log.EntryAddedEvent;
              };
          };
      }
      /**
       * Types of the 'Log' domain.
       */
      namespace Log {
          /**
           * Parameters of the 'Log.clear' method.
           */
          interface ClearParams {
          }
          /**
           * Return value of the 'Log.clear' method.
           */
          interface ClearResult {
          }
          /**
           * Parameters of the 'Log.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Log.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Log.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Log.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Log.startViolationsReport' method.
           */
          interface StartViolationsReportParams {
              /**
               * Configuration for violations.
               */
              config: ViolationSetting[];
          }
          /**
           * Return value of the 'Log.startViolationsReport' method.
           */
          interface StartViolationsReportResult {
          }
          /**
           * Parameters of the 'Log.stopViolationsReport' method.
           */
          interface StopViolationsReportParams {
          }
          /**
           * Return value of the 'Log.stopViolationsReport' method.
           */
          interface StopViolationsReportResult {
          }
          /**
           * Parameters of the 'Log.entryAdded' event.
           */
          interface EntryAddedEvent {
              /**
               * The entry.
               */
              entry: LogEntry;
          }
          /**
           * Log entry.
           */
          interface LogEntry {
              /**
               * Log entry source.
               */
              source: 'xml' | 'javascript' | 'network' | 'storage' | 'appcache' | 'rendering' | 'security' | 'deprecation' | 'worker' | 'violation' | 'intervention' | 'recommendation' | 'other';
              /**
               * Log entry severity.
               */
              level: 'verbose' | 'info' | 'warning' | 'error';
              /**
               * Logged text.
               */
              text: string;
              category?: 'cors';
              /**
               * Timestamp when this entry was added.
               */
              timestamp: CdpV8.Runtime.Timestamp;
              /**
               * URL of the resource if known.
               */
              url?: string;
              /**
               * Line number in the resource.
               */
              lineNumber?: integer;
              /**
               * JavaScript stack trace.
               */
              stackTrace?: CdpV8.Runtime.StackTrace;
              /**
               * Identifier of the network request associated with this entry.
               */
              networkRequestId?: Network.RequestId;
              /**
               * Identifier of the worker associated with this entry.
               */
              workerId?: string;
              /**
               * Call arguments.
               */
              args?: CdpV8.Runtime.RemoteObject[];
          }
          /**
           * Violation configuration setting.
           */
          interface ViolationSetting {
              /**
               * Violation type.
               */
              name: 'longTask' | 'longLayout' | 'blockedEvent' | 'blockedParser' | 'discouragedAPIUse' | 'handler' | 'recurringHandler';
              /**
               * Time threshold to trigger upon.
               */
              threshold: number;
          }
      }
      /**
       * Methods and events of the 'Memory' domain.
       */
      interface MemoryApi {
          requests: {
              getDOMCounters: {
                  params: Memory.GetDOMCountersParams;
                  result: Memory.GetDOMCountersResult;
              };
              prepareForLeakDetection: {
                  params: Memory.PrepareForLeakDetectionParams;
                  result: Memory.PrepareForLeakDetectionResult;
              };
              /**
               * Simulate OomIntervention by purging V8 memory.
               */
              forciblyPurgeJavaScriptMemory: {
                  params: Memory.ForciblyPurgeJavaScriptMemoryParams;
                  result: Memory.ForciblyPurgeJavaScriptMemoryResult;
              };
              /**
               * Enable/disable suppressing memory pressure notifications in all processes.
               */
              setPressureNotificationsSuppressed: {
                  params: Memory.SetPressureNotificationsSuppressedParams;
                  result: Memory.SetPressureNotificationsSuppressedResult;
              };
              /**
               * Simulate a memory pressure notification in all processes.
               */
              simulatePressureNotification: {
                  params: Memory.SimulatePressureNotificationParams;
                  result: Memory.SimulatePressureNotificationResult;
              };
              /**
               * Start collecting native memory profile.
               */
              startSampling: {
                  params: Memory.StartSamplingParams;
                  result: Memory.StartSamplingResult;
              };
              /**
               * Stop collecting native memory profile.
               */
              stopSampling: {
                  params: Memory.StopSamplingParams;
                  result: Memory.StopSamplingResult;
              };
              /**
               * Retrieve native memory allocations profile
               * collected since renderer process startup.
               */
              getAllTimeSamplingProfile: {
                  params: Memory.GetAllTimeSamplingProfileParams;
                  result: Memory.GetAllTimeSamplingProfileResult;
              };
              /**
               * Retrieve native memory allocations profile
               * collected since browser process startup.
               */
              getBrowserSamplingProfile: {
                  params: Memory.GetBrowserSamplingProfileParams;
                  result: Memory.GetBrowserSamplingProfileResult;
              };
              /**
               * Retrieve native memory allocations profile collected since last
               * `startSampling` call.
               */
              getSamplingProfile: {
                  params: Memory.GetSamplingProfileParams;
                  result: Memory.GetSamplingProfileResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'Memory' domain.
       */
      namespace Memory {
          /**
           * Parameters of the 'Memory.getDOMCounters' method.
           */
          interface GetDOMCountersParams {
          }
          /**
           * Return value of the 'Memory.getDOMCounters' method.
           */
          interface GetDOMCountersResult {
              documents: integer;
              nodes: integer;
              jsEventListeners: integer;
          }
          /**
           * Parameters of the 'Memory.prepareForLeakDetection' method.
           */
          interface PrepareForLeakDetectionParams {
          }
          /**
           * Return value of the 'Memory.prepareForLeakDetection' method.
           */
          interface PrepareForLeakDetectionResult {
          }
          /**
           * Parameters of the 'Memory.forciblyPurgeJavaScriptMemory' method.
           */
          interface ForciblyPurgeJavaScriptMemoryParams {
          }
          /**
           * Return value of the 'Memory.forciblyPurgeJavaScriptMemory' method.
           */
          interface ForciblyPurgeJavaScriptMemoryResult {
          }
          /**
           * Parameters of the 'Memory.setPressureNotificationsSuppressed' method.
           */
          interface SetPressureNotificationsSuppressedParams {
              /**
               * If true, memory pressure notifications will be suppressed.
               */
              suppressed: boolean;
          }
          /**
           * Return value of the 'Memory.setPressureNotificationsSuppressed' method.
           */
          interface SetPressureNotificationsSuppressedResult {
          }
          /**
           * Parameters of the 'Memory.simulatePressureNotification' method.
           */
          interface SimulatePressureNotificationParams {
              /**
               * Memory pressure level of the notification.
               */
              level: PressureLevel;
          }
          /**
           * Return value of the 'Memory.simulatePressureNotification' method.
           */
          interface SimulatePressureNotificationResult {
          }
          /**
           * Parameters of the 'Memory.startSampling' method.
           */
          interface StartSamplingParams {
              /**
               * Average number of bytes between samples.
               */
              samplingInterval?: integer;
              /**
               * Do not randomize intervals between samples.
               */
              suppressRandomness?: boolean;
          }
          /**
           * Return value of the 'Memory.startSampling' method.
           */
          interface StartSamplingResult {
          }
          /**
           * Parameters of the 'Memory.stopSampling' method.
           */
          interface StopSamplingParams {
          }
          /**
           * Return value of the 'Memory.stopSampling' method.
           */
          interface StopSamplingResult {
          }
          /**
           * Parameters of the 'Memory.getAllTimeSamplingProfile' method.
           */
          interface GetAllTimeSamplingProfileParams {
          }
          /**
           * Return value of the 'Memory.getAllTimeSamplingProfile' method.
           */
          interface GetAllTimeSamplingProfileResult {
              profile: SamplingProfile;
          }
          /**
           * Parameters of the 'Memory.getBrowserSamplingProfile' method.
           */
          interface GetBrowserSamplingProfileParams {
          }
          /**
           * Return value of the 'Memory.getBrowserSamplingProfile' method.
           */
          interface GetBrowserSamplingProfileResult {
              profile: SamplingProfile;
          }
          /**
           * Parameters of the 'Memory.getSamplingProfile' method.
           */
          interface GetSamplingProfileParams {
          }
          /**
           * Return value of the 'Memory.getSamplingProfile' method.
           */
          interface GetSamplingProfileResult {
              profile: SamplingProfile;
          }
          /**
           * Memory pressure level.
           */
          type PressureLevel = 'moderate' | 'critical';
          /**
           * Heap profile sample.
           */
          interface SamplingProfileNode {
              /**
               * Size of the sampled allocation.
               */
              size: number;
              /**
               * Total bytes attributed to this sample.
               */
              total: number;
              /**
               * Execution stack at the point of allocation.
               */
              stack: string[];
          }
          /**
           * Array of heap profile samples.
           */
          interface SamplingProfile {
              samples: SamplingProfileNode[];
              modules: Module[];
          }
          /**
           * Executable module information
           */
          interface Module {
              /**
               * Name of the module.
               */
              name: string;
              /**
               * UUID of the module.
               */
              uuid: string;
              /**
               * Base address where the module is loaded into memory. Encoded as a decimal
               * or hexadecimal (0x prefixed) string.
               */
              baseAddress: string;
              /**
               * Size of the module in bytes.
               */
              size: number;
          }
      }
      /**
       * Methods and events of the 'Network' domain.
       */
      interface NetworkApi {
          requests: {
              /**
               * Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
               */
              setAcceptedEncodings: {
                  params: Network.SetAcceptedEncodingsParams;
                  result: Network.SetAcceptedEncodingsResult;
              };
              /**
               * Clears accepted encodings set by setAcceptedEncodings
               */
              clearAcceptedEncodingsOverride: {
                  params: Network.ClearAcceptedEncodingsOverrideParams;
                  result: Network.ClearAcceptedEncodingsOverrideResult;
              };
              /**
               * Tells whether clearing browser cache is supported.
               * @deprecated
               */
              canClearBrowserCache: {
                  params: Network.CanClearBrowserCacheParams;
                  result: Network.CanClearBrowserCacheResult;
              };
              /**
               * Tells whether clearing browser cookies is supported.
               * @deprecated
               */
              canClearBrowserCookies: {
                  params: Network.CanClearBrowserCookiesParams;
                  result: Network.CanClearBrowserCookiesResult;
              };
              /**
               * Tells whether emulation of network conditions is supported.
               * @deprecated
               */
              canEmulateNetworkConditions: {
                  params: Network.CanEmulateNetworkConditionsParams;
                  result: Network.CanEmulateNetworkConditionsResult;
              };
              /**
               * Clears browser cache.
               */
              clearBrowserCache: {
                  params: Network.ClearBrowserCacheParams;
                  result: Network.ClearBrowserCacheResult;
              };
              /**
               * Clears browser cookies.
               */
              clearBrowserCookies: {
                  params: Network.ClearBrowserCookiesParams;
                  result: Network.ClearBrowserCookiesResult;
              };
              /**
               * Response to Network.requestIntercepted which either modifies the request to continue with any
               * modifications, or blocks it, or completes it with the provided response bytes. If a network
               * fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
               * event will be sent with the same InterceptionId.
               * Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
               * @deprecated
               */
              continueInterceptedRequest: {
                  params: Network.ContinueInterceptedRequestParams;
                  result: Network.ContinueInterceptedRequestResult;
              };
              /**
               * Deletes browser cookies with matching name and url or domain/path pair.
               */
              deleteCookies: {
                  params: Network.DeleteCookiesParams;
                  result: Network.DeleteCookiesResult;
              };
              /**
               * Disables network tracking, prevents network events from being sent to the client.
               */
              disable: {
                  params: Network.DisableParams;
                  result: Network.DisableResult;
              };
              /**
               * Activates emulation of network conditions.
               */
              emulateNetworkConditions: {
                  params: Network.EmulateNetworkConditionsParams;
                  result: Network.EmulateNetworkConditionsResult;
              };
              /**
               * Enables network tracking, network events will now be delivered to the client.
               */
              enable: {
                  params: Network.EnableParams;
                  result: Network.EnableResult;
              };
              /**
               * Returns all browser cookies. Depending on the backend support, will return detailed cookie
               * information in the `cookies` field.
               * Deprecated. Use Storage.getCookies instead.
               * @deprecated
               */
              getAllCookies: {
                  params: Network.GetAllCookiesParams;
                  result: Network.GetAllCookiesResult;
              };
              /**
               * Returns the DER-encoded certificate.
               */
              getCertificate: {
                  params: Network.GetCertificateParams;
                  result: Network.GetCertificateResult;
              };
              /**
               * Returns all browser cookies for the current URL. Depending on the backend support, will return
               * detailed cookie information in the `cookies` field.
               */
              getCookies: {
                  params: Network.GetCookiesParams;
                  result: Network.GetCookiesResult;
              };
              /**
               * Returns content served for the given request.
               */
              getResponseBody: {
                  params: Network.GetResponseBodyParams;
                  result: Network.GetResponseBodyResult;
              };
              /**
               * Returns post data sent with the request. Returns an error when no data was sent with the request.
               */
              getRequestPostData: {
                  params: Network.GetRequestPostDataParams;
                  result: Network.GetRequestPostDataResult;
              };
              /**
               * Returns content served for the given currently intercepted request.
               */
              getResponseBodyForInterception: {
                  params: Network.GetResponseBodyForInterceptionParams;
                  result: Network.GetResponseBodyForInterceptionResult;
              };
              /**
               * Returns a handle to the stream representing the response body. Note that after this command,
               * the intercepted request can't be continued as is -- you either need to cancel it or to provide
               * the response body. The stream only supports sequential read, IO.read will fail if the position
               * is specified.
               */
              takeResponseBodyForInterceptionAsStream: {
                  params: Network.TakeResponseBodyForInterceptionAsStreamParams;
                  result: Network.TakeResponseBodyForInterceptionAsStreamResult;
              };
              /**
               * This method sends a new XMLHttpRequest which is identical to the original one. The following
               * parameters should be identical: method, url, async, request body, extra headers, withCredentials
               * attribute, user, password.
               */
              replayXHR: {
                  params: Network.ReplayXHRParams;
                  result: Network.ReplayXHRResult;
              };
              /**
               * Searches for given string in response content.
               */
              searchInResponseBody: {
                  params: Network.SearchInResponseBodyParams;
                  result: Network.SearchInResponseBodyResult;
              };
              /**
               * Blocks URLs from loading.
               */
              setBlockedURLs: {
                  params: Network.SetBlockedURLsParams;
                  result: Network.SetBlockedURLsResult;
              };
              /**
               * Toggles ignoring of service worker for each request.
               */
              setBypassServiceWorker: {
                  params: Network.SetBypassServiceWorkerParams;
                  result: Network.SetBypassServiceWorkerResult;
              };
              /**
               * Toggles ignoring cache for each request. If `true`, cache will not be used.
               */
              setCacheDisabled: {
                  params: Network.SetCacheDisabledParams;
                  result: Network.SetCacheDisabledResult;
              };
              /**
               * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
               */
              setCookie: {
                  params: Network.SetCookieParams;
                  result: Network.SetCookieResult;
              };
              /**
               * Sets given cookies.
               */
              setCookies: {
                  params: Network.SetCookiesParams;
                  result: Network.SetCookiesResult;
              };
              /**
               * Specifies whether to always send extra HTTP headers with the requests from this page.
               */
              setExtraHTTPHeaders: {
                  params: Network.SetExtraHTTPHeadersParams;
                  result: Network.SetExtraHTTPHeadersResult;
              };
              /**
               * Specifies whether to attach a page script stack id in requests
               */
              setAttachDebugStack: {
                  params: Network.SetAttachDebugStackParams;
                  result: Network.SetAttachDebugStackResult;
              };
              /**
               * Sets the requests to intercept that match the provided patterns and optionally resource types.
               * Deprecated, please use Fetch.enable instead.
               * @deprecated
               */
              setRequestInterception: {
                  params: Network.SetRequestInterceptionParams;
                  result: Network.SetRequestInterceptionResult;
              };
              /**
               * Allows overriding user agent with the given string.
               */
              setUserAgentOverride: {
                  params: Network.SetUserAgentOverrideParams;
                  result: Network.SetUserAgentOverrideResult;
              };
              /**
               * Enables streaming of the response for the given requestId.
               * If enabled, the dataReceived event contains the data that was received during streaming.
               */
              streamResourceContent: {
                  params: Network.StreamResourceContentParams;
                  result: Network.StreamResourceContentResult;
              };
              /**
               * Returns information about the COEP/COOP isolation status.
               */
              getSecurityIsolationStatus: {
                  params: Network.GetSecurityIsolationStatusParams;
                  result: Network.GetSecurityIsolationStatusResult;
              };
              /**
               * Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
               * Enabling triggers 'reportingApiReportAdded' for all existing reports.
               */
              enableReportingApi: {
                  params: Network.EnableReportingApiParams;
                  result: Network.EnableReportingApiResult;
              };
              /**
               * Fetches the resource and returns the content.
               */
              loadNetworkResource: {
                  params: Network.LoadNetworkResourceParams;
                  result: Network.LoadNetworkResourceResult;
              };
          };
          events: {
              /**
               * Fired when data chunk was received over the network.
               */
              dataReceived: {
                  params: Network.DataReceivedEvent;
              };
              /**
               * Fired when EventSource message is received.
               */
              eventSourceMessageReceived: {
                  params: Network.EventSourceMessageReceivedEvent;
              };
              /**
               * Fired when HTTP request has failed to load.
               */
              loadingFailed: {
                  params: Network.LoadingFailedEvent;
              };
              /**
               * Fired when HTTP request has finished loading.
               */
              loadingFinished: {
                  params: Network.LoadingFinishedEvent;
              };
              /**
               * Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
               * mocked.
               * Deprecated, use Fetch.requestPaused instead.
               * @deprecated
               */
              requestIntercepted: {
                  params: Network.RequestInterceptedEvent;
              };
              /**
               * Fired if request ended up loading from cache.
               */
              requestServedFromCache: {
                  params: Network.RequestServedFromCacheEvent;
              };
              /**
               * Fired when page is about to send HTTP request.
               */
              requestWillBeSent: {
                  params: Network.RequestWillBeSentEvent;
              };
              /**
               * Fired when resource loading priority is changed
               */
              resourceChangedPriority: {
                  params: Network.ResourceChangedPriorityEvent;
              };
              /**
               * Fired when a signed exchange was received over the network
               */
              signedExchangeReceived: {
                  params: Network.SignedExchangeReceivedEvent;
              };
              /**
               * Fired when HTTP response is available.
               */
              responseReceived: {
                  params: Network.ResponseReceivedEvent;
              };
              /**
               * Fired when WebSocket is closed.
               */
              webSocketClosed: {
                  params: Network.WebSocketClosedEvent;
              };
              /**
               * Fired upon WebSocket creation.
               */
              webSocketCreated: {
                  params: Network.WebSocketCreatedEvent;
              };
              /**
               * Fired when WebSocket message error occurs.
               */
              webSocketFrameError: {
                  params: Network.WebSocketFrameErrorEvent;
              };
              /**
               * Fired when WebSocket message is received.
               */
              webSocketFrameReceived: {
                  params: Network.WebSocketFrameReceivedEvent;
              };
              /**
               * Fired when WebSocket message is sent.
               */
              webSocketFrameSent: {
                  params: Network.WebSocketFrameSentEvent;
              };
              /**
               * Fired when WebSocket handshake response becomes available.
               */
              webSocketHandshakeResponseReceived: {
                  params: Network.WebSocketHandshakeResponseReceivedEvent;
              };
              /**
               * Fired when WebSocket is about to initiate handshake.
               */
              webSocketWillSendHandshakeRequest: {
                  params: Network.WebSocketWillSendHandshakeRequestEvent;
              };
              /**
               * Fired upon WebTransport creation.
               */
              webTransportCreated: {
                  params: Network.WebTransportCreatedEvent;
              };
              /**
               * Fired when WebTransport handshake is finished.
               */
              webTransportConnectionEstablished: {
                  params: Network.WebTransportConnectionEstablishedEvent;
              };
              /**
               * Fired when WebTransport is disposed.
               */
              webTransportClosed: {
                  params: Network.WebTransportClosedEvent;
              };
              /**
               * Fired when additional information about a requestWillBeSent event is available from the
               * network stack. Not every requestWillBeSent event will have an additional
               * requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
               * or requestWillBeSentExtraInfo will be fired first for the same request.
               */
              requestWillBeSentExtraInfo: {
                  params: Network.RequestWillBeSentExtraInfoEvent;
              };
              /**
               * Fired when additional information about a responseReceived event is available from the network
               * stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
               * it, and responseReceivedExtraInfo may be fired before or after responseReceived.
               */
              responseReceivedExtraInfo: {
                  params: Network.ResponseReceivedExtraInfoEvent;
              };
              /**
               * Fired exactly once for each Trust Token operation. Depending on
               * the type of the operation and whether the operation succeeded or
               * failed, the event is fired before the corresponding request was sent
               * or after the response was received.
               */
              trustTokenOperationDone: {
                  params: Network.TrustTokenOperationDoneEvent;
              };
              /**
               * Fired once when parsing the .wbn file has succeeded.
               * The event contains the information about the web bundle contents.
               */
              subresourceWebBundleMetadataReceived: {
                  params: Network.SubresourceWebBundleMetadataReceivedEvent;
              };
              /**
               * Fired once when parsing the .wbn file has failed.
               */
              subresourceWebBundleMetadataError: {
                  params: Network.SubresourceWebBundleMetadataErrorEvent;
              };
              /**
               * Fired when handling requests for resources within a .wbn file.
               * Note: this will only be fired for resources that are requested by the webpage.
               */
              subresourceWebBundleInnerResponseParsed: {
                  params: Network.SubresourceWebBundleInnerResponseParsedEvent;
              };
              /**
               * Fired when request for resources within a .wbn file failed.
               */
              subresourceWebBundleInnerResponseError: {
                  params: Network.SubresourceWebBundleInnerResponseErrorEvent;
              };
              /**
               * Is sent whenever a new report is added.
               * And after 'enableReportingApi' for all existing reports.
               */
              reportingApiReportAdded: {
                  params: Network.ReportingApiReportAddedEvent;
              };
              reportingApiReportUpdated: {
                  params: Network.ReportingApiReportUpdatedEvent;
              };
              reportingApiEndpointsChangedForOrigin: {
                  params: Network.ReportingApiEndpointsChangedForOriginEvent;
              };
          };
      }
      /**
       * Types of the 'Network' domain.
       */
      namespace Network {
          /**
           * Parameters of the 'Network.setAcceptedEncodings' method.
           */
          interface SetAcceptedEncodingsParams {
              /**
               * List of accepted content encodings.
               */
              encodings: ContentEncoding[];
          }
          /**
           * Return value of the 'Network.setAcceptedEncodings' method.
           */
          interface SetAcceptedEncodingsResult {
          }
          /**
           * Parameters of the 'Network.clearAcceptedEncodingsOverride' method.
           */
          interface ClearAcceptedEncodingsOverrideParams {
          }
          /**
           * Return value of the 'Network.clearAcceptedEncodingsOverride' method.
           */
          interface ClearAcceptedEncodingsOverrideResult {
          }
          /**
           * Parameters of the 'Network.canClearBrowserCache' method.
           */
          interface CanClearBrowserCacheParams {
          }
          /**
           * Return value of the 'Network.canClearBrowserCache' method.
           */
          interface CanClearBrowserCacheResult {
              /**
               * True if browser cache can be cleared.
               */
              result: boolean;
          }
          /**
           * Parameters of the 'Network.canClearBrowserCookies' method.
           */
          interface CanClearBrowserCookiesParams {
          }
          /**
           * Return value of the 'Network.canClearBrowserCookies' method.
           */
          interface CanClearBrowserCookiesResult {
              /**
               * True if browser cookies can be cleared.
               */
              result: boolean;
          }
          /**
           * Parameters of the 'Network.canEmulateNetworkConditions' method.
           */
          interface CanEmulateNetworkConditionsParams {
          }
          /**
           * Return value of the 'Network.canEmulateNetworkConditions' method.
           */
          interface CanEmulateNetworkConditionsResult {
              /**
               * True if emulation of network conditions is supported.
               */
              result: boolean;
          }
          /**
           * Parameters of the 'Network.clearBrowserCache' method.
           */
          interface ClearBrowserCacheParams {
          }
          /**
           * Return value of the 'Network.clearBrowserCache' method.
           */
          interface ClearBrowserCacheResult {
          }
          /**
           * Parameters of the 'Network.clearBrowserCookies' method.
           */
          interface ClearBrowserCookiesParams {
          }
          /**
           * Return value of the 'Network.clearBrowserCookies' method.
           */
          interface ClearBrowserCookiesResult {
          }
          /**
           * Parameters of the 'Network.continueInterceptedRequest' method.
           */
          interface ContinueInterceptedRequestParams {
              interceptionId: InterceptionId;
              /**
               * If set this causes the request to fail with the given reason. Passing `Aborted` for requests
               * marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
               * to an authChallenge.
               */
              errorReason?: ErrorReason;
              /**
               * If set the requests completes using with the provided base64 encoded raw response, including
               * HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)
               */
              rawResponse?: string;
              /**
               * If set the request url will be modified in a way that's not observable by page. Must not be
               * set in response to an authChallenge.
               */
              url?: string;
              /**
               * If set this allows the request method to be overridden. Must not be set in response to an
               * authChallenge.
               */
              method?: string;
              /**
               * If set this allows postData to be set. Must not be set in response to an authChallenge.
               */
              postData?: string;
              /**
               * If set this allows the request headers to be changed. Must not be set in response to an
               * authChallenge.
               */
              headers?: Headers;
              /**
               * Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
               */
              authChallengeResponse?: AuthChallengeResponse;
          }
          /**
           * Return value of the 'Network.continueInterceptedRequest' method.
           */
          interface ContinueInterceptedRequestResult {
          }
          /**
           * Parameters of the 'Network.deleteCookies' method.
           */
          interface DeleteCookiesParams {
              /**
               * Name of the cookies to remove.
               */
              name: string;
              /**
               * If specified, deletes all the cookies with the given name where domain and path match
               * provided URL.
               */
              url?: string;
              /**
               * If specified, deletes only cookies with the exact domain.
               */
              domain?: string;
              /**
               * If specified, deletes only cookies with the exact path.
               */
              path?: string;
          }
          /**
           * Return value of the 'Network.deleteCookies' method.
           */
          interface DeleteCookiesResult {
          }
          /**
           * Parameters of the 'Network.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Network.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Network.emulateNetworkConditions' method.
           */
          interface EmulateNetworkConditionsParams {
              /**
               * True to emulate internet disconnection.
               */
              offline: boolean;
              /**
               * Minimum latency from request sent to response headers received (ms).
               */
              latency: number;
              /**
               * Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
               */
              downloadThroughput: number;
              /**
               * Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
               */
              uploadThroughput: number;
              /**
               * Connection type if known.
               */
              connectionType?: ConnectionType;
          }
          /**
           * Return value of the 'Network.emulateNetworkConditions' method.
           */
          interface EmulateNetworkConditionsResult {
          }
          /**
           * Parameters of the 'Network.enable' method.
           */
          interface EnableParams {
              /**
               * Buffer size in bytes to use when preserving network payloads (XHRs, etc).
               */
              maxTotalBufferSize?: integer;
              /**
               * Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
               */
              maxResourceBufferSize?: integer;
              /**
               * Longest post body size (in bytes) that would be included in requestWillBeSent notification
               */
              maxPostDataSize?: integer;
          }
          /**
           * Return value of the 'Network.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Network.getAllCookies' method.
           */
          interface GetAllCookiesParams {
          }
          /**
           * Return value of the 'Network.getAllCookies' method.
           */
          interface GetAllCookiesResult {
              /**
               * Array of cookie objects.
               */
              cookies: Cookie[];
          }
          /**
           * Parameters of the 'Network.getCertificate' method.
           */
          interface GetCertificateParams {
              /**
               * Origin to get certificate for.
               */
              origin: string;
          }
          /**
           * Return value of the 'Network.getCertificate' method.
           */
          interface GetCertificateResult {
              tableNames: string[];
          }
          /**
           * Parameters of the 'Network.getCookies' method.
           */
          interface GetCookiesParams {
              /**
               * The list of URLs for which applicable cookies will be fetched.
               * If not specified, it's assumed to be set to the list containing
               * the URLs of the page and all of its subframes.
               */
              urls?: string[];
          }
          /**
           * Return value of the 'Network.getCookies' method.
           */
          interface GetCookiesResult {
              /**
               * Array of cookie objects.
               */
              cookies: Cookie[];
          }
          /**
           * Parameters of the 'Network.getResponseBody' method.
           */
          interface GetResponseBodyParams {
              /**
               * Identifier of the network request to get content for.
               */
              requestId: RequestId;
          }
          /**
           * Return value of the 'Network.getResponseBody' method.
           */
          interface GetResponseBodyResult {
              /**
               * Response body.
               */
              body: string;
              /**
               * True, if content was sent as base64.
               */
              base64Encoded: boolean;
          }
          /**
           * Parameters of the 'Network.getRequestPostData' method.
           */
          interface GetRequestPostDataParams {
              /**
               * Identifier of the network request to get content for.
               */
              requestId: RequestId;
          }
          /**
           * Return value of the 'Network.getRequestPostData' method.
           */
          interface GetRequestPostDataResult {
              /**
               * Request body string, omitting files from multipart requests
               */
              postData: string;
          }
          /**
           * Parameters of the 'Network.getResponseBodyForInterception' method.
           */
          interface GetResponseBodyForInterceptionParams {
              /**
               * Identifier for the intercepted request to get body for.
               */
              interceptionId: InterceptionId;
          }
          /**
           * Return value of the 'Network.getResponseBodyForInterception' method.
           */
          interface GetResponseBodyForInterceptionResult {
              /**
               * Response body.
               */
              body: string;
              /**
               * True, if content was sent as base64.
               */
              base64Encoded: boolean;
          }
          /**
           * Parameters of the 'Network.takeResponseBodyForInterceptionAsStream' method.
           */
          interface TakeResponseBodyForInterceptionAsStreamParams {
              interceptionId: InterceptionId;
          }
          /**
           * Return value of the 'Network.takeResponseBodyForInterceptionAsStream' method.
           */
          interface TakeResponseBodyForInterceptionAsStreamResult {
              stream: IO.StreamHandle;
          }
          /**
           * Parameters of the 'Network.replayXHR' method.
           */
          interface ReplayXHRParams {
              /**
               * Identifier of XHR to replay.
               */
              requestId: RequestId;
          }
          /**
           * Return value of the 'Network.replayXHR' method.
           */
          interface ReplayXHRResult {
          }
          /**
           * Parameters of the 'Network.searchInResponseBody' method.
           */
          interface SearchInResponseBodyParams {
              /**
               * Identifier of the network response to search.
               */
              requestId: RequestId;
              /**
               * String to search for.
               */
              query: string;
              /**
               * If true, search is case sensitive.
               */
              caseSensitive?: boolean;
              /**
               * If true, treats string parameter as regex.
               */
              isRegex?: boolean;
          }
          /**
           * Return value of the 'Network.searchInResponseBody' method.
           */
          interface SearchInResponseBodyResult {
              /**
               * List of search matches.
               */
              result: CdpV8.Debugger.SearchMatch[];
          }
          /**
           * Parameters of the 'Network.setBlockedURLs' method.
           */
          interface SetBlockedURLsParams {
              /**
               * URL patterns to block. Wildcards ('*') are allowed.
               */
              urls: string[];
          }
          /**
           * Return value of the 'Network.setBlockedURLs' method.
           */
          interface SetBlockedURLsResult {
          }
          /**
           * Parameters of the 'Network.setBypassServiceWorker' method.
           */
          interface SetBypassServiceWorkerParams {
              /**
               * Bypass service worker and load from network.
               */
              bypass: boolean;
          }
          /**
           * Return value of the 'Network.setBypassServiceWorker' method.
           */
          interface SetBypassServiceWorkerResult {
          }
          /**
           * Parameters of the 'Network.setCacheDisabled' method.
           */
          interface SetCacheDisabledParams {
              /**
               * Cache disabled state.
               */
              cacheDisabled: boolean;
          }
          /**
           * Return value of the 'Network.setCacheDisabled' method.
           */
          interface SetCacheDisabledResult {
          }
          /**
           * Parameters of the 'Network.setCookie' method.
           */
          interface SetCookieParams {
              /**
               * Cookie name.
               */
              name: string;
              /**
               * Cookie value.
               */
              value: string;
              /**
               * The request-URI to associate with the setting of the cookie. This value can affect the
               * default domain, path, source port, and source scheme values of the created cookie.
               */
              url?: string;
              /**
               * Cookie domain.
               */
              domain?: string;
              /**
               * Cookie path.
               */
              path?: string;
              /**
               * True if cookie is secure.
               */
              secure?: boolean;
              /**
               * True if cookie is http-only.
               */
              httpOnly?: boolean;
              /**
               * Cookie SameSite type.
               */
              sameSite?: CookieSameSite;
              /**
               * Cookie expiration date, session cookie if not set
               */
              expires?: TimeSinceEpoch;
              /**
               * Cookie Priority type.
               */
              priority?: CookiePriority;
              /**
               * True if cookie is SameParty.
               */
              sameParty?: boolean;
              /**
               * Cookie source scheme type.
               */
              sourceScheme?: CookieSourceScheme;
              /**
               * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
               * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
               * This is a temporary ability and it will be removed in the future.
               */
              sourcePort?: integer;
              /**
               * Cookie partition key. The site of the top-level URL the browser was visiting at the start
               * of the request to the endpoint that set the cookie.
               * If not set, the cookie will be set as not partitioned.
               */
              partitionKey?: string;
          }
          /**
           * Return value of the 'Network.setCookie' method.
           */
          interface SetCookieResult {
              /**
               * Always set to true. If an error occurs, the response indicates protocol error.
               * @deprecated
               */
              success: boolean;
          }
          /**
           * Parameters of the 'Network.setCookies' method.
           */
          interface SetCookiesParams {
              /**
               * Cookies to be set.
               */
              cookies: CookieParam[];
          }
          /**
           * Return value of the 'Network.setCookies' method.
           */
          interface SetCookiesResult {
          }
          /**
           * Parameters of the 'Network.setExtraHTTPHeaders' method.
           */
          interface SetExtraHTTPHeadersParams {
              /**
               * Map with extra HTTP headers.
               */
              headers: Headers;
          }
          /**
           * Return value of the 'Network.setExtraHTTPHeaders' method.
           */
          interface SetExtraHTTPHeadersResult {
          }
          /**
           * Parameters of the 'Network.setAttachDebugStack' method.
           */
          interface SetAttachDebugStackParams {
              /**
               * Whether to attach a page script stack for debugging purpose.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Network.setAttachDebugStack' method.
           */
          interface SetAttachDebugStackResult {
          }
          /**
           * Parameters of the 'Network.setRequestInterception' method.
           */
          interface SetRequestInterceptionParams {
              /**
               * Requests matching any of these patterns will be forwarded and wait for the corresponding
               * continueInterceptedRequest call.
               */
              patterns: RequestPattern[];
          }
          /**
           * Return value of the 'Network.setRequestInterception' method.
           */
          interface SetRequestInterceptionResult {
          }
          /**
           * Parameters of the 'Network.setUserAgentOverride' method.
           */
          interface SetUserAgentOverrideParams {
              /**
               * User agent to use.
               */
              userAgent: string;
              /**
               * Browser language to emulate.
               */
              acceptLanguage?: string;
              /**
               * The platform navigator.platform should return.
               */
              platform?: string;
              /**
               * To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
               */
              userAgentMetadata?: Emulation.UserAgentMetadata;
          }
          /**
           * Return value of the 'Network.setUserAgentOverride' method.
           */
          interface SetUserAgentOverrideResult {
          }
          /**
           * Parameters of the 'Network.streamResourceContent' method.
           */
          interface StreamResourceContentParams {
              /**
               * Identifier of the request to stream.
               */
              requestId: RequestId;
          }
          /**
           * Return value of the 'Network.streamResourceContent' method.
           */
          interface StreamResourceContentResult {
              /**
               * Data that has been buffered until streaming is enabled. (Encoded as a base64 string when passed over JSON)
               */
              bufferedData: string;
          }
          /**
           * Parameters of the 'Network.getSecurityIsolationStatus' method.
           */
          interface GetSecurityIsolationStatusParams {
              /**
               * If no frameId is provided, the status of the target is provided.
               */
              frameId?: Page.FrameId;
          }
          /**
           * Return value of the 'Network.getSecurityIsolationStatus' method.
           */
          interface GetSecurityIsolationStatusResult {
              status: SecurityIsolationStatus;
          }
          /**
           * Parameters of the 'Network.enableReportingApi' method.
           */
          interface EnableReportingApiParams {
              /**
               * Whether to enable or disable events for the Reporting API
               */
              enable: boolean;
          }
          /**
           * Return value of the 'Network.enableReportingApi' method.
           */
          interface EnableReportingApiResult {
          }
          /**
           * Parameters of the 'Network.loadNetworkResource' method.
           */
          interface LoadNetworkResourceParams {
              /**
               * Frame id to get the resource for. Mandatory for frame targets, and
               * should be omitted for worker targets.
               */
              frameId?: Page.FrameId;
              /**
               * URL of the resource to get content for.
               */
              url: string;
              /**
               * Options for the request.
               */
              options: LoadNetworkResourceOptions;
          }
          /**
           * Return value of the 'Network.loadNetworkResource' method.
           */
          interface LoadNetworkResourceResult {
              resource: LoadNetworkResourcePageResult;
          }
          /**
           * Parameters of the 'Network.dataReceived' event.
           */
          interface DataReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Data chunk length.
               */
              dataLength: integer;
              /**
               * Actual bytes received (might be less than dataLength for compressed encodings).
               */
              encodedDataLength: integer;
              /**
               * Data that was received. (Encoded as a base64 string when passed over JSON)
               */
              data?: string;
          }
          /**
           * Parameters of the 'Network.eventSourceMessageReceived' event.
           */
          interface EventSourceMessageReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Message type.
               */
              eventName: string;
              /**
               * Message identifier.
               */
              eventId: string;
              /**
               * Message content.
               */
              data: string;
          }
          /**
           * Parameters of the 'Network.loadingFailed' event.
           */
          interface LoadingFailedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Resource type.
               */
              type: ResourceType;
              /**
               * User friendly error message.
               */
              errorText: string;
              /**
               * True if loading was canceled.
               */
              canceled?: boolean;
              /**
               * The reason why loading was blocked, if any.
               */
              blockedReason?: BlockedReason;
              /**
               * The reason why loading was blocked by CORS, if any.
               */
              corsErrorStatus?: CorsErrorStatus;
          }
          /**
           * Parameters of the 'Network.loadingFinished' event.
           */
          interface LoadingFinishedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Total number of bytes received for this request.
               */
              encodedDataLength: number;
          }
          /**
           * Parameters of the 'Network.requestIntercepted' event.
           */
          interface RequestInterceptedEvent {
              /**
               * Each request the page makes will have a unique id, however if any redirects are encountered
               * while processing that fetch, they will be reported with the same id as the original fetch.
               * Likewise if HTTP authentication is needed then the same fetch id will be used.
               */
              interceptionId: InterceptionId;
              request: Request;
              /**
               * The id of the frame that initiated the request.
               */
              frameId: Page.FrameId;
              /**
               * How the requested resource will be used.
               */
              resourceType: ResourceType;
              /**
               * Whether this is a navigation request, which can abort the navigation completely.
               */
              isNavigationRequest: boolean;
              /**
               * Set if the request is a navigation that will result in a download.
               * Only present after response is received from the server (i.e. HeadersReceived stage).
               */
              isDownload?: boolean;
              /**
               * Redirect location, only sent if a redirect was intercepted.
               */
              redirectUrl?: string;
              /**
               * Details of the Authorization Challenge encountered. If this is set then
               * continueInterceptedRequest must contain an authChallengeResponse.
               */
              authChallenge?: AuthChallenge;
              /**
               * Response error if intercepted at response stage or if redirect occurred while intercepting
               * request.
               */
              responseErrorReason?: ErrorReason;
              /**
               * Response code if intercepted at response stage or if redirect occurred while intercepting
               * request or auth retry occurred.
               */
              responseStatusCode?: integer;
              /**
               * Response headers if intercepted at the response stage or if redirect occurred while
               * intercepting request or auth retry occurred.
               */
              responseHeaders?: Headers;
              /**
               * If the intercepted request had a corresponding requestWillBeSent event fired for it, then
               * this requestId will be the same as the requestId present in the requestWillBeSent event.
               */
              requestId?: RequestId;
          }
          /**
           * Parameters of the 'Network.requestServedFromCache' event.
           */
          interface RequestServedFromCacheEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
          }
          /**
           * Parameters of the 'Network.requestWillBeSent' event.
           */
          interface RequestWillBeSentEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Loader identifier. Empty string if the request is fetched from worker.
               */
              loaderId: LoaderId;
              /**
               * URL of the document this request is loaded for.
               */
              documentURL: string;
              /**
               * Request data.
               */
              request: Request;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Timestamp.
               */
              wallTime: TimeSinceEpoch;
              /**
               * Request initiator.
               */
              initiator: Initiator;
              /**
               * In the case that redirectResponse is populated, this flag indicates whether
               * requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
               * for the request which was just redirected.
               */
              redirectHasExtraInfo: boolean;
              /**
               * Redirect response data.
               */
              redirectResponse?: Response;
              /**
               * Type of this resource.
               */
              type?: ResourceType;
              /**
               * Frame identifier.
               */
              frameId?: Page.FrameId;
              /**
               * Whether the request is initiated by a user gesture. Defaults to false.
               */
              hasUserGesture?: boolean;
          }
          /**
           * Parameters of the 'Network.resourceChangedPriority' event.
           */
          interface ResourceChangedPriorityEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * New priority
               */
              newPriority: ResourcePriority;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
          }
          /**
           * Parameters of the 'Network.signedExchangeReceived' event.
           */
          interface SignedExchangeReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Information about the signed exchange response.
               */
              info: SignedExchangeInfo;
          }
          /**
           * Parameters of the 'Network.responseReceived' event.
           */
          interface ResponseReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Loader identifier. Empty string if the request is fetched from worker.
               */
              loaderId: LoaderId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Resource type.
               */
              type: ResourceType;
              /**
               * Response data.
               */
              response: Response;
              /**
               * Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
               * or were emitted for this request.
               */
              hasExtraInfo: boolean;
              /**
               * Frame identifier.
               */
              frameId?: Page.FrameId;
          }
          /**
           * Parameters of the 'Network.webSocketClosed' event.
           */
          interface WebSocketClosedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
          }
          /**
           * Parameters of the 'Network.webSocketCreated' event.
           */
          interface WebSocketCreatedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * WebSocket request URL.
               */
              url: string;
              /**
               * Request initiator.
               */
              initiator?: Initiator;
          }
          /**
           * Parameters of the 'Network.webSocketFrameError' event.
           */
          interface WebSocketFrameErrorEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * WebSocket error message.
               */
              errorMessage: string;
          }
          /**
           * Parameters of the 'Network.webSocketFrameReceived' event.
           */
          interface WebSocketFrameReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * WebSocket response data.
               */
              response: WebSocketFrame;
          }
          /**
           * Parameters of the 'Network.webSocketFrameSent' event.
           */
          interface WebSocketFrameSentEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * WebSocket response data.
               */
              response: WebSocketFrame;
          }
          /**
           * Parameters of the 'Network.webSocketHandshakeResponseReceived' event.
           */
          interface WebSocketHandshakeResponseReceivedEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * WebSocket response data.
               */
              response: WebSocketResponse;
          }
          /**
           * Parameters of the 'Network.webSocketWillSendHandshakeRequest' event.
           */
          interface WebSocketWillSendHandshakeRequestEvent {
              /**
               * Request identifier.
               */
              requestId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * UTC Timestamp.
               */
              wallTime: TimeSinceEpoch;
              /**
               * WebSocket request data.
               */
              request: WebSocketRequest;
          }
          /**
           * Parameters of the 'Network.webTransportCreated' event.
           */
          interface WebTransportCreatedEvent {
              /**
               * WebTransport identifier.
               */
              transportId: RequestId;
              /**
               * WebTransport request URL.
               */
              url: string;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
              /**
               * Request initiator.
               */
              initiator?: Initiator;
          }
          /**
           * Parameters of the 'Network.webTransportConnectionEstablished' event.
           */
          interface WebTransportConnectionEstablishedEvent {
              /**
               * WebTransport identifier.
               */
              transportId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
          }
          /**
           * Parameters of the 'Network.webTransportClosed' event.
           */
          interface WebTransportClosedEvent {
              /**
               * WebTransport identifier.
               */
              transportId: RequestId;
              /**
               * Timestamp.
               */
              timestamp: MonotonicTime;
          }
          /**
           * Parameters of the 'Network.requestWillBeSentExtraInfo' event.
           */
          interface RequestWillBeSentExtraInfoEvent {
              /**
               * Request identifier. Used to match this information to an existing requestWillBeSent event.
               */
              requestId: RequestId;
              /**
               * A list of cookies potentially associated to the requested URL. This includes both cookies sent with
               * the request and the ones not sent; the latter are distinguished by having blockedReason field set.
               */
              associatedCookies: BlockedCookieWithReason[];
              /**
               * Raw request headers as they will be sent over the wire.
               */
              headers: Headers;
              /**
               * Connection timing information for the request.
               */
              connectTiming: ConnectTiming;
              /**
               * The client security state set for the request.
               */
              clientSecurityState?: ClientSecurityState;
              /**
               * Whether the site has partitioned cookies stored in a partition different than the current one.
               */
              siteHasCookieInOtherPartition?: boolean;
          }
          /**
           * Parameters of the 'Network.responseReceivedExtraInfo' event.
           */
          interface ResponseReceivedExtraInfoEvent {
              /**
               * Request identifier. Used to match this information to another responseReceived event.
               */
              requestId: RequestId;
              /**
               * A list of cookies which were not stored from the response along with the corresponding
               * reasons for blocking. The cookies here may not be valid due to syntax errors, which
               * are represented by the invalid cookie line string instead of a proper cookie.
               */
              blockedCookies: BlockedSetCookieWithReason[];
              /**
               * Raw response headers as they were received over the wire.
               */
              headers: Headers;
              /**
               * The IP address space of the resource. The address space can only be determined once the transport
               * established the connection, so we can't send it in `requestWillBeSentExtraInfo`.
               */
              resourceIPAddressSpace: IPAddressSpace;
              /**
               * The status code of the response. This is useful in cases the request failed and no responseReceived
               * event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code
               * for cached requests, where the status in responseReceived is a 200 and this will be 304.
               */
              statusCode: integer;
              /**
               * Raw response header text as it was received over the wire. The raw text may not always be
               * available, such as in the case of HTTP/2 or QUIC.
               */
              headersText?: string;
              /**
               * The cookie partition key that will be used to store partitioned cookies set in this response.
               * Only sent when partitioned cookies are enabled.
               */
              cookiePartitionKey?: string;
              /**
               * True if partitioned cookies are enabled, but the partition key is not serializeable to string.
               */
              cookiePartitionKeyOpaque?: boolean;
          }
          /**
           * Parameters of the 'Network.trustTokenOperationDone' event.
           */
          interface TrustTokenOperationDoneEvent {
              /**
               * Detailed success or error status of the operation.
               * 'AlreadyExists' also signifies a successful operation, as the result
               * of the operation already exists und thus, the operation was abort
               * preemptively (e.g. a cache hit).
               */
              status: 'Ok' | 'InvalidArgument' | 'MissingIssuerKeys' | 'FailedPrecondition' | 'ResourceExhausted' | 'AlreadyExists' | 'Unavailable' | 'Unauthorized' | 'BadResponse' | 'InternalError' | 'UnknownError' | 'FulfilledLocally';
              type: TrustTokenOperationType;
              requestId: RequestId;
              /**
               * Top level origin. The context in which the operation was attempted.
               */
              topLevelOrigin?: string;
              /**
               * Origin of the issuer in case of a "Issuance" or "Redemption" operation.
               */
              issuerOrigin?: string;
              /**
               * The number of obtained Trust Tokens on a successful "Issuance" operation.
               */
              issuedTokenCount?: integer;
          }
          /**
           * Parameters of the 'Network.subresourceWebBundleMetadataReceived' event.
           */
          interface SubresourceWebBundleMetadataReceivedEvent {
              /**
               * Request identifier. Used to match this information to another event.
               */
              requestId: RequestId;
              /**
               * A list of URLs of resources in the subresource Web Bundle.
               */
              urls: string[];
          }
          /**
           * Parameters of the 'Network.subresourceWebBundleMetadataError' event.
           */
          interface SubresourceWebBundleMetadataErrorEvent {
              /**
               * Request identifier. Used to match this information to another event.
               */
              requestId: RequestId;
              /**
               * Error message
               */
              errorMessage: string;
          }
          /**
           * Parameters of the 'Network.subresourceWebBundleInnerResponseParsed' event.
           */
          interface SubresourceWebBundleInnerResponseParsedEvent {
              /**
               * Request identifier of the subresource request
               */
              innerRequestId: RequestId;
              /**
               * URL of the subresource resource.
               */
              innerRequestURL: string;
              /**
               * Bundle request identifier. Used to match this information to another event.
               * This made be absent in case when the instrumentation was enabled only
               * after webbundle was parsed.
               */
              bundleRequestId?: RequestId;
          }
          /**
           * Parameters of the 'Network.subresourceWebBundleInnerResponseError' event.
           */
          interface SubresourceWebBundleInnerResponseErrorEvent {
              /**
               * Request identifier of the subresource request
               */
              innerRequestId: RequestId;
              /**
               * URL of the subresource resource.
               */
              innerRequestURL: string;
              /**
               * Error message
               */
              errorMessage: string;
              /**
               * Bundle request identifier. Used to match this information to another event.
               * This made be absent in case when the instrumentation was enabled only
               * after webbundle was parsed.
               */
              bundleRequestId?: RequestId;
          }
          /**
           * Parameters of the 'Network.reportingApiReportAdded' event.
           */
          interface ReportingApiReportAddedEvent {
              report: ReportingApiReport;
          }
          /**
           * Parameters of the 'Network.reportingApiReportUpdated' event.
           */
          interface ReportingApiReportUpdatedEvent {
              report: ReportingApiReport;
          }
          /**
           * Parameters of the 'Network.reportingApiEndpointsChangedForOrigin' event.
           */
          interface ReportingApiEndpointsChangedForOriginEvent {
              /**
               * Origin of the document(s) which configured the endpoints.
               */
              origin: string;
              endpoints: ReportingApiEndpoint[];
          }
          /**
           * Resource type as it was perceived by the rendering engine.
           */
          type ResourceType = 'Document' | 'Stylesheet' | 'Image' | 'Media' | 'Font' | 'Script' | 'TextTrack' | 'XHR' | 'Fetch' | 'Prefetch' | 'EventSource' | 'WebSocket' | 'Manifest' | 'SignedExchange' | 'Ping' | 'CSPViolationReport' | 'Preflight' | 'Other';
          /**
           * Unique loader identifier.
           */
          type LoaderId = string;
          /**
           * Unique request identifier.
           */
          type RequestId = string;
          /**
           * Unique intercepted request identifier.
           */
          type InterceptionId = string;
          /**
           * Network level fetch failure reason.
           */
          type ErrorReason = 'Failed' | 'Aborted' | 'TimedOut' | 'AccessDenied' | 'ConnectionClosed' | 'ConnectionReset' | 'ConnectionRefused' | 'ConnectionAborted' | 'ConnectionFailed' | 'NameNotResolved' | 'InternetDisconnected' | 'AddressUnreachable' | 'BlockedByClient' | 'BlockedByResponse';
          /**
           * UTC time in seconds, counted from January 1, 1970.
           */
          type TimeSinceEpoch = number;
          /**
           * Monotonically increasing time in seconds since an arbitrary point in the past.
           */
          type MonotonicTime = number;
          /**
           * Request / response headers as keys / values of JSON object.
           */
          interface Headers {
              [key: string]: any;
          }
          /**
           * The underlying connection technology that the browser is supposedly using.
           */
          type ConnectionType = 'none' | 'cellular2g' | 'cellular3g' | 'cellular4g' | 'bluetooth' | 'ethernet' | 'wifi' | 'wimax' | 'other';
          /**
           * Represents the cookie's 'SameSite' status:
           * https://tools.ietf.org/html/draft-west-first-party-cookies
           */
          type CookieSameSite = 'Strict' | 'Lax' | 'None';
          /**
           * Represents the cookie's 'Priority' status:
           * https://tools.ietf.org/html/draft-west-cookie-priority-00
           */
          type CookiePriority = 'Low' | 'Medium' | 'High';
          /**
           * Represents the source scheme of the origin that originally set the cookie.
           * A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
           * This is a temporary ability and it will be removed in the future.
           */
          type CookieSourceScheme = 'Unset' | 'NonSecure' | 'Secure';
          /**
           * Timing information for the request.
           */
          interface ResourceTiming {
              /**
               * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
               * milliseconds relatively to this requestTime.
               */
              requestTime: number;
              /**
               * Started resolving proxy.
               */
              proxyStart: number;
              /**
               * Finished resolving proxy.
               */
              proxyEnd: number;
              /**
               * Started DNS address resolve.
               */
              dnsStart: number;
              /**
               * Finished DNS address resolve.
               */
              dnsEnd: number;
              /**
               * Started connecting to the remote host.
               */
              connectStart: number;
              /**
               * Connected to the remote host.
               */
              connectEnd: number;
              /**
               * Started SSL handshake.
               */
              sslStart: number;
              /**
               * Finished SSL handshake.
               */
              sslEnd: number;
              /**
               * Started running ServiceWorker.
               */
              workerStart: number;
              /**
               * Finished Starting ServiceWorker.
               */
              workerReady: number;
              /**
               * Started fetch event.
               */
              workerFetchStart: number;
              /**
               * Settled fetch event respondWith promise.
               */
              workerRespondWithSettled: number;
              /**
               * Started sending request.
               */
              sendStart: number;
              /**
               * Finished sending request.
               */
              sendEnd: number;
              /**
               * Time the server started pushing request.
               */
              pushStart: number;
              /**
               * Time the server finished pushing request.
               */
              pushEnd: number;
              /**
               * Started receiving response headers.
               */
              receiveHeadersStart: number;
              /**
               * Finished receiving response headers.
               */
              receiveHeadersEnd: number;
          }
          /**
           * Loading priority of a resource request.
           */
          type ResourcePriority = 'VeryLow' | 'Low' | 'Medium' | 'High' | 'VeryHigh';
          /**
           * Post data entry for HTTP request
           */
          interface PostDataEntry {
              bytes?: string;
          }
          /**
           * HTTP request data.
           */
          interface Request {
              /**
               * Request URL (without fragment).
               */
              url: string;
              /**
               * Fragment of the requested URL starting with hash, if present.
               */
              urlFragment?: string;
              /**
               * HTTP request method.
               */
              method: string;
              /**
               * HTTP request headers.
               */
              headers: Headers;
              /**
               * HTTP POST request data.
               */
              postData?: string;
              /**
               * True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
               */
              hasPostData?: boolean;
              /**
               * Request body elements. This will be converted from base64 to binary
               */
              postDataEntries?: PostDataEntry[];
              /**
               * The mixed content type of the request.
               */
              mixedContentType?: Security.MixedContentType;
              /**
               * Priority of the resource request at the time request is sent.
               */
              initialPriority: ResourcePriority;
              /**
               * The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
               */
              referrerPolicy: 'unsafe-url' | 'no-referrer-when-downgrade' | 'no-referrer' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin';
              /**
               * Whether is loaded via link preload.
               */
              isLinkPreload?: boolean;
              /**
               * Set for requests when the TrustToken API is used. Contains the parameters
               * passed by the developer (e.g. via "fetch") as understood by the backend.
               */
              trustTokenParams?: TrustTokenParams;
              /**
               * True if this resource request is considered to be the 'same site' as the
               * request correspondinfg to the main frame.
               */
              isSameSite?: boolean;
          }
          /**
           * Details of a signed certificate timestamp (SCT).
           */
          interface SignedCertificateTimestamp {
              /**
               * Validation status.
               */
              status: string;
              /**
               * Origin.
               */
              origin: string;
              /**
               * Log name / description.
               */
              logDescription: string;
              /**
               * Log ID.
               */
              logId: string;
              /**
               * Issuance date. Unlike TimeSinceEpoch, this contains the number of
               * milliseconds since January 1, 1970, UTC, not the number of seconds.
               */
              timestamp: number;
              /**
               * Hash algorithm.
               */
              hashAlgorithm: string;
              /**
               * Signature algorithm.
               */
              signatureAlgorithm: string;
              /**
               * Signature data.
               */
              signatureData: string;
          }
          /**
           * Security details about a request.
           */
          interface SecurityDetails {
              /**
               * Protocol name (e.g. "TLS 1.2" or "QUIC").
               */
              protocol: string;
              /**
               * Key Exchange used by the connection, or the empty string if not applicable.
               */
              keyExchange: string;
              /**
               * (EC)DH group used by the connection, if applicable.
               */
              keyExchangeGroup?: string;
              /**
               * Cipher name.
               */
              cipher: string;
              /**
               * TLS MAC. Note that AEAD ciphers do not have separate MACs.
               */
              mac?: string;
              /**
               * Certificate ID value.
               */
              certificateId: Security.CertificateId;
              /**
               * Certificate subject name.
               */
              subjectName: string;
              /**
               * Subject Alternative Name (SAN) DNS names and IP addresses.
               */
              sanList: string[];
              /**
               * Name of the issuing CA.
               */
              issuer: string;
              /**
               * Certificate valid from date.
               */
              validFrom: TimeSinceEpoch;
              /**
               * Certificate valid to (expiration) date
               */
              validTo: TimeSinceEpoch;
              /**
               * List of signed certificate timestamps (SCTs).
               */
              signedCertificateTimestampList: SignedCertificateTimestamp[];
              /**
               * Whether the request complied with Certificate Transparency policy
               */
              certificateTransparencyCompliance: CertificateTransparencyCompliance;
              /**
               * The signature algorithm used by the server in the TLS server signature,
               * represented as a TLS SignatureScheme code point. Omitted if not
               * applicable or not known.
               */
              serverSignatureAlgorithm?: integer;
              /**
               * Whether the connection used Encrypted ClientHello
               */
              encryptedClientHello: boolean;
          }
          /**
           * Whether the request complied with Certificate Transparency policy.
           */
          type CertificateTransparencyCompliance = 'unknown' | 'not-compliant' | 'compliant';
          /**
           * The reason why request was blocked.
           */
          type BlockedReason = 'other' | 'csp' | 'mixed-content' | 'origin' | 'inspector' | 'subresource-filter' | 'content-type' | 'coep-frame-resource-needs-coep-header' | 'coop-sandboxed-iframe-cannot-navigate-to-coop-page' | 'corp-not-same-origin' | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep' | 'corp-not-same-site';
          /**
           * The reason why request was blocked.
           */
          type CorsError = 'DisallowedByMode' | 'InvalidResponse' | 'WildcardOriginNotAllowed' | 'MissingAllowOriginHeader' | 'MultipleAllowOriginValues' | 'InvalidAllowOriginValue' | 'AllowOriginMismatch' | 'InvalidAllowCredentials' | 'CorsDisabledScheme' | 'PreflightInvalidStatus' | 'PreflightDisallowedRedirect' | 'PreflightWildcardOriginNotAllowed' | 'PreflightMissingAllowOriginHeader' | 'PreflightMultipleAllowOriginValues' | 'PreflightInvalidAllowOriginValue' | 'PreflightAllowOriginMismatch' | 'PreflightInvalidAllowCredentials' | 'PreflightMissingAllowExternal' | 'PreflightInvalidAllowExternal' | 'PreflightMissingAllowPrivateNetwork' | 'PreflightInvalidAllowPrivateNetwork' | 'InvalidAllowMethodsPreflightResponse' | 'InvalidAllowHeadersPreflightResponse' | 'MethodDisallowedByPreflightResponse' | 'HeaderDisallowedByPreflightResponse' | 'RedirectContainsCredentials' | 'InsecurePrivateNetwork' | 'InvalidPrivateNetworkAccess' | 'UnexpectedPrivateNetworkAccess' | 'NoCorsRedirectModeNotFollow' | 'PreflightMissingPrivateNetworkAccessId' | 'PreflightMissingPrivateNetworkAccessName' | 'PrivateNetworkAccessPermissionUnavailable' | 'PrivateNetworkAccessPermissionDenied';
          interface CorsErrorStatus {
              corsError: CorsError;
              failedParameter: string;
          }
          /**
           * Source of serviceworker response.
           */
          type ServiceWorkerResponseSource = 'cache-storage' | 'http-cache' | 'fallback-code' | 'network';
          /**
           * Determines what type of Trust Token operation is executed and
           * depending on the type, some additional parameters. The values
           * are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
           */
          interface TrustTokenParams {
              operation: TrustTokenOperationType;
              /**
               * Only set for "token-redemption" operation and determine whether
               * to request a fresh SRR or use a still valid cached SRR.
               */
              refreshPolicy: 'UseCached' | 'Refresh';
              /**
               * Origins of issuers from whom to request tokens or redemption
               * records.
               */
              issuers?: string[];
          }
          type TrustTokenOperationType = 'Issuance' | 'Redemption' | 'Signing';
          /**
           * The reason why Chrome uses a specific transport protocol for HTTP semantics.
           */
          type AlternateProtocolUsage = 'alternativeJobWonWithoutRace' | 'alternativeJobWonRace' | 'mainJobWonRace' | 'mappingMissing' | 'broken' | 'dnsAlpnH3JobWonWithoutRace' | 'dnsAlpnH3JobWonRace' | 'unspecifiedReason';
          interface ServiceWorkerRouterInfo {
              ruleIdMatched: integer;
          }
          /**
           * HTTP response data.
           */
          interface Response {
              /**
               * Response URL. This URL can be different from CachedResource.url in case of redirect.
               */
              url: string;
              /**
               * HTTP response status code.
               */
              status: integer;
              /**
               * HTTP response status text.
               */
              statusText: string;
              /**
               * HTTP response headers.
               */
              headers: Headers;
              /**
               * HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
               * @deprecated
               */
              headersText?: string;
              /**
               * Resource mimeType as determined by the browser.
               */
              mimeType: string;
              /**
               * Refined HTTP request headers that were actually transmitted over the network.
               */
              requestHeaders?: Headers;
              /**
               * HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
               * @deprecated
               */
              requestHeadersText?: string;
              /**
               * Specifies whether physical connection was actually reused for this request.
               */
              connectionReused: boolean;
              /**
               * Physical connection id that was actually used for this request.
               */
              connectionId: number;
              /**
               * Remote IP address.
               */
              remoteIPAddress?: string;
              /**
               * Remote port.
               */
              remotePort?: integer;
              /**
               * Specifies that the request was served from the disk cache.
               */
              fromDiskCache?: boolean;
              /**
               * Specifies that the request was served from the ServiceWorker.
               */
              fromServiceWorker?: boolean;
              /**
               * Specifies that the request was served from the prefetch cache.
               */
              fromPrefetchCache?: boolean;
              /**
               * Infomation about how Service Worker Static Router was used.
               */
              serviceWorkerRouterInfo?: ServiceWorkerRouterInfo;
              /**
               * Total number of bytes received for this request so far.
               */
              encodedDataLength: number;
              /**
               * Timing information for the given request.
               */
              timing?: ResourceTiming;
              /**
               * Response source of response from ServiceWorker.
               */
              serviceWorkerResponseSource?: ServiceWorkerResponseSource;
              /**
               * The time at which the returned response was generated.
               */
              responseTime?: TimeSinceEpoch;
              /**
               * Cache Storage Cache Name.
               */
              cacheStorageCacheName?: string;
              /**
               * Protocol used to fetch this request.
               */
              protocol?: string;
              /**
               * The reason why Chrome uses a specific transport protocol for HTTP semantics.
               */
              alternateProtocolUsage?: AlternateProtocolUsage;
              /**
               * Security state of the request resource.
               */
              securityState: Security.SecurityState;
              /**
               * Security details for the request.
               */
              securityDetails?: SecurityDetails;
          }
          /**
           * WebSocket request data.
           */
          interface WebSocketRequest {
              /**
               * HTTP request headers.
               */
              headers: Headers;
          }
          /**
           * WebSocket response data.
           */
          interface WebSocketResponse {
              /**
               * HTTP response status code.
               */
              status: integer;
              /**
               * HTTP response status text.
               */
              statusText: string;
              /**
               * HTTP response headers.
               */
              headers: Headers;
              /**
               * HTTP response headers text.
               */
              headersText?: string;
              /**
               * HTTP request headers.
               */
              requestHeaders?: Headers;
              /**
               * HTTP request headers text.
               */
              requestHeadersText?: string;
          }
          /**
           * WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
           */
          interface WebSocketFrame {
              /**
               * WebSocket message opcode.
               */
              opcode: number;
              /**
               * WebSocket message mask.
               */
              mask: boolean;
              /**
               * WebSocket message payload data.
               * If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
               * If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
               */
              payloadData: string;
          }
          /**
           * Information about the cached resource.
           */
          interface CachedResource {
              /**
               * Resource URL. This is the url of the original network request.
               */
              url: string;
              /**
               * Type of this resource.
               */
              type: ResourceType;
              /**
               * Cached response data.
               */
              response?: Response;
              /**
               * Cached response body size.
               */
              bodySize: number;
          }
          /**
           * Information about the request initiator.
           */
          interface Initiator {
              /**
               * Type of this initiator.
               */
              type: 'parser' | 'script' | 'preload' | 'SignedExchange' | 'preflight' | 'other';
              /**
               * Initiator JavaScript stack trace, set for Script only.
               */
              stack?: CdpV8.Runtime.StackTrace;
              /**
               * Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
               */
              url?: string;
              /**
               * Initiator line number, set for Parser type or for Script type (when script is importing
               * module) (0-based).
               */
              lineNumber?: number;
              /**
               * Initiator column number, set for Parser type or for Script type (when script is importing
               * module) (0-based).
               */
              columnNumber?: number;
              /**
               * Set if another request triggered this request (e.g. preflight).
               */
              requestId?: RequestId;
          }
          /**
           * Cookie object
           */
          interface Cookie {
              /**
               * Cookie name.
               */
              name: string;
              /**
               * Cookie value.
               */
              value: string;
              /**
               * Cookie domain.
               */
              domain: string;
              /**
               * Cookie path.
               */
              path: string;
              /**
               * Cookie expiration date as the number of seconds since the UNIX epoch.
               */
              expires: number;
              /**
               * Cookie size.
               */
              size: integer;
              /**
               * True if cookie is http-only.
               */
              httpOnly: boolean;
              /**
               * True if cookie is secure.
               */
              secure: boolean;
              /**
               * True in case of session cookie.
               */
              session: boolean;
              /**
               * Cookie SameSite type.
               */
              sameSite?: CookieSameSite;
              /**
               * Cookie Priority
               */
              priority: CookiePriority;
              /**
               * True if cookie is SameParty.
               * @deprecated
               */
              sameParty: boolean;
              /**
               * Cookie source scheme type.
               */
              sourceScheme: CookieSourceScheme;
              /**
               * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
               * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
               * This is a temporary ability and it will be removed in the future.
               */
              sourcePort: integer;
              /**
               * Cookie partition key. The site of the top-level URL the browser was visiting at the start
               * of the request to the endpoint that set the cookie.
               */
              partitionKey?: string;
              /**
               * True if cookie partition key is opaque.
               */
              partitionKeyOpaque?: boolean;
          }
          /**
           * Types of reasons why a cookie may not be stored from a response.
           */
          type SetCookieBlockedReason = 'SecureOnly' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'ThirdPartyPhaseout' | 'ThirdPartyBlockedInFirstPartySet' | 'SyntaxError' | 'SchemeNotSupported' | 'OverwriteSecure' | 'InvalidDomain' | 'InvalidPrefix' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'SamePartyConflictsWithOtherAttributes' | 'NameValuePairExceedsMaxSize' | 'DisallowedCharacter' | 'NoCookieContent';
          /**
           * Types of reasons why a cookie may not be sent with a request.
           */
          type CookieBlockedReason = 'SecureOnly' | 'NotOnPath' | 'DomainMismatch' | 'SameSiteStrict' | 'SameSiteLax' | 'SameSiteUnspecifiedTreatedAsLax' | 'SameSiteNoneInsecure' | 'UserPreferences' | 'ThirdPartyPhaseout' | 'ThirdPartyBlockedInFirstPartySet' | 'UnknownError' | 'SchemefulSameSiteStrict' | 'SchemefulSameSiteLax' | 'SchemefulSameSiteUnspecifiedTreatedAsLax' | 'SamePartyFromCrossPartyContext' | 'NameValuePairExceedsMaxSize';
          /**
           * A cookie which was not stored from a response with the corresponding reason.
           */
          interface BlockedSetCookieWithReason {
              /**
               * The reason(s) this cookie was blocked.
               */
              blockedReasons: SetCookieBlockedReason[];
              /**
               * The string representing this individual cookie as it would appear in the header.
               * This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
               */
              cookieLine: string;
              /**
               * The cookie object which represents the cookie which was not stored. It is optional because
               * sometimes complete cookie information is not available, such as in the case of parsing
               * errors.
               */
              cookie?: Cookie;
          }
          /**
           * A cookie with was not sent with a request with the corresponding reason.
           */
          interface BlockedCookieWithReason {
              /**
               * The reason(s) the cookie was blocked.
               */
              blockedReasons: CookieBlockedReason[];
              /**
               * The cookie object representing the cookie which was not sent.
               */
              cookie: Cookie;
          }
          /**
           * Cookie parameter object
           */
          interface CookieParam {
              /**
               * Cookie name.
               */
              name: string;
              /**
               * Cookie value.
               */
              value: string;
              /**
               * The request-URI to associate with the setting of the cookie. This value can affect the
               * default domain, path, source port, and source scheme values of the created cookie.
               */
              url?: string;
              /**
               * Cookie domain.
               */
              domain?: string;
              /**
               * Cookie path.
               */
              path?: string;
              /**
               * True if cookie is secure.
               */
              secure?: boolean;
              /**
               * True if cookie is http-only.
               */
              httpOnly?: boolean;
              /**
               * Cookie SameSite type.
               */
              sameSite?: CookieSameSite;
              /**
               * Cookie expiration date, session cookie if not set
               */
              expires?: TimeSinceEpoch;
              /**
               * Cookie Priority.
               */
              priority?: CookiePriority;
              /**
               * True if cookie is SameParty.
               */
              sameParty?: boolean;
              /**
               * Cookie source scheme type.
               */
              sourceScheme?: CookieSourceScheme;
              /**
               * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
               * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
               * This is a temporary ability and it will be removed in the future.
               */
              sourcePort?: integer;
              /**
               * Cookie partition key. The site of the top-level URL the browser was visiting at the start
               * of the request to the endpoint that set the cookie.
               * If not set, the cookie will be set as not partitioned.
               */
              partitionKey?: string;
          }
          /**
           * Authorization challenge for HTTP status code 401 or 407.
           */
          interface AuthChallenge {
              /**
               * Source of the authentication challenge.
               */
              source?: 'Server' | 'Proxy';
              /**
               * Origin of the challenger.
               */
              origin: string;
              /**
               * The authentication scheme used, such as basic or digest
               */
              scheme: string;
              /**
               * The realm of the challenge. May be empty.
               */
              realm: string;
          }
          /**
           * Response to an AuthChallenge.
           */
          interface AuthChallengeResponse {
              /**
               * The decision on what to do in response to the authorization challenge.  Default means
               * deferring to the default behavior of the net stack, which will likely either the Cancel
               * authentication or display a popup dialog box.
               */
              response: 'Default' | 'CancelAuth' | 'ProvideCredentials';
              /**
               * The username to provide, possibly empty. Should only be set if response is
               * ProvideCredentials.
               */
              username?: string;
              /**
               * The password to provide, possibly empty. Should only be set if response is
               * ProvideCredentials.
               */
              password?: string;
          }
          /**
           * Stages of the interception to begin intercepting. Request will intercept before the request is
           * sent. Response will intercept after the response is received.
           */
          type InterceptionStage = 'Request' | 'HeadersReceived';
          /**
           * Request pattern for interception.
           */
          interface RequestPattern {
              /**
               * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
               * backslash. Omitting is equivalent to `"*"`.
               */
              urlPattern?: string;
              /**
               * If set, only requests for matching resource types will be intercepted.
               */
              resourceType?: ResourceType;
              /**
               * Stage at which to begin intercepting requests. Default is Request.
               */
              interceptionStage?: InterceptionStage;
          }
          /**
           * Information about a signed exchange signature.
           * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
           */
          interface SignedExchangeSignature {
              /**
               * Signed exchange signature label.
               */
              label: string;
              /**
               * The hex string of signed exchange signature.
               */
              signature: string;
              /**
               * Signed exchange signature integrity.
               */
              integrity: string;
              /**
               * Signed exchange signature cert Url.
               */
              certUrl?: string;
              /**
               * The hex string of signed exchange signature cert sha256.
               */
              certSha256?: string;
              /**
               * Signed exchange signature validity Url.
               */
              validityUrl: string;
              /**
               * Signed exchange signature date.
               */
              date: integer;
              /**
               * Signed exchange signature expires.
               */
              expires: integer;
              /**
               * The encoded certificates.
               */
              certificates?: string[];
          }
          /**
           * Information about a signed exchange header.
           * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
           */
          interface SignedExchangeHeader {
              /**
               * Signed exchange request URL.
               */
              requestUrl: string;
              /**
               * Signed exchange response code.
               */
              responseCode: integer;
              /**
               * Signed exchange response headers.
               */
              responseHeaders: Headers;
              /**
               * Signed exchange response signature.
               */
              signatures: SignedExchangeSignature[];
              /**
               * Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
               */
              headerIntegrity: string;
          }
          /**
           * Field type for a signed exchange related error.
           */
          type SignedExchangeErrorField = 'signatureSig' | 'signatureIntegrity' | 'signatureCertUrl' | 'signatureCertSha256' | 'signatureValidityUrl' | 'signatureTimestamps';
          /**
           * Information about a signed exchange response.
           */
          interface SignedExchangeError {
              /**
               * Error message.
               */
              message: string;
              /**
               * The index of the signature which caused the error.
               */
              signatureIndex?: integer;
              /**
               * The field which caused the error.
               */
              errorField?: SignedExchangeErrorField;
          }
          /**
           * Information about a signed exchange response.
           */
          interface SignedExchangeInfo {
              /**
               * The outer response of signed HTTP exchange which was received from network.
               */
              outerResponse: Response;
              /**
               * Information about the signed exchange header.
               */
              header?: SignedExchangeHeader;
              /**
               * Security details for the signed exchange header.
               */
              securityDetails?: SecurityDetails;
              /**
               * Errors occurred while handling the signed exchagne.
               */
              errors?: SignedExchangeError[];
          }
          /**
           * List of content encodings supported by the backend.
           */
          type ContentEncoding = 'deflate' | 'gzip' | 'br' | 'zstd';
          type PrivateNetworkRequestPolicy = 'Allow' | 'BlockFromInsecureToMorePrivate' | 'WarnFromInsecureToMorePrivate' | 'PreflightBlock' | 'PreflightWarn';
          type IPAddressSpace = 'Local' | 'Private' | 'Public' | 'Unknown';
          interface ConnectTiming {
              /**
               * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
               * milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
               * the same request (but not for redirected requests).
               */
              requestTime: number;
          }
          interface ClientSecurityState {
              initiatorIsSecureContext: boolean;
              initiatorIPAddressSpace: IPAddressSpace;
              privateNetworkRequestPolicy: PrivateNetworkRequestPolicy;
          }
          type CrossOriginOpenerPolicyValue = 'SameOrigin' | 'SameOriginAllowPopups' | 'RestrictProperties' | 'UnsafeNone' | 'SameOriginPlusCoep' | 'RestrictPropertiesPlusCoep';
          interface CrossOriginOpenerPolicyStatus {
              value: CrossOriginOpenerPolicyValue;
              reportOnlyValue: CrossOriginOpenerPolicyValue;
              reportingEndpoint?: string;
              reportOnlyReportingEndpoint?: string;
          }
          type CrossOriginEmbedderPolicyValue = 'None' | 'Credentialless' | 'RequireCorp';
          interface CrossOriginEmbedderPolicyStatus {
              value: CrossOriginEmbedderPolicyValue;
              reportOnlyValue: CrossOriginEmbedderPolicyValue;
              reportingEndpoint?: string;
              reportOnlyReportingEndpoint?: string;
          }
          type ContentSecurityPolicySource = 'HTTP' | 'Meta';
          interface ContentSecurityPolicyStatus {
              effectiveDirectives: string;
              isEnforced: boolean;
              source: ContentSecurityPolicySource;
          }
          interface SecurityIsolationStatus {
              coop?: CrossOriginOpenerPolicyStatus;
              coep?: CrossOriginEmbedderPolicyStatus;
              csp?: ContentSecurityPolicyStatus[];
          }
          /**
           * The status of a Reporting API report.
           */
          type ReportStatus = 'Queued' | 'Pending' | 'MarkedForRemoval' | 'Success';
          type ReportId = string;
          /**
           * An object representing a report generated by the Reporting API.
           */
          interface ReportingApiReport {
              id: ReportId;
              /**
               * The URL of the document that triggered the report.
               */
              initiatorUrl: string;
              /**
               * The name of the endpoint group that should be used to deliver the report.
               */
              destination: string;
              /**
               * The type of the report (specifies the set of data that is contained in the report body).
               */
              type: string;
              /**
               * When the report was generated.
               */
              timestamp: Network.TimeSinceEpoch;
              /**
               * How many uploads deep the related request was.
               */
              depth: integer;
              /**
               * The number of delivery attempts made so far, not including an active attempt.
               */
              completedAttempts: integer;
              body: Record<string, unknown>;
              status: ReportStatus;
          }
          interface ReportingApiEndpoint {
              /**
               * The URL of the endpoint to which reports may be delivered.
               */
              url: string;
              /**
               * Name of the endpoint group.
               */
              groupName: string;
          }
          /**
           * An object providing the result of a network resource load.
           */
          interface LoadNetworkResourcePageResult {
              success: boolean;
              /**
               * Optional values used for error reporting.
               */
              netError?: number;
              netErrorName?: string;
              httpStatusCode?: number;
              /**
               * If successful, one of the following two fields holds the result.
               */
              stream?: IO.StreamHandle;
              /**
               * Response headers.
               */
              headers?: Network.Headers;
          }
          /**
           * An options object that may be extended later to better support CORS,
           * CORB and streaming.
           */
          interface LoadNetworkResourceOptions {
              disableCache: boolean;
              includeCredentials: boolean;
          }
      }
      /**
       * Methods and events of the 'Overlay' domain.
       */
      interface OverlayApi {
          requests: {
              /**
               * Disables domain notifications.
               */
              disable: {
                  params: Overlay.DisableParams;
                  result: Overlay.DisableResult;
              };
              /**
               * Enables domain notifications.
               */
              enable: {
                  params: Overlay.EnableParams;
                  result: Overlay.EnableResult;
              };
              /**
               * For testing.
               */
              getHighlightObjectForTest: {
                  params: Overlay.GetHighlightObjectForTestParams;
                  result: Overlay.GetHighlightObjectForTestResult;
              };
              /**
               * For Persistent Grid testing.
               */
              getGridHighlightObjectsForTest: {
                  params: Overlay.GetGridHighlightObjectsForTestParams;
                  result: Overlay.GetGridHighlightObjectsForTestResult;
              };
              /**
               * For Source Order Viewer testing.
               */
              getSourceOrderHighlightObjectForTest: {
                  params: Overlay.GetSourceOrderHighlightObjectForTestParams;
                  result: Overlay.GetSourceOrderHighlightObjectForTestResult;
              };
              /**
               * Hides any highlight.
               */
              hideHighlight: {
                  params: Overlay.HideHighlightParams;
                  result: Overlay.HideHighlightResult;
              };
              /**
               * Highlights owner element of the frame with given id.
               * Deprecated: Doesn't work reliablity and cannot be fixed due to process
               * separatation (the owner node might be in a different process). Determine
               * the owner node in the client and use highlightNode.
               * @deprecated
               */
              highlightFrame: {
                  params: Overlay.HighlightFrameParams;
                  result: Overlay.HighlightFrameResult;
              };
              /**
               * Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
               * objectId must be specified.
               */
              highlightNode: {
                  params: Overlay.HighlightNodeParams;
                  result: Overlay.HighlightNodeResult;
              };
              /**
               * Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
               */
              highlightQuad: {
                  params: Overlay.HighlightQuadParams;
                  result: Overlay.HighlightQuadResult;
              };
              /**
               * Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
               */
              highlightRect: {
                  params: Overlay.HighlightRectParams;
                  result: Overlay.HighlightRectResult;
              };
              /**
               * Highlights the source order of the children of the DOM node with given id or with the given
               * JavaScript object wrapper. Either nodeId or objectId must be specified.
               */
              highlightSourceOrder: {
                  params: Overlay.HighlightSourceOrderParams;
                  result: Overlay.HighlightSourceOrderResult;
              };
              /**
               * Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
               * Backend then generates 'inspectNodeRequested' event upon element selection.
               */
              setInspectMode: {
                  params: Overlay.SetInspectModeParams;
                  result: Overlay.SetInspectModeResult;
              };
              /**
               * Highlights owner element of all frames detected to be ads.
               */
              setShowAdHighlights: {
                  params: Overlay.SetShowAdHighlightsParams;
                  result: Overlay.SetShowAdHighlightsResult;
              };
              setPausedInDebuggerMessage: {
                  params: Overlay.SetPausedInDebuggerMessageParams;
                  result: Overlay.SetPausedInDebuggerMessageResult;
              };
              /**
               * Requests that backend shows debug borders on layers
               */
              setShowDebugBorders: {
                  params: Overlay.SetShowDebugBordersParams;
                  result: Overlay.SetShowDebugBordersResult;
              };
              /**
               * Requests that backend shows the FPS counter
               */
              setShowFPSCounter: {
                  params: Overlay.SetShowFPSCounterParams;
                  result: Overlay.SetShowFPSCounterResult;
              };
              /**
               * Highlight multiple elements with the CSS Grid overlay.
               */
              setShowGridOverlays: {
                  params: Overlay.SetShowGridOverlaysParams;
                  result: Overlay.SetShowGridOverlaysResult;
              };
              setShowFlexOverlays: {
                  params: Overlay.SetShowFlexOverlaysParams;
                  result: Overlay.SetShowFlexOverlaysResult;
              };
              setShowScrollSnapOverlays: {
                  params: Overlay.SetShowScrollSnapOverlaysParams;
                  result: Overlay.SetShowScrollSnapOverlaysResult;
              };
              setShowContainerQueryOverlays: {
                  params: Overlay.SetShowContainerQueryOverlaysParams;
                  result: Overlay.SetShowContainerQueryOverlaysResult;
              };
              /**
               * Requests that backend shows paint rectangles
               */
              setShowPaintRects: {
                  params: Overlay.SetShowPaintRectsParams;
                  result: Overlay.SetShowPaintRectsResult;
              };
              /**
               * Requests that backend shows layout shift regions
               */
              setShowLayoutShiftRegions: {
                  params: Overlay.SetShowLayoutShiftRegionsParams;
                  result: Overlay.SetShowLayoutShiftRegionsResult;
              };
              /**
               * Requests that backend shows scroll bottleneck rects
               */
              setShowScrollBottleneckRects: {
                  params: Overlay.SetShowScrollBottleneckRectsParams;
                  result: Overlay.SetShowScrollBottleneckRectsResult;
              };
              /**
               * Deprecated, no longer has any effect.
               * @deprecated
               */
              setShowHitTestBorders: {
                  params: Overlay.SetShowHitTestBordersParams;
                  result: Overlay.SetShowHitTestBordersResult;
              };
              /**
               * Request that backend shows an overlay with web vital metrics.
               */
              setShowWebVitals: {
                  params: Overlay.SetShowWebVitalsParams;
                  result: Overlay.SetShowWebVitalsResult;
              };
              /**
               * Paints viewport size upon main frame resize.
               */
              setShowViewportSizeOnResize: {
                  params: Overlay.SetShowViewportSizeOnResizeParams;
                  result: Overlay.SetShowViewportSizeOnResizeResult;
              };
              /**
               * Add a dual screen device hinge
               */
              setShowHinge: {
                  params: Overlay.SetShowHingeParams;
                  result: Overlay.SetShowHingeResult;
              };
              /**
               * Show elements in isolation mode with overlays.
               */
              setShowIsolatedElements: {
                  params: Overlay.SetShowIsolatedElementsParams;
                  result: Overlay.SetShowIsolatedElementsResult;
              };
              /**
               * Show Window Controls Overlay for PWA
               */
              setShowWindowControlsOverlay: {
                  params: Overlay.SetShowWindowControlsOverlayParams;
                  result: Overlay.SetShowWindowControlsOverlayResult;
              };
          };
          events: {
              /**
               * Fired when the node should be inspected. This happens after call to `setInspectMode` or when
               * user manually inspects an element.
               */
              inspectNodeRequested: {
                  params: Overlay.InspectNodeRequestedEvent;
              };
              /**
               * Fired when the node should be highlighted. This happens after call to `setInspectMode`.
               */
              nodeHighlightRequested: {
                  params: Overlay.NodeHighlightRequestedEvent;
              };
              /**
               * Fired when user asks to capture screenshot of some area on the page.
               */
              screenshotRequested: {
                  params: Overlay.ScreenshotRequestedEvent;
              };
              /**
               * Fired when user cancels the inspect mode.
               */
              inspectModeCanceled: {
                  params: Overlay.InspectModeCanceledEvent;
              };
          };
      }
      /**
       * Types of the 'Overlay' domain.
       */
      namespace Overlay {
          /**
           * Parameters of the 'Overlay.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Overlay.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Overlay.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Overlay.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Overlay.getHighlightObjectForTest' method.
           */
          interface GetHighlightObjectForTestParams {
              /**
               * Id of the node to get highlight object for.
               */
              nodeId: DOM.NodeId;
              /**
               * Whether to include distance info.
               */
              includeDistance?: boolean;
              /**
               * Whether to include style info.
               */
              includeStyle?: boolean;
              /**
               * The color format to get config with (default: hex).
               */
              colorFormat?: ColorFormat;
              /**
               * Whether to show accessibility info (default: true).
               */
              showAccessibilityInfo?: boolean;
          }
          /**
           * Return value of the 'Overlay.getHighlightObjectForTest' method.
           */
          interface GetHighlightObjectForTestResult {
              /**
               * Highlight data for the node.
               */
              highlight: Record<string, unknown>;
          }
          /**
           * Parameters of the 'Overlay.getGridHighlightObjectsForTest' method.
           */
          interface GetGridHighlightObjectsForTestParams {
              /**
               * Ids of the node to get highlight object for.
               */
              nodeIds: DOM.NodeId[];
          }
          /**
           * Return value of the 'Overlay.getGridHighlightObjectsForTest' method.
           */
          interface GetGridHighlightObjectsForTestResult {
              /**
               * Grid Highlight data for the node ids provided.
               */
              highlights: Record<string, unknown>;
          }
          /**
           * Parameters of the 'Overlay.getSourceOrderHighlightObjectForTest' method.
           */
          interface GetSourceOrderHighlightObjectForTestParams {
              /**
               * Id of the node to highlight.
               */
              nodeId: DOM.NodeId;
          }
          /**
           * Return value of the 'Overlay.getSourceOrderHighlightObjectForTest' method.
           */
          interface GetSourceOrderHighlightObjectForTestResult {
              /**
               * Source order highlight data for the node id provided.
               */
              highlight: Record<string, unknown>;
          }
          /**
           * Parameters of the 'Overlay.hideHighlight' method.
           */
          interface HideHighlightParams {
          }
          /**
           * Return value of the 'Overlay.hideHighlight' method.
           */
          interface HideHighlightResult {
          }
          /**
           * Parameters of the 'Overlay.highlightFrame' method.
           */
          interface HighlightFrameParams {
              /**
               * Identifier of the frame to highlight.
               */
              frameId: Page.FrameId;
              /**
               * The content box highlight fill color (default: transparent).
               */
              contentColor?: DOM.RGBA;
              /**
               * The content box highlight outline color (default: transparent).
               */
              contentOutlineColor?: DOM.RGBA;
          }
          /**
           * Return value of the 'Overlay.highlightFrame' method.
           */
          interface HighlightFrameResult {
          }
          /**
           * Parameters of the 'Overlay.highlightNode' method.
           */
          interface HighlightNodeParams {
              /**
               * A descriptor for the highlight appearance.
               */
              highlightConfig: HighlightConfig;
              /**
               * Identifier of the node to highlight.
               */
              nodeId?: DOM.NodeId;
              /**
               * Identifier of the backend node to highlight.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * JavaScript object id of the node to be highlighted.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
              /**
               * Selectors to highlight relevant nodes.
               */
              selector?: string;
          }
          /**
           * Return value of the 'Overlay.highlightNode' method.
           */
          interface HighlightNodeResult {
          }
          /**
           * Parameters of the 'Overlay.highlightQuad' method.
           */
          interface HighlightQuadParams {
              /**
               * Quad to highlight
               */
              quad: DOM.Quad;
              /**
               * The highlight fill color (default: transparent).
               */
              color?: DOM.RGBA;
              /**
               * The highlight outline color (default: transparent).
               */
              outlineColor?: DOM.RGBA;
          }
          /**
           * Return value of the 'Overlay.highlightQuad' method.
           */
          interface HighlightQuadResult {
          }
          /**
           * Parameters of the 'Overlay.highlightRect' method.
           */
          interface HighlightRectParams {
              /**
               * X coordinate
               */
              x: integer;
              /**
               * Y coordinate
               */
              y: integer;
              /**
               * Rectangle width
               */
              width: integer;
              /**
               * Rectangle height
               */
              height: integer;
              /**
               * The highlight fill color (default: transparent).
               */
              color?: DOM.RGBA;
              /**
               * The highlight outline color (default: transparent).
               */
              outlineColor?: DOM.RGBA;
          }
          /**
           * Return value of the 'Overlay.highlightRect' method.
           */
          interface HighlightRectResult {
          }
          /**
           * Parameters of the 'Overlay.highlightSourceOrder' method.
           */
          interface HighlightSourceOrderParams {
              /**
               * A descriptor for the appearance of the overlay drawing.
               */
              sourceOrderConfig: SourceOrderConfig;
              /**
               * Identifier of the node to highlight.
               */
              nodeId?: DOM.NodeId;
              /**
               * Identifier of the backend node to highlight.
               */
              backendNodeId?: DOM.BackendNodeId;
              /**
               * JavaScript object id of the node to be highlighted.
               */
              objectId?: CdpV8.Runtime.RemoteObjectId;
          }
          /**
           * Return value of the 'Overlay.highlightSourceOrder' method.
           */
          interface HighlightSourceOrderResult {
          }
          /**
           * Parameters of the 'Overlay.setInspectMode' method.
           */
          interface SetInspectModeParams {
              /**
               * Set an inspection mode.
               */
              mode: InspectMode;
              /**
               * A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
               * == false`.
               */
              highlightConfig?: HighlightConfig;
          }
          /**
           * Return value of the 'Overlay.setInspectMode' method.
           */
          interface SetInspectModeResult {
          }
          /**
           * Parameters of the 'Overlay.setShowAdHighlights' method.
           */
          interface SetShowAdHighlightsParams {
              /**
               * True for showing ad highlights
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowAdHighlights' method.
           */
          interface SetShowAdHighlightsResult {
          }
          /**
           * Parameters of the 'Overlay.setPausedInDebuggerMessage' method.
           */
          interface SetPausedInDebuggerMessageParams {
              /**
               * The message to display, also triggers resume and step over controls.
               */
              message?: string;
          }
          /**
           * Return value of the 'Overlay.setPausedInDebuggerMessage' method.
           */
          interface SetPausedInDebuggerMessageResult {
          }
          /**
           * Parameters of the 'Overlay.setShowDebugBorders' method.
           */
          interface SetShowDebugBordersParams {
              /**
               * True for showing debug borders
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowDebugBorders' method.
           */
          interface SetShowDebugBordersResult {
          }
          /**
           * Parameters of the 'Overlay.setShowFPSCounter' method.
           */
          interface SetShowFPSCounterParams {
              /**
               * True for showing the FPS counter
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowFPSCounter' method.
           */
          interface SetShowFPSCounterResult {
          }
          /**
           * Parameters of the 'Overlay.setShowGridOverlays' method.
           */
          interface SetShowGridOverlaysParams {
              /**
               * An array of node identifiers and descriptors for the highlight appearance.
               */
              gridNodeHighlightConfigs: GridNodeHighlightConfig[];
          }
          /**
           * Return value of the 'Overlay.setShowGridOverlays' method.
           */
          interface SetShowGridOverlaysResult {
          }
          /**
           * Parameters of the 'Overlay.setShowFlexOverlays' method.
           */
          interface SetShowFlexOverlaysParams {
              /**
               * An array of node identifiers and descriptors for the highlight appearance.
               */
              flexNodeHighlightConfigs: FlexNodeHighlightConfig[];
          }
          /**
           * Return value of the 'Overlay.setShowFlexOverlays' method.
           */
          interface SetShowFlexOverlaysResult {
          }
          /**
           * Parameters of the 'Overlay.setShowScrollSnapOverlays' method.
           */
          interface SetShowScrollSnapOverlaysParams {
              /**
               * An array of node identifiers and descriptors for the highlight appearance.
               */
              scrollSnapHighlightConfigs: ScrollSnapHighlightConfig[];
          }
          /**
           * Return value of the 'Overlay.setShowScrollSnapOverlays' method.
           */
          interface SetShowScrollSnapOverlaysResult {
          }
          /**
           * Parameters of the 'Overlay.setShowContainerQueryOverlays' method.
           */
          interface SetShowContainerQueryOverlaysParams {
              /**
               * An array of node identifiers and descriptors for the highlight appearance.
               */
              containerQueryHighlightConfigs: ContainerQueryHighlightConfig[];
          }
          /**
           * Return value of the 'Overlay.setShowContainerQueryOverlays' method.
           */
          interface SetShowContainerQueryOverlaysResult {
          }
          /**
           * Parameters of the 'Overlay.setShowPaintRects' method.
           */
          interface SetShowPaintRectsParams {
              /**
               * True for showing paint rectangles
               */
              result: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowPaintRects' method.
           */
          interface SetShowPaintRectsResult {
          }
          /**
           * Parameters of the 'Overlay.setShowLayoutShiftRegions' method.
           */
          interface SetShowLayoutShiftRegionsParams {
              /**
               * True for showing layout shift regions
               */
              result: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowLayoutShiftRegions' method.
           */
          interface SetShowLayoutShiftRegionsResult {
          }
          /**
           * Parameters of the 'Overlay.setShowScrollBottleneckRects' method.
           */
          interface SetShowScrollBottleneckRectsParams {
              /**
               * True for showing scroll bottleneck rects
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowScrollBottleneckRects' method.
           */
          interface SetShowScrollBottleneckRectsResult {
          }
          /**
           * Parameters of the 'Overlay.setShowHitTestBorders' method.
           */
          interface SetShowHitTestBordersParams {
              /**
               * True for showing hit-test borders
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowHitTestBorders' method.
           */
          interface SetShowHitTestBordersResult {
          }
          /**
           * Parameters of the 'Overlay.setShowWebVitals' method.
           */
          interface SetShowWebVitalsParams {
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowWebVitals' method.
           */
          interface SetShowWebVitalsResult {
          }
          /**
           * Parameters of the 'Overlay.setShowViewportSizeOnResize' method.
           */
          interface SetShowViewportSizeOnResizeParams {
              /**
               * Whether to paint size or not.
               */
              show: boolean;
          }
          /**
           * Return value of the 'Overlay.setShowViewportSizeOnResize' method.
           */
          interface SetShowViewportSizeOnResizeResult {
          }
          /**
           * Parameters of the 'Overlay.setShowHinge' method.
           */
          interface SetShowHingeParams {
              /**
               * hinge data, null means hideHinge
               */
              hingeConfig?: HingeConfig;
          }
          /**
           * Return value of the 'Overlay.setShowHinge' method.
           */
          interface SetShowHingeResult {
          }
          /**
           * Parameters of the 'Overlay.setShowIsolatedElements' method.
           */
          interface SetShowIsolatedElementsParams {
              /**
               * An array of node identifiers and descriptors for the highlight appearance.
               */
              isolatedElementHighlightConfigs: IsolatedElementHighlightConfig[];
          }
          /**
           * Return value of the 'Overlay.setShowIsolatedElements' method.
           */
          interface SetShowIsolatedElementsResult {
          }
          /**
           * Parameters of the 'Overlay.setShowWindowControlsOverlay' method.
           */
          interface SetShowWindowControlsOverlayParams {
              /**
               * Window Controls Overlay data, null means hide Window Controls Overlay
               */
              windowControlsOverlayConfig?: WindowControlsOverlayConfig;
          }
          /**
           * Return value of the 'Overlay.setShowWindowControlsOverlay' method.
           */
          interface SetShowWindowControlsOverlayResult {
          }
          /**
           * Parameters of the 'Overlay.inspectNodeRequested' event.
           */
          interface InspectNodeRequestedEvent {
              /**
               * Id of the node to inspect.
               */
              backendNodeId: DOM.BackendNodeId;
          }
          /**
           * Parameters of the 'Overlay.nodeHighlightRequested' event.
           */
          interface NodeHighlightRequestedEvent {
              nodeId: DOM.NodeId;
          }
          /**
           * Parameters of the 'Overlay.screenshotRequested' event.
           */
          interface ScreenshotRequestedEvent {
              /**
               * Viewport to capture, in device independent pixels (dip).
               */
              viewport: Page.Viewport;
          }
          /**
           * Parameters of the 'Overlay.inspectModeCanceled' event.
           */
          interface InspectModeCanceledEvent {
          }
          /**
           * Configuration data for drawing the source order of an elements children.
           */
          interface SourceOrderConfig {
              /**
               * the color to outline the givent element in.
               */
              parentOutlineColor: DOM.RGBA;
              /**
               * the color to outline the child elements in.
               */
              childOutlineColor: DOM.RGBA;
          }
          /**
           * Configuration data for the highlighting of Grid elements.
           */
          interface GridHighlightConfig {
              /**
               * Whether the extension lines from grid cells to the rulers should be shown (default: false).
               */
              showGridExtensionLines?: boolean;
              /**
               * Show Positive line number labels (default: false).
               */
              showPositiveLineNumbers?: boolean;
              /**
               * Show Negative line number labels (default: false).
               */
              showNegativeLineNumbers?: boolean;
              /**
               * Show area name labels (default: false).
               */
              showAreaNames?: boolean;
              /**
               * Show line name labels (default: false).
               */
              showLineNames?: boolean;
              /**
               * Show track size labels (default: false).
               */
              showTrackSizes?: boolean;
              /**
               * The grid container border highlight color (default: transparent).
               */
              gridBorderColor?: DOM.RGBA;
              /**
               * The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
               * @deprecated
               */
              cellBorderColor?: DOM.RGBA;
              /**
               * The row line color (default: transparent).
               */
              rowLineColor?: DOM.RGBA;
              /**
               * The column line color (default: transparent).
               */
              columnLineColor?: DOM.RGBA;
              /**
               * Whether the grid border is dashed (default: false).
               */
              gridBorderDash?: boolean;
              /**
               * Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
               * @deprecated
               */
              cellBorderDash?: boolean;
              /**
               * Whether row lines are dashed (default: false).
               */
              rowLineDash?: boolean;
              /**
               * Whether column lines are dashed (default: false).
               */
              columnLineDash?: boolean;
              /**
               * The row gap highlight fill color (default: transparent).
               */
              rowGapColor?: DOM.RGBA;
              /**
               * The row gap hatching fill color (default: transparent).
               */
              rowHatchColor?: DOM.RGBA;
              /**
               * The column gap highlight fill color (default: transparent).
               */
              columnGapColor?: DOM.RGBA;
              /**
               * The column gap hatching fill color (default: transparent).
               */
              columnHatchColor?: DOM.RGBA;
              /**
               * The named grid areas border color (Default: transparent).
               */
              areaBorderColor?: DOM.RGBA;
              /**
               * The grid container background color (Default: transparent).
               */
              gridBackgroundColor?: DOM.RGBA;
          }
          /**
           * Configuration data for the highlighting of Flex container elements.
           */
          interface FlexContainerHighlightConfig {
              /**
               * The style of the container border
               */
              containerBorder?: LineStyle;
              /**
               * The style of the separator between lines
               */
              lineSeparator?: LineStyle;
              /**
               * The style of the separator between items
               */
              itemSeparator?: LineStyle;
              /**
               * Style of content-distribution space on the main axis (justify-content).
               */
              mainDistributedSpace?: BoxStyle;
              /**
               * Style of content-distribution space on the cross axis (align-content).
               */
              crossDistributedSpace?: BoxStyle;
              /**
               * Style of empty space caused by row gaps (gap/row-gap).
               */
              rowGapSpace?: BoxStyle;
              /**
               * Style of empty space caused by columns gaps (gap/column-gap).
               */
              columnGapSpace?: BoxStyle;
              /**
               * Style of the self-alignment line (align-items).
               */
              crossAlignment?: LineStyle;
          }
          /**
           * Configuration data for the highlighting of Flex item elements.
           */
          interface FlexItemHighlightConfig {
              /**
               * Style of the box representing the item's base size
               */
              baseSizeBox?: BoxStyle;
              /**
               * Style of the border around the box representing the item's base size
               */
              baseSizeBorder?: LineStyle;
              /**
               * Style of the arrow representing if the item grew or shrank
               */
              flexibilityArrow?: LineStyle;
          }
          /**
           * Style information for drawing a line.
           */
          interface LineStyle {
              /**
               * The color of the line (default: transparent)
               */
              color?: DOM.RGBA;
              /**
               * The line pattern (default: solid)
               */
              pattern?: 'dashed' | 'dotted';
          }
          /**
           * Style information for drawing a box.
           */
          interface BoxStyle {
              /**
               * The background color for the box (default: transparent)
               */
              fillColor?: DOM.RGBA;
              /**
               * The hatching color for the box (default: transparent)
               */
              hatchColor?: DOM.RGBA;
          }
          type ContrastAlgorithm = 'aa' | 'aaa' | 'apca';
          /**
           * Configuration data for the highlighting of page elements.
           */
          interface HighlightConfig {
              /**
               * Whether the node info tooltip should be shown (default: false).
               */
              showInfo?: boolean;
              /**
               * Whether the node styles in the tooltip (default: false).
               */
              showStyles?: boolean;
              /**
               * Whether the rulers should be shown (default: false).
               */
              showRulers?: boolean;
              /**
               * Whether the a11y info should be shown (default: true).
               */
              showAccessibilityInfo?: boolean;
              /**
               * Whether the extension lines from node to the rulers should be shown (default: false).
               */
              showExtensionLines?: boolean;
              /**
               * The content box highlight fill color (default: transparent).
               */
              contentColor?: DOM.RGBA;
              /**
               * The padding highlight fill color (default: transparent).
               */
              paddingColor?: DOM.RGBA;
              /**
               * The border highlight fill color (default: transparent).
               */
              borderColor?: DOM.RGBA;
              /**
               * The margin highlight fill color (default: transparent).
               */
              marginColor?: DOM.RGBA;
              /**
               * The event target element highlight fill color (default: transparent).
               */
              eventTargetColor?: DOM.RGBA;
              /**
               * The shape outside fill color (default: transparent).
               */
              shapeColor?: DOM.RGBA;
              /**
               * The shape margin fill color (default: transparent).
               */
              shapeMarginColor?: DOM.RGBA;
              /**
               * The grid layout color (default: transparent).
               */
              cssGridColor?: DOM.RGBA;
              /**
               * The color format used to format color styles (default: hex).
               */
              colorFormat?: ColorFormat;
              /**
               * The grid layout highlight configuration (default: all transparent).
               */
              gridHighlightConfig?: GridHighlightConfig;
              /**
               * The flex container highlight configuration (default: all transparent).
               */
              flexContainerHighlightConfig?: FlexContainerHighlightConfig;
              /**
               * The flex item highlight configuration (default: all transparent).
               */
              flexItemHighlightConfig?: FlexItemHighlightConfig;
              /**
               * The contrast algorithm to use for the contrast ratio (default: aa).
               */
              contrastAlgorithm?: ContrastAlgorithm;
              /**
               * The container query container highlight configuration (default: all transparent).
               */
              containerQueryContainerHighlightConfig?: ContainerQueryContainerHighlightConfig;
          }
          type ColorFormat = 'rgb' | 'hsl' | 'hwb' | 'hex';
          /**
           * Configurations for Persistent Grid Highlight
           */
          interface GridNodeHighlightConfig {
              /**
               * A descriptor for the highlight appearance.
               */
              gridHighlightConfig: GridHighlightConfig;
              /**
               * Identifier of the node to highlight.
               */
              nodeId: DOM.NodeId;
          }
          interface FlexNodeHighlightConfig {
              /**
               * A descriptor for the highlight appearance of flex containers.
               */
              flexContainerHighlightConfig: FlexContainerHighlightConfig;
              /**
               * Identifier of the node to highlight.
               */
              nodeId: DOM.NodeId;
          }
          interface ScrollSnapContainerHighlightConfig {
              /**
               * The style of the snapport border (default: transparent)
               */
              snapportBorder?: LineStyle;
              /**
               * The style of the snap area border (default: transparent)
               */
              snapAreaBorder?: LineStyle;
              /**
               * The margin highlight fill color (default: transparent).
               */
              scrollMarginColor?: DOM.RGBA;
              /**
               * The padding highlight fill color (default: transparent).
               */
              scrollPaddingColor?: DOM.RGBA;
          }
          interface ScrollSnapHighlightConfig {
              /**
               * A descriptor for the highlight appearance of scroll snap containers.
               */
              scrollSnapContainerHighlightConfig: ScrollSnapContainerHighlightConfig;
              /**
               * Identifier of the node to highlight.
               */
              nodeId: DOM.NodeId;
          }
          /**
           * Configuration for dual screen hinge
           */
          interface HingeConfig {
              /**
               * A rectangle represent hinge
               */
              rect: DOM.Rect;
              /**
               * The content box highlight fill color (default: a dark color).
               */
              contentColor?: DOM.RGBA;
              /**
               * The content box highlight outline color (default: transparent).
               */
              outlineColor?: DOM.RGBA;
          }
          /**
           * Configuration for Window Controls Overlay
           */
          interface WindowControlsOverlayConfig {
              /**
               * Whether the title bar CSS should be shown when emulating the Window Controls Overlay.
               */
              showCSS: boolean;
              /**
               * Seleted platforms to show the overlay.
               */
              selectedPlatform: string;
              /**
               * The theme color defined in app manifest.
               */
              themeColor: string;
          }
          interface ContainerQueryHighlightConfig {
              /**
               * A descriptor for the highlight appearance of container query containers.
               */
              containerQueryContainerHighlightConfig: ContainerQueryContainerHighlightConfig;
              /**
               * Identifier of the container node to highlight.
               */
              nodeId: DOM.NodeId;
          }
          interface ContainerQueryContainerHighlightConfig {
              /**
               * The style of the container border.
               */
              containerBorder?: LineStyle;
              /**
               * The style of the descendants' borders.
               */
              descendantBorder?: LineStyle;
          }
          interface IsolatedElementHighlightConfig {
              /**
               * A descriptor for the highlight appearance of an element in isolation mode.
               */
              isolationModeHighlightConfig: IsolationModeHighlightConfig;
              /**
               * Identifier of the isolated element to highlight.
               */
              nodeId: DOM.NodeId;
          }
          interface IsolationModeHighlightConfig {
              /**
               * The fill color of the resizers (default: transparent).
               */
              resizerColor?: DOM.RGBA;
              /**
               * The fill color for resizer handles (default: transparent).
               */
              resizerHandleColor?: DOM.RGBA;
              /**
               * The fill color for the mask covering non-isolated elements (default: transparent).
               */
              maskColor?: DOM.RGBA;
          }
          type InspectMode = 'searchForNode' | 'searchForUAShadowDOM' | 'captureAreaScreenshot' | 'showDistances' | 'none';
      }
      /**
       * Methods and events of the 'Page' domain.
       */
      interface PageApi {
          requests: {
              /**
               * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
               * @deprecated
               */
              addScriptToEvaluateOnLoad: {
                  params: Page.AddScriptToEvaluateOnLoadParams;
                  result: Page.AddScriptToEvaluateOnLoadResult;
              };
              /**
               * Evaluates given script in every frame upon creation (before loading frame's scripts).
               */
              addScriptToEvaluateOnNewDocument: {
                  params: Page.AddScriptToEvaluateOnNewDocumentParams;
                  result: Page.AddScriptToEvaluateOnNewDocumentResult;
              };
              /**
               * Brings page to front (activates tab).
               */
              bringToFront: {
                  params: Page.BringToFrontParams;
                  result: Page.BringToFrontResult;
              };
              /**
               * Capture page screenshot.
               */
              captureScreenshot: {
                  params: Page.CaptureScreenshotParams;
                  result: Page.CaptureScreenshotResult;
              };
              /**
               * Returns a snapshot of the page as a string. For MHTML format, the serialization includes
               * iframes, shadow DOM, external resources, and element-inline styles.
               */
              captureSnapshot: {
                  params: Page.CaptureSnapshotParams;
                  result: Page.CaptureSnapshotResult;
              };
              /**
               * Clears the overridden device metrics.
               * @deprecated
               */
              clearDeviceMetricsOverride: {
                  params: Page.ClearDeviceMetricsOverrideParams;
                  result: Page.ClearDeviceMetricsOverrideResult;
              };
              /**
               * Clears the overridden Device Orientation.
               * @deprecated
               */
              clearDeviceOrientationOverride: {
                  params: Page.ClearDeviceOrientationOverrideParams;
                  result: Page.ClearDeviceOrientationOverrideResult;
              };
              /**
               * Clears the overridden Geolocation Position and Error.
               * @deprecated
               */
              clearGeolocationOverride: {
                  params: Page.ClearGeolocationOverrideParams;
                  result: Page.ClearGeolocationOverrideResult;
              };
              /**
               * Creates an isolated world for the given frame.
               */
              createIsolatedWorld: {
                  params: Page.CreateIsolatedWorldParams;
                  result: Page.CreateIsolatedWorldResult;
              };
              /**
               * Deletes browser cookie with given name, domain and path.
               * @deprecated
               */
              deleteCookie: {
                  params: Page.DeleteCookieParams;
                  result: Page.DeleteCookieResult;
              };
              /**
               * Disables page domain notifications.
               */
              disable: {
                  params: Page.DisableParams;
                  result: Page.DisableResult;
              };
              /**
               * Enables page domain notifications.
               */
              enable: {
                  params: Page.EnableParams;
                  result: Page.EnableResult;
              };
              getAppManifest: {
                  params: Page.GetAppManifestParams;
                  result: Page.GetAppManifestResult;
              };
              getInstallabilityErrors: {
                  params: Page.GetInstallabilityErrorsParams;
                  result: Page.GetInstallabilityErrorsResult;
              };
              /**
               * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
               * @deprecated
               */
              getManifestIcons: {
                  params: Page.GetManifestIconsParams;
                  result: Page.GetManifestIconsResult;
              };
              /**
               * Returns the unique (PWA) app id.
               * Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
               */
              getAppId: {
                  params: Page.GetAppIdParams;
                  result: Page.GetAppIdResult;
              };
              getAdScriptId: {
                  params: Page.GetAdScriptIdParams;
                  result: Page.GetAdScriptIdResult;
              };
              /**
               * Returns present frame tree structure.
               */
              getFrameTree: {
                  params: Page.GetFrameTreeParams;
                  result: Page.GetFrameTreeResult;
              };
              /**
               * Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
               */
              getLayoutMetrics: {
                  params: Page.GetLayoutMetricsParams;
                  result: Page.GetLayoutMetricsResult;
              };
              /**
               * Returns navigation history for the current page.
               */
              getNavigationHistory: {
                  params: Page.GetNavigationHistoryParams;
                  result: Page.GetNavigationHistoryResult;
              };
              /**
               * Resets navigation history for the current page.
               */
              resetNavigationHistory: {
                  params: Page.ResetNavigationHistoryParams;
                  result: Page.ResetNavigationHistoryResult;
              };
              /**
               * Returns content of the given resource.
               */
              getResourceContent: {
                  params: Page.GetResourceContentParams;
                  result: Page.GetResourceContentResult;
              };
              /**
               * Returns present frame / resource tree structure.
               */
              getResourceTree: {
                  params: Page.GetResourceTreeParams;
                  result: Page.GetResourceTreeResult;
              };
              /**
               * Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
               */
              handleJavaScriptDialog: {
                  params: Page.HandleJavaScriptDialogParams;
                  result: Page.HandleJavaScriptDialogResult;
              };
              /**
               * Navigates current page to the given URL.
               */
              navigate: {
                  params: Page.NavigateParams;
                  result: Page.NavigateResult;
              };
              /**
               * Navigates current page to the given history entry.
               */
              navigateToHistoryEntry: {
                  params: Page.NavigateToHistoryEntryParams;
                  result: Page.NavigateToHistoryEntryResult;
              };
              /**
               * Print page as PDF.
               */
              printToPDF: {
                  params: Page.PrintToPDFParams;
                  result: Page.PrintToPDFResult;
              };
              /**
               * Reloads given page optionally ignoring the cache.
               */
              reload: {
                  params: Page.ReloadParams;
                  result: Page.ReloadResult;
              };
              /**
               * Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
               * @deprecated
               */
              removeScriptToEvaluateOnLoad: {
                  params: Page.RemoveScriptToEvaluateOnLoadParams;
                  result: Page.RemoveScriptToEvaluateOnLoadResult;
              };
              /**
               * Removes given script from the list.
               */
              removeScriptToEvaluateOnNewDocument: {
                  params: Page.RemoveScriptToEvaluateOnNewDocumentParams;
                  result: Page.RemoveScriptToEvaluateOnNewDocumentResult;
              };
              /**
               * Acknowledges that a screencast frame has been received by the frontend.
               */
              screencastFrameAck: {
                  params: Page.ScreencastFrameAckParams;
                  result: Page.ScreencastFrameAckResult;
              };
              /**
               * Searches for given string in resource content.
               */
              searchInResource: {
                  params: Page.SearchInResourceParams;
                  result: Page.SearchInResourceResult;
              };
              /**
               * Enable Chrome's experimental ad filter on all sites.
               */
              setAdBlockingEnabled: {
                  params: Page.SetAdBlockingEnabledParams;
                  result: Page.SetAdBlockingEnabledResult;
              };
              /**
               * Enable page Content Security Policy by-passing.
               */
              setBypassCSP: {
                  params: Page.SetBypassCSPParams;
                  result: Page.SetBypassCSPResult;
              };
              /**
               * Get Permissions Policy state on given frame.
               */
              getPermissionsPolicyState: {
                  params: Page.GetPermissionsPolicyStateParams;
                  result: Page.GetPermissionsPolicyStateResult;
              };
              /**
               * Get Origin Trials on given frame.
               */
              getOriginTrials: {
                  params: Page.GetOriginTrialsParams;
                  result: Page.GetOriginTrialsResult;
              };
              /**
               * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
               * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
               * query results).
               * @deprecated
               */
              setDeviceMetricsOverride: {
                  params: Page.SetDeviceMetricsOverrideParams;
                  result: Page.SetDeviceMetricsOverrideResult;
              };
              /**
               * Overrides the Device Orientation.
               * @deprecated
               */
              setDeviceOrientationOverride: {
                  params: Page.SetDeviceOrientationOverrideParams;
                  result: Page.SetDeviceOrientationOverrideResult;
              };
              /**
               * Set generic font families.
               */
              setFontFamilies: {
                  params: Page.SetFontFamiliesParams;
                  result: Page.SetFontFamiliesResult;
              };
              /**
               * Set default font sizes.
               */
              setFontSizes: {
                  params: Page.SetFontSizesParams;
                  result: Page.SetFontSizesResult;
              };
              /**
               * Sets given markup as the document's HTML.
               */
              setDocumentContent: {
                  params: Page.SetDocumentContentParams;
                  result: Page.SetDocumentContentResult;
              };
              /**
               * Set the behavior when downloading a file.
               * @deprecated
               */
              setDownloadBehavior: {
                  params: Page.SetDownloadBehaviorParams;
                  result: Page.SetDownloadBehaviorResult;
              };
              /**
               * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
               * unavailable.
               * @deprecated
               */
              setGeolocationOverride: {
                  params: Page.SetGeolocationOverrideParams;
                  result: Page.SetGeolocationOverrideResult;
              };
              /**
               * Controls whether page will emit lifecycle events.
               */
              setLifecycleEventsEnabled: {
                  params: Page.SetLifecycleEventsEnabledParams;
                  result: Page.SetLifecycleEventsEnabledResult;
              };
              /**
               * Toggles mouse event-based touch event emulation.
               * @deprecated
               */
              setTouchEmulationEnabled: {
                  params: Page.SetTouchEmulationEnabledParams;
                  result: Page.SetTouchEmulationEnabledResult;
              };
              /**
               * Starts sending each frame using the `screencastFrame` event.
               */
              startScreencast: {
                  params: Page.StartScreencastParams;
                  result: Page.StartScreencastResult;
              };
              /**
               * Force the page stop all navigations and pending resource fetches.
               */
              stopLoading: {
                  params: Page.StopLoadingParams;
                  result: Page.StopLoadingResult;
              };
              /**
               * Crashes renderer on the IO thread, generates minidumps.
               */
              crash: {
                  params: Page.CrashParams;
                  result: Page.CrashResult;
              };
              /**
               * Tries to close page, running its beforeunload hooks, if any.
               */
              close: {
                  params: Page.CloseParams;
                  result: Page.CloseResult;
              };
              /**
               * Tries to update the web lifecycle state of the page.
               * It will transition the page to the given state according to:
               * https://github.com/WICG/web-lifecycle/
               */
              setWebLifecycleState: {
                  params: Page.SetWebLifecycleStateParams;
                  result: Page.SetWebLifecycleStateResult;
              };
              /**
               * Stops sending each frame in the `screencastFrame`.
               */
              stopScreencast: {
                  params: Page.StopScreencastParams;
                  result: Page.StopScreencastResult;
              };
              /**
               * Requests backend to produce compilation cache for the specified scripts.
               * `scripts` are appeneded to the list of scripts for which the cache
               * would be produced. The list may be reset during page navigation.
               * When script with a matching URL is encountered, the cache is optionally
               * produced upon backend discretion, based on internal heuristics.
               * See also: `Page.compilationCacheProduced`.
               */
              produceCompilationCache: {
                  params: Page.ProduceCompilationCacheParams;
                  result: Page.ProduceCompilationCacheResult;
              };
              /**
               * Seeds compilation cache for given url. Compilation cache does not survive
               * cross-process navigation.
               */
              addCompilationCache: {
                  params: Page.AddCompilationCacheParams;
                  result: Page.AddCompilationCacheResult;
              };
              /**
               * Clears seeded compilation cache.
               */
              clearCompilationCache: {
                  params: Page.ClearCompilationCacheParams;
                  result: Page.ClearCompilationCacheResult;
              };
              /**
               * Sets the Secure Payment Confirmation transaction mode.
               * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
               */
              setSPCTransactionMode: {
                  params: Page.SetSPCTransactionModeParams;
                  result: Page.SetSPCTransactionModeResult;
              };
              /**
               * Extensions for Custom Handlers API:
               * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
               */
              setRPHRegistrationMode: {
                  params: Page.SetRPHRegistrationModeParams;
                  result: Page.SetRPHRegistrationModeResult;
              };
              /**
               * Generates a report for testing.
               */
              generateTestReport: {
                  params: Page.GenerateTestReportParams;
                  result: Page.GenerateTestReportResult;
              };
              /**
               * Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
               */
              waitForDebugger: {
                  params: Page.WaitForDebuggerParams;
                  result: Page.WaitForDebuggerResult;
              };
              /**
               * Intercept file chooser requests and transfer control to protocol clients.
               * When file chooser interception is enabled, native file chooser dialog is not shown.
               * Instead, a protocol event `Page.fileChooserOpened` is emitted.
               */
              setInterceptFileChooserDialog: {
                  params: Page.SetInterceptFileChooserDialogParams;
                  result: Page.SetInterceptFileChooserDialogResult;
              };
              /**
               * Enable/disable prerendering manually.
               *
               * This command is a short-term solution for https://crbug.com/1440085.
               * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
               * for more details.
               *
               * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
               */
              setPrerenderingAllowed: {
                  params: Page.SetPrerenderingAllowedParams;
                  result: Page.SetPrerenderingAllowedResult;
              };
          };
          events: {
              domContentEventFired: {
                  params: Page.DomContentEventFiredEvent;
              };
              /**
               * Emitted only when `page.interceptFileChooser` is enabled.
               */
              fileChooserOpened: {
                  params: Page.FileChooserOpenedEvent;
              };
              /**
               * Fired when frame has been attached to its parent.
               */
              frameAttached: {
                  params: Page.FrameAttachedEvent;
              };
              /**
               * Fired when frame no longer has a scheduled navigation.
               * @deprecated
               */
              frameClearedScheduledNavigation: {
                  params: Page.FrameClearedScheduledNavigationEvent;
              };
              /**
               * Fired when frame has been detached from its parent.
               */
              frameDetached: {
                  params: Page.FrameDetachedEvent;
              };
              /**
               * Fired once navigation of the frame has completed. Frame is now associated with the new loader.
               */
              frameNavigated: {
                  params: Page.FrameNavigatedEvent;
              };
              /**
               * Fired when opening document to write to.
               */
              documentOpened: {
                  params: Page.DocumentOpenedEvent;
              };
              frameResized: {
                  params: Page.FrameResizedEvent;
              };
              /**
               * Fired when a renderer-initiated navigation is requested.
               * Navigation may still be cancelled after the event is issued.
               */
              frameRequestedNavigation: {
                  params: Page.FrameRequestedNavigationEvent;
              };
              /**
               * Fired when frame schedules a potential navigation.
               * @deprecated
               */
              frameScheduledNavigation: {
                  params: Page.FrameScheduledNavigationEvent;
              };
              /**
               * Fired when frame has started loading.
               */
              frameStartedLoading: {
                  params: Page.FrameStartedLoadingEvent;
              };
              /**
               * Fired when frame has stopped loading.
               */
              frameStoppedLoading: {
                  params: Page.FrameStoppedLoadingEvent;
              };
              /**
               * Fired when page is about to start a download.
               * Deprecated. Use Browser.downloadWillBegin instead.
               * @deprecated
               */
              downloadWillBegin: {
                  params: Page.DownloadWillBeginEvent;
              };
              /**
               * Fired when download makes progress. Last call has |done| == true.
               * Deprecated. Use Browser.downloadProgress instead.
               * @deprecated
               */
              downloadProgress: {
                  params: Page.DownloadProgressEvent;
              };
              /**
               * Fired when interstitial page was hidden
               */
              interstitialHidden: {
                  params: Page.InterstitialHiddenEvent;
              };
              /**
               * Fired when interstitial page was shown
               */
              interstitialShown: {
                  params: Page.InterstitialShownEvent;
              };
              /**
               * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
               * closed.
               */
              javascriptDialogClosed: {
                  params: Page.JavascriptDialogClosedEvent;
              };
              /**
               * Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
               * open.
               */
              javascriptDialogOpening: {
                  params: Page.JavascriptDialogOpeningEvent;
              };
              /**
               * Fired for top level page lifecycle events such as navigation, load, paint, etc.
               */
              lifecycleEvent: {
                  params: Page.LifecycleEventEvent;
              };
              /**
               * Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
               * not assume any ordering with the Page.frameNavigated event. This event is fired only for
               * main-frame history navigation where the document changes (non-same-document navigations),
               * when bfcache navigation fails.
               */
              backForwardCacheNotUsed: {
                  params: Page.BackForwardCacheNotUsedEvent;
              };
              loadEventFired: {
                  params: Page.LoadEventFiredEvent;
              };
              /**
               * Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
               */
              navigatedWithinDocument: {
                  params: Page.NavigatedWithinDocumentEvent;
              };
              /**
               * Compressed image data requested by the `startScreencast`.
               */
              screencastFrame: {
                  params: Page.ScreencastFrameEvent;
              };
              /**
               * Fired when the page with currently enabled screencast was shown or hidden `.
               */
              screencastVisibilityChanged: {
                  params: Page.ScreencastVisibilityChangedEvent;
              };
              /**
               * Fired when a new window is going to be opened, via window.open(), link click, form submission,
               * etc.
               */
              windowOpen: {
                  params: Page.WindowOpenEvent;
              };
              /**
               * Issued for every compilation cache generated. Is only available
               * if Page.setGenerateCompilationCache is enabled.
               */
              compilationCacheProduced: {
                  params: Page.CompilationCacheProducedEvent;
              };
          };
      }
      /**
       * Types of the 'Page' domain.
       */
      namespace Page {
          /**
           * Parameters of the 'Page.addScriptToEvaluateOnLoad' method.
           */
          interface AddScriptToEvaluateOnLoadParams {
              scriptSource: string;
          }
          /**
           * Return value of the 'Page.addScriptToEvaluateOnLoad' method.
           */
          interface AddScriptToEvaluateOnLoadResult {
              /**
               * Identifier of the added script.
               */
              identifier: ScriptIdentifier;
          }
          /**
           * Parameters of the 'Page.addScriptToEvaluateOnNewDocument' method.
           */
          interface AddScriptToEvaluateOnNewDocumentParams {
              source: string;
              /**
               * If specified, creates an isolated world with the given name and evaluates given script in it.
               * This world name will be used as the ExecutionContextDescription::name when the corresponding
               * event is emitted.
               */
              worldName?: string;
              /**
               * Specifies whether command line API should be available to the script, defaults
               * to false.
               */
              includeCommandLineAPI?: boolean;
              /**
               * If true, runs the script immediately on existing execution contexts or worlds.
               * Default: false.
               */
              runImmediately?: boolean;
          }
          /**
           * Return value of the 'Page.addScriptToEvaluateOnNewDocument' method.
           */
          interface AddScriptToEvaluateOnNewDocumentResult {
              /**
               * Identifier of the added script.
               */
              identifier: ScriptIdentifier;
          }
          /**
           * Parameters of the 'Page.bringToFront' method.
           */
          interface BringToFrontParams {
          }
          /**
           * Return value of the 'Page.bringToFront' method.
           */
          interface BringToFrontResult {
          }
          /**
           * Parameters of the 'Page.captureScreenshot' method.
           */
          interface CaptureScreenshotParams {
              /**
               * Image compression format (defaults to png).
               */
              format?: 'jpeg' | 'png' | 'webp';
              /**
               * Compression quality from range [0..100] (jpeg only).
               */
              quality?: integer;
              /**
               * Capture the screenshot of a given region only.
               */
              clip?: Viewport;
              /**
               * Capture the screenshot from the surface, rather than the view. Defaults to true.
               */
              fromSurface?: boolean;
              /**
               * Capture the screenshot beyond the viewport. Defaults to false.
               */
              captureBeyondViewport?: boolean;
              /**
               * Optimize image encoding for speed, not for resulting size (defaults to false)
               */
              optimizeForSpeed?: boolean;
          }
          /**
           * Return value of the 'Page.captureScreenshot' method.
           */
          interface CaptureScreenshotResult {
              /**
               * Base64-encoded image data. (Encoded as a base64 string when passed over JSON)
               */
              data: string;
          }
          /**
           * Parameters of the 'Page.captureSnapshot' method.
           */
          interface CaptureSnapshotParams {
              /**
               * Format (defaults to mhtml).
               */
              format?: 'mhtml';
          }
          /**
           * Return value of the 'Page.captureSnapshot' method.
           */
          interface CaptureSnapshotResult {
              /**
               * Serialized page data.
               */
              data: string;
          }
          /**
           * Parameters of the 'Page.clearDeviceMetricsOverride' method.
           */
          interface ClearDeviceMetricsOverrideParams {
          }
          /**
           * Return value of the 'Page.clearDeviceMetricsOverride' method.
           */
          interface ClearDeviceMetricsOverrideResult {
          }
          /**
           * Parameters of the 'Page.clearDeviceOrientationOverride' method.
           */
          interface ClearDeviceOrientationOverrideParams {
          }
          /**
           * Return value of the 'Page.clearDeviceOrientationOverride' method.
           */
          interface ClearDeviceOrientationOverrideResult {
          }
          /**
           * Parameters of the 'Page.clearGeolocationOverride' method.
           */
          interface ClearGeolocationOverrideParams {
          }
          /**
           * Return value of the 'Page.clearGeolocationOverride' method.
           */
          interface ClearGeolocationOverrideResult {
          }
          /**
           * Parameters of the 'Page.createIsolatedWorld' method.
           */
          interface CreateIsolatedWorldParams {
              /**
               * Id of the frame in which the isolated world should be created.
               */
              frameId: FrameId;
              /**
               * An optional name which is reported in the Execution Context.
               */
              worldName?: string;
              /**
               * Whether or not universal access should be granted to the isolated world. This is a powerful
               * option, use with caution.
               */
              grantUniveralAccess?: boolean;
          }
          /**
           * Return value of the 'Page.createIsolatedWorld' method.
           */
          interface CreateIsolatedWorldResult {
              /**
               * Execution context of the isolated world.
               */
              executionContextId: CdpV8.Runtime.ExecutionContextId;
          }
          /**
           * Parameters of the 'Page.deleteCookie' method.
           */
          interface DeleteCookieParams {
              /**
               * Name of the cookie to remove.
               */
              cookieName: string;
              /**
               * URL to match cooke domain and path.
               */
              url: string;
          }
          /**
           * Return value of the 'Page.deleteCookie' method.
           */
          interface DeleteCookieResult {
          }
          /**
           * Parameters of the 'Page.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Page.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Page.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Page.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Page.getAppManifest' method.
           */
          interface GetAppManifestParams {
          }
          /**
           * Return value of the 'Page.getAppManifest' method.
           */
          interface GetAppManifestResult {
              /**
               * Manifest location.
               */
              url: string;
              errors: AppManifestError[];
              /**
               * Manifest content.
               */
              data?: string;
              /**
               * Parsed manifest properties
               */
              parsed?: AppManifestParsedProperties;
          }
          /**
           * Parameters of the 'Page.getInstallabilityErrors' method.
           */
          interface GetInstallabilityErrorsParams {
          }
          /**
           * Return value of the 'Page.getInstallabilityErrors' method.
           */
          interface GetInstallabilityErrorsResult {
              installabilityErrors: InstallabilityError[];
          }
          /**
           * Parameters of the 'Page.getManifestIcons' method.
           */
          interface GetManifestIconsParams {
          }
          /**
           * Return value of the 'Page.getManifestIcons' method.
           */
          interface GetManifestIconsResult {
              primaryIcon?: string;
          }
          /**
           * Parameters of the 'Page.getAppId' method.
           */
          interface GetAppIdParams {
          }
          /**
           * Return value of the 'Page.getAppId' method.
           */
          interface GetAppIdResult {
              /**
               * App id, either from manifest's id attribute or computed from start_url
               */
              appId?: string;
              /**
               * Recommendation for manifest's id attribute to match current id computed from start_url
               */
              recommendedId?: string;
          }
          /**
           * Parameters of the 'Page.getAdScriptId' method.
           */
          interface GetAdScriptIdParams {
              frameId: FrameId;
          }
          /**
           * Return value of the 'Page.getAdScriptId' method.
           */
          interface GetAdScriptIdResult {
              /**
               * Identifies the bottom-most script which caused the frame to be labelled
               * as an ad. Only sent if frame is labelled as an ad and id is available.
               */
              adScriptId?: AdScriptId;
          }
          /**
           * Parameters of the 'Page.getFrameTree' method.
           */
          interface GetFrameTreeParams {
          }
          /**
           * Return value of the 'Page.getFrameTree' method.
           */
          interface GetFrameTreeResult {
              /**
               * Present frame tree structure.
               */
              frameTree: FrameTree;
          }
          /**
           * Parameters of the 'Page.getLayoutMetrics' method.
           */
          interface GetLayoutMetricsParams {
          }
          /**
           * Return value of the 'Page.getLayoutMetrics' method.
           */
          interface GetLayoutMetricsResult {
              /**
               * Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
               * @deprecated
               */
              layoutViewport: LayoutViewport;
              /**
               * Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
               * @deprecated
               */
              visualViewport: VisualViewport;
              /**
               * Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
               * @deprecated
               */
              contentSize: DOM.Rect;
              /**
               * Metrics relating to the layout viewport in CSS pixels.
               */
              cssLayoutViewport: LayoutViewport;
              /**
               * Metrics relating to the visual viewport in CSS pixels.
               */
              cssVisualViewport: VisualViewport;
              /**
               * Size of scrollable area in CSS pixels.
               */
              cssContentSize: DOM.Rect;
          }
          /**
           * Parameters of the 'Page.getNavigationHistory' method.
           */
          interface GetNavigationHistoryParams {
          }
          /**
           * Return value of the 'Page.getNavigationHistory' method.
           */
          interface GetNavigationHistoryResult {
              /**
               * Index of the current navigation history entry.
               */
              currentIndex: integer;
              /**
               * Array of navigation history entries.
               */
              entries: NavigationEntry[];
          }
          /**
           * Parameters of the 'Page.resetNavigationHistory' method.
           */
          interface ResetNavigationHistoryParams {
          }
          /**
           * Return value of the 'Page.resetNavigationHistory' method.
           */
          interface ResetNavigationHistoryResult {
          }
          /**
           * Parameters of the 'Page.getResourceContent' method.
           */
          interface GetResourceContentParams {
              /**
               * Frame id to get resource for.
               */
              frameId: FrameId;
              /**
               * URL of the resource to get content for.
               */
              url: string;
          }
          /**
           * Return value of the 'Page.getResourceContent' method.
           */
          interface GetResourceContentResult {
              /**
               * Resource content.
               */
              content: string;
              /**
               * True, if content was served as base64.
               */
              base64Encoded: boolean;
          }
          /**
           * Parameters of the 'Page.getResourceTree' method.
           */
          interface GetResourceTreeParams {
          }
          /**
           * Return value of the 'Page.getResourceTree' method.
           */
          interface GetResourceTreeResult {
              /**
               * Present frame / resource tree structure.
               */
              frameTree: FrameResourceTree;
          }
          /**
           * Parameters of the 'Page.handleJavaScriptDialog' method.
           */
          interface HandleJavaScriptDialogParams {
              /**
               * Whether to accept or dismiss the dialog.
               */
              accept: boolean;
              /**
               * The text to enter into the dialog prompt before accepting. Used only if this is a prompt
               * dialog.
               */
              promptText?: string;
          }
          /**
           * Return value of the 'Page.handleJavaScriptDialog' method.
           */
          interface HandleJavaScriptDialogResult {
          }
          /**
           * Parameters of the 'Page.navigate' method.
           */
          interface NavigateParams {
              /**
               * URL to navigate the page to.
               */
              url: string;
              /**
               * Referrer URL.
               */
              referrer?: string;
              /**
               * Intended transition type.
               */
              transitionType?: TransitionType;
              /**
               * Frame id to navigate, if not specified navigates the top frame.
               */
              frameId?: FrameId;
              /**
               * Referrer-policy used for the navigation.
               */
              referrerPolicy?: ReferrerPolicy;
          }
          /**
           * Return value of the 'Page.navigate' method.
           */
          interface NavigateResult {
              /**
               * Frame id that has navigated (or failed to navigate)
               */
              frameId: FrameId;
              /**
               * Loader identifier. This is omitted in case of same-document navigation,
               * as the previously committed loaderId would not change.
               */
              loaderId?: Network.LoaderId;
              /**
               * User friendly error message, present if and only if navigation has failed.
               */
              errorText?: string;
          }
          /**
           * Parameters of the 'Page.navigateToHistoryEntry' method.
           */
          interface NavigateToHistoryEntryParams {
              /**
               * Unique id of the entry to navigate to.
               */
              entryId: integer;
          }
          /**
           * Return value of the 'Page.navigateToHistoryEntry' method.
           */
          interface NavigateToHistoryEntryResult {
          }
          /**
           * Parameters of the 'Page.printToPDF' method.
           */
          interface PrintToPDFParams {
              /**
               * Paper orientation. Defaults to false.
               */
              landscape?: boolean;
              /**
               * Display header and footer. Defaults to false.
               */
              displayHeaderFooter?: boolean;
              /**
               * Print background graphics. Defaults to false.
               */
              printBackground?: boolean;
              /**
               * Scale of the webpage rendering. Defaults to 1.
               */
              scale?: number;
              /**
               * Paper width in inches. Defaults to 8.5 inches.
               */
              paperWidth?: number;
              /**
               * Paper height in inches. Defaults to 11 inches.
               */
              paperHeight?: number;
              /**
               * Top margin in inches. Defaults to 1cm (~0.4 inches).
               */
              marginTop?: number;
              /**
               * Bottom margin in inches. Defaults to 1cm (~0.4 inches).
               */
              marginBottom?: number;
              /**
               * Left margin in inches. Defaults to 1cm (~0.4 inches).
               */
              marginLeft?: number;
              /**
               * Right margin in inches. Defaults to 1cm (~0.4 inches).
               */
              marginRight?: number;
              /**
               * Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
               * printed in the document order, not in the order specified, and no
               * more than once.
               * Defaults to empty string, which implies the entire document is printed.
               * The page numbers are quietly capped to actual page count of the
               * document, and ranges beyond the end of the document are ignored.
               * If this results in no pages to print, an error is reported.
               * It is an error to specify a range with start greater than end.
               */
              pageRanges?: string;
              /**
               * HTML template for the print header. Should be valid HTML markup with following
               * classes used to inject printing values into them:
               * - `date`: formatted print date
               * - `title`: document title
               * - `url`: document location
               * - `pageNumber`: current page number
               * - `totalPages`: total pages in the document
               *
               * For example, `<span class=title></span>` would generate span containing the title.
               */
              headerTemplate?: string;
              /**
               * HTML template for the print footer. Should use the same format as the `headerTemplate`.
               */
              footerTemplate?: string;
              /**
               * Whether or not to prefer page size as defined by css. Defaults to false,
               * in which case the content will be scaled to fit the paper size.
               */
              preferCSSPageSize?: boolean;
              /**
               * return as stream
               */
              transferMode?: 'ReturnAsBase64' | 'ReturnAsStream';
              /**
               * Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
               */
              generateTaggedPDF?: boolean;
              /**
               * Whether or not to embed the document outline into the PDF.
               */
              generateDocumentOutline?: boolean;
          }
          /**
           * Return value of the 'Page.printToPDF' method.
           */
          interface PrintToPDFResult {
              /**
               * Base64-encoded pdf data. Empty if |returnAsStream| is specified. (Encoded as a base64 string when passed over JSON)
               */
              data: string;
              /**
               * A handle of the stream that holds resulting PDF data.
               */
              stream?: IO.StreamHandle;
          }
          /**
           * Parameters of the 'Page.reload' method.
           */
          interface ReloadParams {
              /**
               * If true, browser cache is ignored (as if the user pressed Shift+refresh).
               */
              ignoreCache?: boolean;
              /**
               * If set, the script will be injected into all frames of the inspected page after reload.
               * Argument will be ignored if reloading dataURL origin.
               */
              scriptToEvaluateOnLoad?: string;
          }
          /**
           * Return value of the 'Page.reload' method.
           */
          interface ReloadResult {
          }
          /**
           * Parameters of the 'Page.removeScriptToEvaluateOnLoad' method.
           */
          interface RemoveScriptToEvaluateOnLoadParams {
              identifier: ScriptIdentifier;
          }
          /**
           * Return value of the 'Page.removeScriptToEvaluateOnLoad' method.
           */
          interface RemoveScriptToEvaluateOnLoadResult {
          }
          /**
           * Parameters of the 'Page.removeScriptToEvaluateOnNewDocument' method.
           */
          interface RemoveScriptToEvaluateOnNewDocumentParams {
              identifier: ScriptIdentifier;
          }
          /**
           * Return value of the 'Page.removeScriptToEvaluateOnNewDocument' method.
           */
          interface RemoveScriptToEvaluateOnNewDocumentResult {
          }
          /**
           * Parameters of the 'Page.screencastFrameAck' method.
           */
          interface ScreencastFrameAckParams {
              /**
               * Frame number.
               */
              sessionId: integer;
          }
          /**
           * Return value of the 'Page.screencastFrameAck' method.
           */
          interface ScreencastFrameAckResult {
          }
          /**
           * Parameters of the 'Page.searchInResource' method.
           */
          interface SearchInResourceParams {
              /**
               * Frame id for resource to search in.
               */
              frameId: FrameId;
              /**
               * URL of the resource to search in.
               */
              url: string;
              /**
               * String to search for.
               */
              query: string;
              /**
               * If true, search is case sensitive.
               */
              caseSensitive?: boolean;
              /**
               * If true, treats string parameter as regex.
               */
              isRegex?: boolean;
          }
          /**
           * Return value of the 'Page.searchInResource' method.
           */
          interface SearchInResourceResult {
              /**
               * List of search matches.
               */
              result: CdpV8.Debugger.SearchMatch[];
          }
          /**
           * Parameters of the 'Page.setAdBlockingEnabled' method.
           */
          interface SetAdBlockingEnabledParams {
              /**
               * Whether to block ads.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Page.setAdBlockingEnabled' method.
           */
          interface SetAdBlockingEnabledResult {
          }
          /**
           * Parameters of the 'Page.setBypassCSP' method.
           */
          interface SetBypassCSPParams {
              /**
               * Whether to bypass page CSP.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Page.setBypassCSP' method.
           */
          interface SetBypassCSPResult {
          }
          /**
           * Parameters of the 'Page.getPermissionsPolicyState' method.
           */
          interface GetPermissionsPolicyStateParams {
              frameId: FrameId;
          }
          /**
           * Return value of the 'Page.getPermissionsPolicyState' method.
           */
          interface GetPermissionsPolicyStateResult {
              states: PermissionsPolicyFeatureState[];
          }
          /**
           * Parameters of the 'Page.getOriginTrials' method.
           */
          interface GetOriginTrialsParams {
              frameId: FrameId;
          }
          /**
           * Return value of the 'Page.getOriginTrials' method.
           */
          interface GetOriginTrialsResult {
              originTrials: OriginTrial[];
          }
          /**
           * Parameters of the 'Page.setDeviceMetricsOverride' method.
           */
          interface SetDeviceMetricsOverrideParams {
              /**
               * Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
               */
              width: integer;
              /**
               * Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
               */
              height: integer;
              /**
               * Overriding device scale factor value. 0 disables the override.
               */
              deviceScaleFactor: number;
              /**
               * Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
               * autosizing and more.
               */
              mobile: boolean;
              /**
               * Scale to apply to resulting view image.
               */
              scale?: number;
              /**
               * Overriding screen width value in pixels (minimum 0, maximum 10000000).
               */
              screenWidth?: integer;
              /**
               * Overriding screen height value in pixels (minimum 0, maximum 10000000).
               */
              screenHeight?: integer;
              /**
               * Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
               */
              positionX?: integer;
              /**
               * Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
               */
              positionY?: integer;
              /**
               * Do not set visible view size, rely upon explicit setVisibleSize call.
               */
              dontSetVisibleSize?: boolean;
              /**
               * Screen orientation override.
               */
              screenOrientation?: Emulation.ScreenOrientation;
              /**
               * The viewport dimensions and scale. If not set, the override is cleared.
               */
              viewport?: Viewport;
          }
          /**
           * Return value of the 'Page.setDeviceMetricsOverride' method.
           */
          interface SetDeviceMetricsOverrideResult {
          }
          /**
           * Parameters of the 'Page.setDeviceOrientationOverride' method.
           */
          interface SetDeviceOrientationOverrideParams {
              /**
               * Mock alpha
               */
              alpha: number;
              /**
               * Mock beta
               */
              beta: number;
              /**
               * Mock gamma
               */
              gamma: number;
          }
          /**
           * Return value of the 'Page.setDeviceOrientationOverride' method.
           */
          interface SetDeviceOrientationOverrideResult {
          }
          /**
           * Parameters of the 'Page.setFontFamilies' method.
           */
          interface SetFontFamiliesParams {
              /**
               * Specifies font families to set. If a font family is not specified, it won't be changed.
               */
              fontFamilies: FontFamilies;
              /**
               * Specifies font families to set for individual scripts.
               */
              forScripts?: ScriptFontFamilies[];
          }
          /**
           * Return value of the 'Page.setFontFamilies' method.
           */
          interface SetFontFamiliesResult {
          }
          /**
           * Parameters of the 'Page.setFontSizes' method.
           */
          interface SetFontSizesParams {
              /**
               * Specifies font sizes to set. If a font size is not specified, it won't be changed.
               */
              fontSizes: FontSizes;
          }
          /**
           * Return value of the 'Page.setFontSizes' method.
           */
          interface SetFontSizesResult {
          }
          /**
           * Parameters of the 'Page.setDocumentContent' method.
           */
          interface SetDocumentContentParams {
              /**
               * Frame id to set HTML for.
               */
              frameId: FrameId;
              /**
               * HTML content to set.
               */
              html: string;
          }
          /**
           * Return value of the 'Page.setDocumentContent' method.
           */
          interface SetDocumentContentResult {
          }
          /**
           * Parameters of the 'Page.setDownloadBehavior' method.
           */
          interface SetDownloadBehaviorParams {
              /**
               * Whether to allow all or deny all download requests, or use default Chrome behavior if
               * available (otherwise deny).
               */
              behavior: 'deny' | 'allow' | 'default';
              /**
               * The default path to save downloaded files to. This is required if behavior is set to 'allow'
               */
              downloadPath?: string;
          }
          /**
           * Return value of the 'Page.setDownloadBehavior' method.
           */
          interface SetDownloadBehaviorResult {
          }
          /**
           * Parameters of the 'Page.setGeolocationOverride' method.
           */
          interface SetGeolocationOverrideParams {
              /**
               * Mock latitude
               */
              latitude?: number;
              /**
               * Mock longitude
               */
              longitude?: number;
              /**
               * Mock accuracy
               */
              accuracy?: number;
          }
          /**
           * Return value of the 'Page.setGeolocationOverride' method.
           */
          interface SetGeolocationOverrideResult {
          }
          /**
           * Parameters of the 'Page.setLifecycleEventsEnabled' method.
           */
          interface SetLifecycleEventsEnabledParams {
              /**
               * If true, starts emitting lifecycle events.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Page.setLifecycleEventsEnabled' method.
           */
          interface SetLifecycleEventsEnabledResult {
          }
          /**
           * Parameters of the 'Page.setTouchEmulationEnabled' method.
           */
          interface SetTouchEmulationEnabledParams {
              /**
               * Whether the touch event emulation should be enabled.
               */
              enabled: boolean;
              /**
               * Touch/gesture events configuration. Default: current platform.
               */
              configuration?: 'mobile' | 'desktop';
          }
          /**
           * Return value of the 'Page.setTouchEmulationEnabled' method.
           */
          interface SetTouchEmulationEnabledResult {
          }
          /**
           * Parameters of the 'Page.startScreencast' method.
           */
          interface StartScreencastParams {
              /**
               * Image compression format.
               */
              format?: 'jpeg' | 'png';
              /**
               * Compression quality from range [0..100].
               */
              quality?: integer;
              /**
               * Maximum screenshot width.
               */
              maxWidth?: integer;
              /**
               * Maximum screenshot height.
               */
              maxHeight?: integer;
              /**
               * Send every n-th frame.
               */
              everyNthFrame?: integer;
          }
          /**
           * Return value of the 'Page.startScreencast' method.
           */
          interface StartScreencastResult {
          }
          /**
           * Parameters of the 'Page.stopLoading' method.
           */
          interface StopLoadingParams {
          }
          /**
           * Return value of the 'Page.stopLoading' method.
           */
          interface StopLoadingResult {
          }
          /**
           * Parameters of the 'Page.crash' method.
           */
          interface CrashParams {
          }
          /**
           * Return value of the 'Page.crash' method.
           */
          interface CrashResult {
          }
          /**
           * Parameters of the 'Page.close' method.
           */
          interface CloseParams {
          }
          /**
           * Return value of the 'Page.close' method.
           */
          interface CloseResult {
          }
          /**
           * Parameters of the 'Page.setWebLifecycleState' method.
           */
          interface SetWebLifecycleStateParams {
              /**
               * Target lifecycle state
               */
              state: 'frozen' | 'active';
          }
          /**
           * Return value of the 'Page.setWebLifecycleState' method.
           */
          interface SetWebLifecycleStateResult {
          }
          /**
           * Parameters of the 'Page.stopScreencast' method.
           */
          interface StopScreencastParams {
          }
          /**
           * Return value of the 'Page.stopScreencast' method.
           */
          interface StopScreencastResult {
          }
          /**
           * Parameters of the 'Page.produceCompilationCache' method.
           */
          interface ProduceCompilationCacheParams {
              scripts: CompilationCacheParams[];
          }
          /**
           * Return value of the 'Page.produceCompilationCache' method.
           */
          interface ProduceCompilationCacheResult {
          }
          /**
           * Parameters of the 'Page.addCompilationCache' method.
           */
          interface AddCompilationCacheParams {
              url: string;
              /**
               * Base64-encoded data (Encoded as a base64 string when passed over JSON)
               */
              data: string;
          }
          /**
           * Return value of the 'Page.addCompilationCache' method.
           */
          interface AddCompilationCacheResult {
          }
          /**
           * Parameters of the 'Page.clearCompilationCache' method.
           */
          interface ClearCompilationCacheParams {
          }
          /**
           * Return value of the 'Page.clearCompilationCache' method.
           */
          interface ClearCompilationCacheResult {
          }
          /**
           * Parameters of the 'Page.setSPCTransactionMode' method.
           */
          interface SetSPCTransactionModeParams {
              mode: AutoResponseMode;
          }
          /**
           * Return value of the 'Page.setSPCTransactionMode' method.
           */
          interface SetSPCTransactionModeResult {
          }
          /**
           * Parameters of the 'Page.setRPHRegistrationMode' method.
           */
          interface SetRPHRegistrationModeParams {
              mode: AutoResponseMode;
          }
          /**
           * Return value of the 'Page.setRPHRegistrationMode' method.
           */
          interface SetRPHRegistrationModeResult {
          }
          /**
           * Parameters of the 'Page.generateTestReport' method.
           */
          interface GenerateTestReportParams {
              /**
               * Message to be displayed in the report.
               */
              message: string;
              /**
               * Specifies the endpoint group to deliver the report to.
               */
              group?: string;
          }
          /**
           * Return value of the 'Page.generateTestReport' method.
           */
          interface GenerateTestReportResult {
          }
          /**
           * Parameters of the 'Page.waitForDebugger' method.
           */
          interface WaitForDebuggerParams {
          }
          /**
           * Return value of the 'Page.waitForDebugger' method.
           */
          interface WaitForDebuggerResult {
          }
          /**
           * Parameters of the 'Page.setInterceptFileChooserDialog' method.
           */
          interface SetInterceptFileChooserDialogParams {
              enabled: boolean;
          }
          /**
           * Return value of the 'Page.setInterceptFileChooserDialog' method.
           */
          interface SetInterceptFileChooserDialogResult {
          }
          /**
           * Parameters of the 'Page.setPrerenderingAllowed' method.
           */
          interface SetPrerenderingAllowedParams {
              isAllowed: boolean;
          }
          /**
           * Return value of the 'Page.setPrerenderingAllowed' method.
           */
          interface SetPrerenderingAllowedResult {
          }
          /**
           * Parameters of the 'Page.domContentEventFired' event.
           */
          interface DomContentEventFiredEvent {
              timestamp: Network.MonotonicTime;
          }
          /**
           * Parameters of the 'Page.fileChooserOpened' event.
           */
          interface FileChooserOpenedEvent {
              /**
               * Id of the frame containing input node.
               */
              frameId: FrameId;
              /**
               * Input mode.
               */
              mode: 'selectSingle' | 'selectMultiple';
              /**
               * Input node id. Only present for file choosers opened via an `<input type="file">` element.
               */
              backendNodeId?: DOM.BackendNodeId;
          }
          /**
           * Parameters of the 'Page.frameAttached' event.
           */
          interface FrameAttachedEvent {
              /**
               * Id of the frame that has been attached.
               */
              frameId: FrameId;
              /**
               * Parent frame identifier.
               */
              parentFrameId: FrameId;
              /**
               * JavaScript stack trace of when frame was attached, only set if frame initiated from script.
               */
              stack?: CdpV8.Runtime.StackTrace;
          }
          /**
           * Parameters of the 'Page.frameClearedScheduledNavigation' event.
           */
          interface FrameClearedScheduledNavigationEvent {
              /**
               * Id of the frame that has cleared its scheduled navigation.
               */
              frameId: FrameId;
          }
          /**
           * Parameters of the 'Page.frameDetached' event.
           */
          interface FrameDetachedEvent {
              /**
               * Id of the frame that has been detached.
               */
              frameId: FrameId;
              reason: 'remove' | 'swap';
          }
          /**
           * Parameters of the 'Page.frameNavigated' event.
           */
          interface FrameNavigatedEvent {
              /**
               * Frame object.
               */
              frame: Frame;
              type: NavigationType;
          }
          /**
           * Parameters of the 'Page.documentOpened' event.
           */
          interface DocumentOpenedEvent {
              /**
               * Frame object.
               */
              frame: Frame;
          }
          /**
           * Parameters of the 'Page.frameResized' event.
           */
          interface FrameResizedEvent {
          }
          /**
           * Parameters of the 'Page.frameRequestedNavigation' event.
           */
          interface FrameRequestedNavigationEvent {
              /**
               * Id of the frame that is being navigated.
               */
              frameId: FrameId;
              /**
               * The reason for the navigation.
               */
              reason: ClientNavigationReason;
              /**
               * The destination URL for the requested navigation.
               */
              url: string;
              /**
               * The disposition for the navigation.
               */
              disposition: ClientNavigationDisposition;
          }
          /**
           * Parameters of the 'Page.frameScheduledNavigation' event.
           */
          interface FrameScheduledNavigationEvent {
              /**
               * Id of the frame that has scheduled a navigation.
               */
              frameId: FrameId;
              /**
               * Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
               * guaranteed to start.
               */
              delay: number;
              /**
               * The reason for the navigation.
               */
              reason: ClientNavigationReason;
              /**
               * The destination URL for the scheduled navigation.
               */
              url: string;
          }
          /**
           * Parameters of the 'Page.frameStartedLoading' event.
           */
          interface FrameStartedLoadingEvent {
              /**
               * Id of the frame that has started loading.
               */
              frameId: FrameId;
          }
          /**
           * Parameters of the 'Page.frameStoppedLoading' event.
           */
          interface FrameStoppedLoadingEvent {
              /**
               * Id of the frame that has stopped loading.
               */
              frameId: FrameId;
          }
          /**
           * Parameters of the 'Page.downloadWillBegin' event.
           */
          interface DownloadWillBeginEvent {
              /**
               * Id of the frame that caused download to begin.
               */
              frameId: FrameId;
              /**
               * Global unique identifier of the download.
               */
              guid: string;
              /**
               * URL of the resource being downloaded.
               */
              url: string;
              /**
               * Suggested file name of the resource (the actual name of the file saved on disk may differ).
               */
              suggestedFilename: string;
          }
          /**
           * Parameters of the 'Page.downloadProgress' event.
           */
          interface DownloadProgressEvent {
              /**
               * Global unique identifier of the download.
               */
              guid: string;
              /**
               * Total expected bytes to download.
               */
              totalBytes: number;
              /**
               * Total bytes received.
               */
              receivedBytes: number;
              /**
               * Download status.
               */
              state: 'inProgress' | 'completed' | 'canceled';
          }
          /**
           * Parameters of the 'Page.interstitialHidden' event.
           */
          interface InterstitialHiddenEvent {
          }
          /**
           * Parameters of the 'Page.interstitialShown' event.
           */
          interface InterstitialShownEvent {
          }
          /**
           * Parameters of the 'Page.javascriptDialogClosed' event.
           */
          interface JavascriptDialogClosedEvent {
              /**
               * Whether dialog was confirmed.
               */
              result: boolean;
              /**
               * User input in case of prompt.
               */
              userInput: string;
          }
          /**
           * Parameters of the 'Page.javascriptDialogOpening' event.
           */
          interface JavascriptDialogOpeningEvent {
              /**
               * Frame url.
               */
              url: string;
              /**
               * Message that will be displayed by the dialog.
               */
              message: string;
              /**
               * Dialog type.
               */
              type: DialogType;
              /**
               * True iff browser is capable showing or acting on the given dialog. When browser has no
               * dialog handler for given target, calling alert while Page domain is engaged will stall
               * the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
               */
              hasBrowserHandler: boolean;
              /**
               * Default dialog prompt.
               */
              defaultPrompt?: string;
          }
          /**
           * Parameters of the 'Page.lifecycleEvent' event.
           */
          interface LifecycleEventEvent {
              /**
               * Id of the frame.
               */
              frameId: FrameId;
              /**
               * Loader identifier. Empty string if the request is fetched from worker.
               */
              loaderId: Network.LoaderId;
              name: string;
              timestamp: Network.MonotonicTime;
          }
          /**
           * Parameters of the 'Page.backForwardCacheNotUsed' event.
           */
          interface BackForwardCacheNotUsedEvent {
              /**
               * The loader id for the associated navgation.
               */
              loaderId: Network.LoaderId;
              /**
               * The frame id of the associated frame.
               */
              frameId: FrameId;
              /**
               * Array of reasons why the page could not be cached. This must not be empty.
               */
              notRestoredExplanations: BackForwardCacheNotRestoredExplanation[];
              /**
               * Tree structure of reasons why the page could not be cached for each frame.
               */
              notRestoredExplanationsTree?: BackForwardCacheNotRestoredExplanationTree;
          }
          /**
           * Parameters of the 'Page.loadEventFired' event.
           */
          interface LoadEventFiredEvent {
              timestamp: Network.MonotonicTime;
          }
          /**
           * Parameters of the 'Page.navigatedWithinDocument' event.
           */
          interface NavigatedWithinDocumentEvent {
              /**
               * Id of the frame.
               */
              frameId: FrameId;
              /**
               * Frame's new url.
               */
              url: string;
          }
          /**
           * Parameters of the 'Page.screencastFrame' event.
           */
          interface ScreencastFrameEvent {
              /**
               * Base64-encoded compressed image. (Encoded as a base64 string when passed over JSON)
               */
              data: string;
              /**
               * Screencast frame metadata.
               */
              metadata: ScreencastFrameMetadata;
              /**
               * Frame number.
               */
              sessionId: integer;
          }
          /**
           * Parameters of the 'Page.screencastVisibilityChanged' event.
           */
          interface ScreencastVisibilityChangedEvent {
              /**
               * True if the page is visible.
               */
              visible: boolean;
          }
          /**
           * Parameters of the 'Page.windowOpen' event.
           */
          interface WindowOpenEvent {
              /**
               * The URL for the new window.
               */
              url: string;
              /**
               * Window name.
               */
              windowName: string;
              /**
               * An array of enabled window features.
               */
              windowFeatures: string[];
              /**
               * Whether or not it was triggered by user gesture.
               */
              userGesture: boolean;
          }
          /**
           * Parameters of the 'Page.compilationCacheProduced' event.
           */
          interface CompilationCacheProducedEvent {
              url: string;
              /**
               * Base64-encoded data (Encoded as a base64 string when passed over JSON)
               */
              data: string;
          }
          /**
           * Unique frame identifier.
           */
          type FrameId = string;
          /**
           * Indicates whether a frame has been identified as an ad.
           */
          type AdFrameType = 'none' | 'child' | 'root';
          type AdFrameExplanation = 'ParentIsAd' | 'CreatedByAdScript' | 'MatchedBlockingRule';
          /**
           * Indicates whether a frame has been identified as an ad and why.
           */
          interface AdFrameStatus {
              adFrameType: AdFrameType;
              explanations?: AdFrameExplanation[];
          }
          /**
           * Identifies the bottom-most script which caused the frame to be labelled
           * as an ad.
           */
          interface AdScriptId {
              /**
               * Script Id of the bottom-most script which caused the frame to be labelled
               * as an ad.
               */
              scriptId: CdpV8.Runtime.ScriptId;
              /**
               * Id of adScriptId's debugger.
               */
              debuggerId: CdpV8.Runtime.UniqueDebuggerId;
          }
          /**
           * Indicates whether the frame is a secure context and why it is the case.
           */
          type SecureContextType = 'Secure' | 'SecureLocalhost' | 'InsecureScheme' | 'InsecureAncestor';
          /**
           * Indicates whether the frame is cross-origin isolated and why it is the case.
           */
          type CrossOriginIsolatedContextType = 'Isolated' | 'NotIsolated' | 'NotIsolatedFeatureDisabled';
          type GatedAPIFeatures = 'SharedArrayBuffers' | 'SharedArrayBuffersTransferAllowed' | 'PerformanceMeasureMemory' | 'PerformanceProfile';
          /**
           * All Permissions Policy features. This enum should match the one defined
           * in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
           */
          type PermissionsPolicyFeature = 'accelerometer' | 'ambient-light-sensor' | 'attribution-reporting' | 'autoplay' | 'bluetooth' | 'browsing-topics' | 'camera' | 'captured-surface-control' | 'ch-dpr' | 'ch-device-memory' | 'ch-downlink' | 'ch-ect' | 'ch-prefers-color-scheme' | 'ch-prefers-reduced-motion' | 'ch-prefers-reduced-transparency' | 'ch-rtt' | 'ch-save-data' | 'ch-ua' | 'ch-ua-arch' | 'ch-ua-bitness' | 'ch-ua-platform' | 'ch-ua-model' | 'ch-ua-mobile' | 'ch-ua-form-factor' | 'ch-ua-full-version' | 'ch-ua-full-version-list' | 'ch-ua-platform-version' | 'ch-ua-wow64' | 'ch-viewport-height' | 'ch-viewport-width' | 'ch-width' | 'clipboard-read' | 'clipboard-write' | 'compute-pressure' | 'cross-origin-isolated' | 'direct-sockets' | 'display-capture' | 'document-domain' | 'encrypted-media' | 'execution-while-out-of-viewport' | 'execution-while-not-rendered' | 'focus-without-user-activation' | 'fullscreen' | 'frobulate' | 'gamepad' | 'geolocation' | 'gyroscope' | 'hid' | 'identity-credentials-get' | 'idle-detection' | 'interest-cohort' | 'join-ad-interest-group' | 'keyboard-map' | 'local-fonts' | 'magnetometer' | 'microphone' | 'midi' | 'otp-credentials' | 'payment' | 'picture-in-picture' | 'private-aggregation' | 'private-state-token-issuance' | 'private-state-token-redemption' | 'publickey-credentials-create' | 'publickey-credentials-get' | 'run-ad-auction' | 'screen-wake-lock' | 'serial' | 'shared-autofill' | 'shared-storage' | 'shared-storage-select-url' | 'smart-card' | 'storage-access' | 'sub-apps' | 'sync-xhr' | 'unload' | 'usb' | 'usb-unrestricted' | 'vertical-scroll' | 'web-printing' | 'web-share' | 'window-management' | 'window-placement' | 'xr-spatial-tracking';
          /**
           * Reason for a permissions policy feature to be disabled.
           */
          type PermissionsPolicyBlockReason = 'Header' | 'IframeAttribute' | 'InFencedFrameTree' | 'InIsolatedApp';
          interface PermissionsPolicyBlockLocator {
              frameId: FrameId;
              blockReason: PermissionsPolicyBlockReason;
          }
          interface PermissionsPolicyFeatureState {
              feature: PermissionsPolicyFeature;
              allowed: boolean;
              locator?: PermissionsPolicyBlockLocator;
          }
          /**
           * Origin Trial(https://www.chromium.org/blink/origin-trials) support.
           * Status for an Origin Trial token.
           */
          type OriginTrialTokenStatus = 'Success' | 'NotSupported' | 'Insecure' | 'Expired' | 'WrongOrigin' | 'InvalidSignature' | 'Malformed' | 'WrongVersion' | 'FeatureDisabled' | 'TokenDisabled' | 'FeatureDisabledForUser' | 'UnknownTrial';
          /**
           * Status for an Origin Trial.
           */
          type OriginTrialStatus = 'Enabled' | 'ValidTokenNotProvided' | 'OSNotSupported' | 'TrialNotAllowed';
          type OriginTrialUsageRestriction = 'None' | 'Subset';
          interface OriginTrialToken {
              origin: string;
              matchSubDomains: boolean;
              trialName: string;
              expiryTime: Network.TimeSinceEpoch;
              isThirdParty: boolean;
              usageRestriction: OriginTrialUsageRestriction;
          }
          interface OriginTrialTokenWithStatus {
              rawTokenText: string;
              /**
               * `parsedToken` is present only when the token is extractable and
               * parsable.
               */
              parsedToken?: OriginTrialToken;
              status: OriginTrialTokenStatus;
          }
          interface OriginTrial {
              trialName: string;
              status: OriginTrialStatus;
              tokensWithStatus: OriginTrialTokenWithStatus[];
          }
          /**
           * Information about the Frame on the page.
           */
          interface Frame {
              /**
               * Frame unique identifier.
               */
              id: FrameId;
              /**
               * Parent frame identifier.
               */
              parentId?: FrameId;
              /**
               * Identifier of the loader associated with this frame.
               */
              loaderId: Network.LoaderId;
              /**
               * Frame's name as specified in the tag.
               */
              name?: string;
              /**
               * Frame document's URL without fragment.
               */
              url: string;
              /**
               * Frame document's URL fragment including the '#'.
               */
              urlFragment?: string;
              /**
               * Frame document's registered domain, taking the public suffixes list into account.
               * Extracted from the Frame's url.
               * Example URLs: http://www.google.com/file.html -> "google.com"
               *               http://a.b.co.uk/file.html      -> "b.co.uk"
               */
              domainAndRegistry: string;
              /**
               * Frame document's security origin.
               */
              securityOrigin: string;
              /**
               * Frame document's mimeType as determined by the browser.
               */
              mimeType: string;
              /**
               * If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
               */
              unreachableUrl?: string;
              /**
               * Indicates whether this frame was tagged as an ad and why.
               */
              adFrameStatus?: AdFrameStatus;
              /**
               * Indicates whether the main document is a secure context and explains why that is the case.
               */
              secureContextType: SecureContextType;
              /**
               * Indicates whether this is a cross origin isolated context.
               */
              crossOriginIsolatedContextType: CrossOriginIsolatedContextType;
              /**
               * Indicated which gated APIs / features are available.
               */
              gatedAPIFeatures: GatedAPIFeatures[];
          }
          /**
           * Information about the Resource on the page.
           */
          interface FrameResource {
              /**
               * Resource URL.
               */
              url: string;
              /**
               * Type of this resource.
               */
              type: Network.ResourceType;
              /**
               * Resource mimeType as determined by the browser.
               */
              mimeType: string;
              /**
               * last-modified timestamp as reported by server.
               */
              lastModified?: Network.TimeSinceEpoch;
              /**
               * Resource content size.
               */
              contentSize?: number;
              /**
               * True if the resource failed to load.
               */
              failed?: boolean;
              /**
               * True if the resource was canceled during loading.
               */
              canceled?: boolean;
          }
          /**
           * Information about the Frame hierarchy along with their cached resources.
           */
          interface FrameResourceTree {
              /**
               * Frame information for this tree item.
               */
              frame: Frame;
              /**
               * Child frames.
               */
              childFrames?: FrameResourceTree[];
              /**
               * Information about frame resources.
               */
              resources: FrameResource[];
          }
          /**
           * Information about the Frame hierarchy.
           */
          interface FrameTree {
              /**
               * Frame information for this tree item.
               */
              frame: Frame;
              /**
               * Child frames.
               */
              childFrames?: FrameTree[];
          }
          /**
           * Unique script identifier.
           */
          type ScriptIdentifier = string;
          /**
           * Transition type.
           */
          type TransitionType = 'link' | 'typed' | 'address_bar' | 'auto_bookmark' | 'auto_subframe' | 'manual_subframe' | 'generated' | 'auto_toplevel' | 'form_submit' | 'reload' | 'keyword' | 'keyword_generated' | 'other';
          /**
           * Navigation history entry.
           */
          interface NavigationEntry {
              /**
               * Unique id of the navigation history entry.
               */
              id: integer;
              /**
               * URL of the navigation history entry.
               */
              url: string;
              /**
               * URL that the user typed in the url bar.
               */
              userTypedURL: string;
              /**
               * Title of the navigation history entry.
               */
              title: string;
              /**
               * Transition type.
               */
              transitionType: TransitionType;
          }
          /**
           * Screencast frame metadata.
           */
          interface ScreencastFrameMetadata {
              /**
               * Top offset in DIP.
               */
              offsetTop: number;
              /**
               * Page scale factor.
               */
              pageScaleFactor: number;
              /**
               * Device screen width in DIP.
               */
              deviceWidth: number;
              /**
               * Device screen height in DIP.
               */
              deviceHeight: number;
              /**
               * Position of horizontal scroll in CSS pixels.
               */
              scrollOffsetX: number;
              /**
               * Position of vertical scroll in CSS pixels.
               */
              scrollOffsetY: number;
              /**
               * Frame swap timestamp.
               */
              timestamp?: Network.TimeSinceEpoch;
          }
          /**
           * Javascript dialog type.
           */
          type DialogType = 'alert' | 'confirm' | 'prompt' | 'beforeunload';
          /**
           * Error while paring app manifest.
           */
          interface AppManifestError {
              /**
               * Error message.
               */
              message: string;
              /**
               * If criticial, this is a non-recoverable parse error.
               */
              critical: integer;
              /**
               * Error line.
               */
              line: integer;
              /**
               * Error column.
               */
              column: integer;
          }
          /**
           * Parsed app manifest properties.
           */
          interface AppManifestParsedProperties {
              /**
               * Computed scope value
               */
              scope: string;
          }
          /**
           * Layout viewport position and dimensions.
           */
          interface LayoutViewport {
              /**
               * Horizontal offset relative to the document (CSS pixels).
               */
              pageX: integer;
              /**
               * Vertical offset relative to the document (CSS pixels).
               */
              pageY: integer;
              /**
               * Width (CSS pixels), excludes scrollbar if present.
               */
              clientWidth: integer;
              /**
               * Height (CSS pixels), excludes scrollbar if present.
               */
              clientHeight: integer;
          }
          /**
           * Visual viewport position, dimensions, and scale.
           */
          interface VisualViewport {
              /**
               * Horizontal offset relative to the layout viewport (CSS pixels).
               */
              offsetX: number;
              /**
               * Vertical offset relative to the layout viewport (CSS pixels).
               */
              offsetY: number;
              /**
               * Horizontal offset relative to the document (CSS pixels).
               */
              pageX: number;
              /**
               * Vertical offset relative to the document (CSS pixels).
               */
              pageY: number;
              /**
               * Width (CSS pixels), excludes scrollbar if present.
               */
              clientWidth: number;
              /**
               * Height (CSS pixels), excludes scrollbar if present.
               */
              clientHeight: number;
              /**
               * Scale relative to the ideal viewport (size at width=device-width).
               */
              scale: number;
              /**
               * Page zoom factor (CSS to device independent pixels ratio).
               */
              zoom?: number;
          }
          /**
           * Viewport for capturing screenshot.
           */
          interface Viewport {
              /**
               * X offset in device independent pixels (dip).
               */
              x: number;
              /**
               * Y offset in device independent pixels (dip).
               */
              y: number;
              /**
               * Rectangle width in device independent pixels (dip).
               */
              width: number;
              /**
               * Rectangle height in device independent pixels (dip).
               */
              height: number;
              /**
               * Page scale factor.
               */
              scale: number;
          }
          /**
           * Generic font families collection.
           */
          interface FontFamilies {
              /**
               * The standard font-family.
               */
              standard?: string;
              /**
               * The fixed font-family.
               */
              fixed?: string;
              /**
               * The serif font-family.
               */
              serif?: string;
              /**
               * The sansSerif font-family.
               */
              sansSerif?: string;
              /**
               * The cursive font-family.
               */
              cursive?: string;
              /**
               * The fantasy font-family.
               */
              fantasy?: string;
              /**
               * The math font-family.
               */
              math?: string;
          }
          /**
           * Font families collection for a script.
           */
          interface ScriptFontFamilies {
              /**
               * Name of the script which these font families are defined for.
               */
              script: string;
              /**
               * Generic font families collection for the script.
               */
              fontFamilies: FontFamilies;
          }
          /**
           * Default font sizes.
           */
          interface FontSizes {
              /**
               * Default standard font size.
               */
              standard?: integer;
              /**
               * Default fixed font size.
               */
              fixed?: integer;
          }
          type ClientNavigationReason = 'formSubmissionGet' | 'formSubmissionPost' | 'httpHeaderRefresh' | 'scriptInitiated' | 'metaTagRefresh' | 'pageBlockInterstitial' | 'reload' | 'anchorClick';
          type ClientNavigationDisposition = 'currentTab' | 'newTab' | 'newWindow' | 'download';
          interface InstallabilityErrorArgument {
              /**
               * Argument name (e.g. name:'minimum-icon-size-in-pixels').
               */
              name: string;
              /**
               * Argument value (e.g. value:'64').
               */
              value: string;
          }
          /**
           * The installability error
           */
          interface InstallabilityError {
              /**
               * The error id (e.g. 'manifest-missing-suitable-icon').
               */
              errorId: string;
              /**
               * The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
               */
              errorArguments: InstallabilityErrorArgument[];
          }
          /**
           * The referring-policy used for the navigation.
           */
          type ReferrerPolicy = 'noReferrer' | 'noReferrerWhenDowngrade' | 'origin' | 'originWhenCrossOrigin' | 'sameOrigin' | 'strictOrigin' | 'strictOriginWhenCrossOrigin' | 'unsafeUrl';
          /**
           * Per-script compilation cache parameters for `Page.produceCompilationCache`
           */
          interface CompilationCacheParams {
              /**
               * The URL of the script to produce a compilation cache entry for.
               */
              url: string;
              /**
               * A hint to the backend whether eager compilation is recommended.
               * (the actual compilation mode used is upon backend discretion).
               */
              eager?: boolean;
          }
          /**
           * Enum of possible auto-reponse for permisison / prompt dialogs.
           */
          type AutoResponseMode = 'none' | 'autoAccept' | 'autoReject' | 'autoOptOut';
          /**
           * The type of a frameNavigated event.
           */
          type NavigationType = 'Navigation' | 'BackForwardCacheRestore';
          /**
           * List of not restored reasons for back-forward cache.
           */
          type BackForwardCacheNotRestoredReason = 'NotPrimaryMainFrame' | 'BackForwardCacheDisabled' | 'RelatedActiveContentsExist' | 'HTTPStatusNotOK' | 'SchemeNotHTTPOrHTTPS' | 'Loading' | 'WasGrantedMediaAccess' | 'DisableForRenderFrameHostCalled' | 'DomainNotAllowed' | 'HTTPMethodNotGET' | 'SubframeIsNavigating' | 'Timeout' | 'CacheLimit' | 'JavaScriptExecution' | 'RendererProcessKilled' | 'RendererProcessCrashed' | 'SchedulerTrackedFeatureUsed' | 'ConflictingBrowsingInstance' | 'CacheFlushed' | 'ServiceWorkerVersionActivation' | 'SessionRestored' | 'ServiceWorkerPostMessage' | 'EnteredBackForwardCacheBeforeServiceWorkerHostAdded' | 'RenderFrameHostReused_SameSite' | 'RenderFrameHostReused_CrossSite' | 'ServiceWorkerClaim' | 'IgnoreEventAndEvict' | 'HaveInnerContents' | 'TimeoutPuttingInCache' | 'BackForwardCacheDisabledByLowMemory' | 'BackForwardCacheDisabledByCommandLine' | 'NetworkRequestDatapipeDrainedAsBytesConsumer' | 'NetworkRequestRedirected' | 'NetworkRequestTimeout' | 'NetworkExceedsBufferLimit' | 'NavigationCancelledWhileRestoring' | 'NotMostRecentNavigationEntry' | 'BackForwardCacheDisabledForPrerender' | 'UserAgentOverrideDiffers' | 'ForegroundCacheLimit' | 'BrowsingInstanceNotSwapped' | 'BackForwardCacheDisabledForDelegate' | 'UnloadHandlerExistsInMainFrame' | 'UnloadHandlerExistsInSubFrame' | 'ServiceWorkerUnregistration' | 'CacheControlNoStore' | 'CacheControlNoStoreCookieModified' | 'CacheControlNoStoreHTTPOnlyCookieModified' | 'NoResponseHead' | 'Unknown' | 'ActivationNavigationsDisallowedForBug1234857' | 'ErrorDocument' | 'FencedFramesEmbedder' | 'CookieDisabled' | 'HTTPAuthRequired' | 'CookieFlushed' | 'WebSocket' | 'WebTransport' | 'WebRTC' | 'MainResourceHasCacheControlNoStore' | 'MainResourceHasCacheControlNoCache' | 'SubresourceHasCacheControlNoStore' | 'SubresourceHasCacheControlNoCache' | 'ContainsPlugins' | 'DocumentLoaded' | 'DedicatedWorkerOrWorklet' | 'OutstandingNetworkRequestOthers' | 'RequestedMIDIPermission' | 'RequestedAudioCapturePermission' | 'RequestedVideoCapturePermission' | 'RequestedBackForwardCacheBlockedSensors' | 'RequestedBackgroundWorkPermission' | 'BroadcastChannel' | 'WebXR' | 'SharedWorker' | 'WebLocks' | 'WebHID' | 'WebShare' | 'RequestedStorageAccessGrant' | 'WebNfc' | 'OutstandingNetworkRequestFetch' | 'OutstandingNetworkRequestXHR' | 'AppBanner' | 'Printing' | 'WebDatabase' | 'PictureInPicture' | 'Portal' | 'SpeechRecognizer' | 'IdleManager' | 'PaymentManager' | 'SpeechSynthesis' | 'KeyboardLock' | 'WebOTPService' | 'OutstandingNetworkRequestDirectSocket' | 'InjectedJavascript' | 'InjectedStyleSheet' | 'KeepaliveRequest' | 'IndexedDBEvent' | 'Dummy' | 'JsNetworkRequestReceivedCacheControlNoStoreResource' | 'WebRTCSticky' | 'WebTransportSticky' | 'WebSocketSticky' | 'SmartCard' | 'LiveMediaStreamTrack' | 'ContentSecurityHandler' | 'ContentWebAuthenticationAPI' | 'ContentFileChooser' | 'ContentSerial' | 'ContentFileSystemAccess' | 'ContentMediaDevicesDispatcherHost' | 'ContentWebBluetooth' | 'ContentWebUSB' | 'ContentMediaSessionService' | 'ContentScreenReader' | 'EmbedderPopupBlockerTabHelper' | 'EmbedderSafeBrowsingTriggeredPopupBlocker' | 'EmbedderSafeBrowsingThreatDetails' | 'EmbedderAppBannerManager' | 'EmbedderDomDistillerViewerSource' | 'EmbedderDomDistillerSelfDeletingRequestDelegate' | 'EmbedderOomInterventionTabHelper' | 'EmbedderOfflinePage' | 'EmbedderChromePasswordManagerClientBindCredentialManager' | 'EmbedderPermissionRequestManager' | 'EmbedderModalDialog' | 'EmbedderExtensions' | 'EmbedderExtensionMessaging' | 'EmbedderExtensionMessagingForOpenPort' | 'EmbedderExtensionSentMessageToCachedFrame';
          /**
           * Types of not restored reasons for back-forward cache.
           */
          type BackForwardCacheNotRestoredReasonType = 'SupportPending' | 'PageSupportNeeded' | 'Circumstantial';
          interface BackForwardCacheBlockingDetails {
              /**
               * Url of the file where blockage happened. Optional because of tests.
               */
              url?: string;
              /**
               * Function name where blockage happened. Optional because of anonymous functions and tests.
               */
              function?: string;
              /**
               * Line number in the script (0-based).
               */
              lineNumber: integer;
              /**
               * Column number in the script (0-based).
               */
              columnNumber: integer;
          }
          interface BackForwardCacheNotRestoredExplanation {
              /**
               * Type of the reason
               */
              type: BackForwardCacheNotRestoredReasonType;
              /**
               * Not restored reason
               */
              reason: BackForwardCacheNotRestoredReason;
              /**
               * Context associated with the reason. The meaning of this context is
               * dependent on the reason:
               * - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
               */
              context?: string;
              details?: BackForwardCacheBlockingDetails[];
          }
          interface BackForwardCacheNotRestoredExplanationTree {
              /**
               * URL of each frame
               */
              url: string;
              /**
               * Not restored reasons of each frame
               */
              explanations: BackForwardCacheNotRestoredExplanation[];
              /**
               * Array of children frame
               */
              children: BackForwardCacheNotRestoredExplanationTree[];
          }
      }
      /**
       * Methods and events of the 'Performance' domain.
       */
      interface PerformanceApi {
          requests: {
              /**
               * Disable collecting and reporting metrics.
               */
              disable: {
                  params: Performance.DisableParams;
                  result: Performance.DisableResult;
              };
              /**
               * Enable collecting and reporting metrics.
               */
              enable: {
                  params: Performance.EnableParams;
                  result: Performance.EnableResult;
              };
              /**
               * Sets time domain to use for collecting and reporting duration metrics.
               * Note that this must be called before enabling metrics collection. Calling
               * this method while metrics collection is enabled returns an error.
               * @deprecated
               */
              setTimeDomain: {
                  params: Performance.SetTimeDomainParams;
                  result: Performance.SetTimeDomainResult;
              };
              /**
               * Retrieve current values of run-time metrics.
               */
              getMetrics: {
                  params: Performance.GetMetricsParams;
                  result: Performance.GetMetricsResult;
              };
          };
          events: {
              /**
               * Current values of the metrics.
               */
              metrics: {
                  params: Performance.MetricsEvent;
              };
          };
      }
      /**
       * Types of the 'Performance' domain.
       */
      namespace Performance {
          /**
           * Parameters of the 'Performance.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Performance.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Performance.enable' method.
           */
          interface EnableParams {
              /**
               * Time domain to use for collecting and reporting duration metrics.
               */
              timeDomain?: 'timeTicks' | 'threadTicks';
          }
          /**
           * Return value of the 'Performance.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Performance.setTimeDomain' method.
           */
          interface SetTimeDomainParams {
              /**
               * Time domain
               */
              timeDomain: 'timeTicks' | 'threadTicks';
          }
          /**
           * Return value of the 'Performance.setTimeDomain' method.
           */
          interface SetTimeDomainResult {
          }
          /**
           * Parameters of the 'Performance.getMetrics' method.
           */
          interface GetMetricsParams {
          }
          /**
           * Return value of the 'Performance.getMetrics' method.
           */
          interface GetMetricsResult {
              /**
               * Current values for run-time metrics.
               */
              metrics: Metric[];
          }
          /**
           * Parameters of the 'Performance.metrics' event.
           */
          interface MetricsEvent {
              /**
               * Current values of the metrics.
               */
              metrics: Metric[];
              /**
               * Timestamp title.
               */
              title: string;
          }
          /**
           * Run-time execution metric.
           */
          interface Metric {
              /**
               * Metric name.
               */
              name: string;
              /**
               * Metric value.
               */
              value: number;
          }
      }
      /**
       * Methods and events of the 'PerformanceTimeline' domain.
       */
      interface PerformanceTimelineApi {
          requests: {
              /**
               * Previously buffered events would be reported before method returns.
               * See also: timelineEventAdded
               */
              enable: {
                  params: PerformanceTimeline.EnableParams;
                  result: PerformanceTimeline.EnableResult;
              };
          };
          events: {
              /**
               * Sent when a performance timeline event is added. See reportPerformanceTimeline method.
               */
              timelineEventAdded: {
                  params: PerformanceTimeline.TimelineEventAddedEvent;
              };
          };
      }
      /**
       * Types of the 'PerformanceTimeline' domain.
       */
      namespace PerformanceTimeline {
          /**
           * Parameters of the 'PerformanceTimeline.enable' method.
           */
          interface EnableParams {
              /**
               * The types of event to report, as specified in
               * https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
               * The specified filter overrides any previous filters, passing empty
               * filter disables recording.
               * Note that not all types exposed to the web platform are currently supported.
               */
              eventTypes: string[];
          }
          /**
           * Return value of the 'PerformanceTimeline.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'PerformanceTimeline.timelineEventAdded' event.
           */
          interface TimelineEventAddedEvent {
              event: TimelineEvent;
          }
          /**
           * See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
           */
          interface LargestContentfulPaint {
              renderTime: Network.TimeSinceEpoch;
              loadTime: Network.TimeSinceEpoch;
              /**
               * The number of pixels being painted.
               */
              size: number;
              /**
               * The id attribute of the element, if available.
               */
              elementId?: string;
              /**
               * The URL of the image (may be trimmed).
               */
              url?: string;
              nodeId?: DOM.BackendNodeId;
          }
          interface LayoutShiftAttribution {
              previousRect: DOM.Rect;
              currentRect: DOM.Rect;
              nodeId?: DOM.BackendNodeId;
          }
          /**
           * See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
           */
          interface LayoutShift {
              /**
               * Score increment produced by this event.
               */
              value: number;
              hadRecentInput: boolean;
              lastInputTime: Network.TimeSinceEpoch;
              sources: LayoutShiftAttribution[];
          }
          interface TimelineEvent {
              /**
               * Identifies the frame that this event is related to. Empty for non-frame targets.
               */
              frameId: Page.FrameId;
              /**
               * The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
               * This determines which of the optional "details" fiedls is present.
               */
              type: string;
              /**
               * Name may be empty depending on the type.
               */
              name: string;
              /**
               * Time in seconds since Epoch, monotonically increasing within document lifetime.
               */
              time: Network.TimeSinceEpoch;
              /**
               * Event duration, if applicable.
               */
              duration?: number;
              lcpDetails?: LargestContentfulPaint;
              layoutShiftDetails?: LayoutShift;
          }
      }
      /**
       * Methods and events of the 'Security' domain.
       */
      interface SecurityApi {
          requests: {
              /**
               * Disables tracking security state changes.
               */
              disable: {
                  params: Security.DisableParams;
                  result: Security.DisableResult;
              };
              /**
               * Enables tracking security state changes.
               */
              enable: {
                  params: Security.EnableParams;
                  result: Security.EnableResult;
              };
              /**
               * Enable/disable whether all certificate errors should be ignored.
               */
              setIgnoreCertificateErrors: {
                  params: Security.SetIgnoreCertificateErrorsParams;
                  result: Security.SetIgnoreCertificateErrorsResult;
              };
              /**
               * Handles a certificate error that fired a certificateError event.
               * @deprecated
               */
              handleCertificateError: {
                  params: Security.HandleCertificateErrorParams;
                  result: Security.HandleCertificateErrorResult;
              };
              /**
               * Enable/disable overriding certificate errors. If enabled, all certificate error events need to
               * be handled by the DevTools client and should be answered with `handleCertificateError` commands.
               * @deprecated
               */
              setOverrideCertificateErrors: {
                  params: Security.SetOverrideCertificateErrorsParams;
                  result: Security.SetOverrideCertificateErrorsResult;
              };
          };
          events: {
              /**
               * There is a certificate error. If overriding certificate errors is enabled, then it should be
               * handled with the `handleCertificateError` command. Note: this event does not fire if the
               * certificate error has been allowed internally. Only one client per target should override
               * certificate errors at the same time.
               * @deprecated
               */
              certificateError: {
                  params: Security.CertificateErrorEvent;
              };
              /**
               * The security state of the page changed.
               */
              visibleSecurityStateChanged: {
                  params: Security.VisibleSecurityStateChangedEvent;
              };
              /**
               * The security state of the page changed. No longer being sent.
               * @deprecated
               */
              securityStateChanged: {
                  params: Security.SecurityStateChangedEvent;
              };
          };
      }
      /**
       * Types of the 'Security' domain.
       */
      namespace Security {
          /**
           * Parameters of the 'Security.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Security.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Security.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Security.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Security.setIgnoreCertificateErrors' method.
           */
          interface SetIgnoreCertificateErrorsParams {
              /**
               * If true, all certificate errors will be ignored.
               */
              ignore: boolean;
          }
          /**
           * Return value of the 'Security.setIgnoreCertificateErrors' method.
           */
          interface SetIgnoreCertificateErrorsResult {
          }
          /**
           * Parameters of the 'Security.handleCertificateError' method.
           */
          interface HandleCertificateErrorParams {
              /**
               * The ID of the event.
               */
              eventId: integer;
              /**
               * The action to take on the certificate error.
               */
              action: CertificateErrorAction;
          }
          /**
           * Return value of the 'Security.handleCertificateError' method.
           */
          interface HandleCertificateErrorResult {
          }
          /**
           * Parameters of the 'Security.setOverrideCertificateErrors' method.
           */
          interface SetOverrideCertificateErrorsParams {
              /**
               * If true, certificate errors will be overridden.
               */
              override: boolean;
          }
          /**
           * Return value of the 'Security.setOverrideCertificateErrors' method.
           */
          interface SetOverrideCertificateErrorsResult {
          }
          /**
           * Parameters of the 'Security.certificateError' event.
           */
          interface CertificateErrorEvent {
              /**
               * The ID of the event.
               */
              eventId: integer;
              /**
               * The type of the error.
               */
              errorType: string;
              /**
               * The url that was requested.
               */
              requestURL: string;
          }
          /**
           * Parameters of the 'Security.visibleSecurityStateChanged' event.
           */
          interface VisibleSecurityStateChangedEvent {
              /**
               * Security state information about the page.
               */
              visibleSecurityState: VisibleSecurityState;
          }
          /**
           * Parameters of the 'Security.securityStateChanged' event.
           */
          interface SecurityStateChangedEvent {
              /**
               * Security state.
               */
              securityState: SecurityState;
              /**
               * True if the page was loaded over cryptographic transport such as HTTPS.
               * @deprecated
               */
              schemeIsCryptographic: boolean;
              /**
               * Previously a list of explanations for the security state. Now always
               * empty.
               * @deprecated
               */
              explanations: SecurityStateExplanation[];
              /**
               * Information about insecure content on the page.
               * @deprecated
               */
              insecureContentStatus: InsecureContentStatus;
              /**
               * Overrides user-visible description of the state. Always omitted.
               * @deprecated
               */
              summary?: string;
          }
          /**
           * An internal certificate ID value.
           */
          type CertificateId = integer;
          /**
           * A description of mixed content (HTTP resources on HTTPS pages), as defined by
           * https://www.w3.org/TR/mixed-content/#categories
           */
          type MixedContentType = 'blockable' | 'optionally-blockable' | 'none';
          /**
           * The security level of a page or resource.
           */
          type SecurityState = 'unknown' | 'neutral' | 'insecure' | 'secure' | 'info' | 'insecure-broken';
          /**
           * Details about the security state of the page certificate.
           */
          interface CertificateSecurityState {
              /**
               * Protocol name (e.g. "TLS 1.2" or "QUIC").
               */
              protocol: string;
              /**
               * Key Exchange used by the connection, or the empty string if not applicable.
               */
              keyExchange: string;
              /**
               * (EC)DH group used by the connection, if applicable.
               */
              keyExchangeGroup?: string;
              /**
               * Cipher name.
               */
              cipher: string;
              /**
               * TLS MAC. Note that AEAD ciphers do not have separate MACs.
               */
              mac?: string;
              /**
               * Page certificate.
               */
              certificate: string[];
              /**
               * Certificate subject name.
               */
              subjectName: string;
              /**
               * Name of the issuing CA.
               */
              issuer: string;
              /**
               * Certificate valid from date.
               */
              validFrom: Network.TimeSinceEpoch;
              /**
               * Certificate valid to (expiration) date
               */
              validTo: Network.TimeSinceEpoch;
              /**
               * The highest priority network error code, if the certificate has an error.
               */
              certificateNetworkError?: string;
              /**
               * True if the certificate uses a weak signature aglorithm.
               */
              certificateHasWeakSignature: boolean;
              /**
               * True if the certificate has a SHA1 signature in the chain.
               */
              certificateHasSha1Signature: boolean;
              /**
               * True if modern SSL
               */
              modernSSL: boolean;
              /**
               * True if the connection is using an obsolete SSL protocol.
               */
              obsoleteSslProtocol: boolean;
              /**
               * True if the connection is using an obsolete SSL key exchange.
               */
              obsoleteSslKeyExchange: boolean;
              /**
               * True if the connection is using an obsolete SSL cipher.
               */
              obsoleteSslCipher: boolean;
              /**
               * True if the connection is using an obsolete SSL signature.
               */
              obsoleteSslSignature: boolean;
          }
          type SafetyTipStatus = 'badReputation' | 'lookalike';
          interface SafetyTipInfo {
              /**
               * Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
               */
              safetyTipStatus: SafetyTipStatus;
              /**
               * The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
               */
              safeUrl?: string;
          }
          /**
           * Security state information about the page.
           */
          interface VisibleSecurityState {
              /**
               * The security level of the page.
               */
              securityState: SecurityState;
              /**
               * Security state details about the page certificate.
               */
              certificateSecurityState?: CertificateSecurityState;
              /**
               * The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
               */
              safetyTipInfo?: SafetyTipInfo;
              /**
               * Array of security state issues ids.
               */
              securityStateIssueIds: string[];
          }
          /**
           * An explanation of an factor contributing to the security state.
           */
          interface SecurityStateExplanation {
              /**
               * Security state representing the severity of the factor being explained.
               */
              securityState: SecurityState;
              /**
               * Title describing the type of factor.
               */
              title: string;
              /**
               * Short phrase describing the type of factor.
               */
              summary: string;
              /**
               * Full text explanation of the factor.
               */
              description: string;
              /**
               * The type of mixed content described by the explanation.
               */
              mixedContentType: MixedContentType;
              /**
               * Page certificate.
               */
              certificate: string[];
              /**
               * Recommendations to fix any issues.
               */
              recommendations?: string[];
          }
          /**
           * Information about insecure content on the page.
           * @deprecated
           */
          interface InsecureContentStatus {
              /**
               * Always false.
               */
              ranMixedContent: boolean;
              /**
               * Always false.
               */
              displayedMixedContent: boolean;
              /**
               * Always false.
               */
              containedMixedForm: boolean;
              /**
               * Always false.
               */
              ranContentWithCertErrors: boolean;
              /**
               * Always false.
               */
              displayedContentWithCertErrors: boolean;
              /**
               * Always set to unknown.
               */
              ranInsecureContentStyle: SecurityState;
              /**
               * Always set to unknown.
               */
              displayedInsecureContentStyle: SecurityState;
          }
          /**
           * The action to take when a certificate error occurs. continue will continue processing the
           * request and cancel will cancel the request.
           */
          type CertificateErrorAction = 'continue' | 'cancel';
      }
      /**
       * Methods and events of the 'ServiceWorker' domain.
       */
      interface ServiceWorkerApi {
          requests: {
              deliverPushMessage: {
                  params: ServiceWorker.DeliverPushMessageParams;
                  result: ServiceWorker.DeliverPushMessageResult;
              };
              disable: {
                  params: ServiceWorker.DisableParams;
                  result: ServiceWorker.DisableResult;
              };
              dispatchSyncEvent: {
                  params: ServiceWorker.DispatchSyncEventParams;
                  result: ServiceWorker.DispatchSyncEventResult;
              };
              dispatchPeriodicSyncEvent: {
                  params: ServiceWorker.DispatchPeriodicSyncEventParams;
                  result: ServiceWorker.DispatchPeriodicSyncEventResult;
              };
              enable: {
                  params: ServiceWorker.EnableParams;
                  result: ServiceWorker.EnableResult;
              };
              inspectWorker: {
                  params: ServiceWorker.InspectWorkerParams;
                  result: ServiceWorker.InspectWorkerResult;
              };
              setForceUpdateOnPageLoad: {
                  params: ServiceWorker.SetForceUpdateOnPageLoadParams;
                  result: ServiceWorker.SetForceUpdateOnPageLoadResult;
              };
              skipWaiting: {
                  params: ServiceWorker.SkipWaitingParams;
                  result: ServiceWorker.SkipWaitingResult;
              };
              startWorker: {
                  params: ServiceWorker.StartWorkerParams;
                  result: ServiceWorker.StartWorkerResult;
              };
              stopAllWorkers: {
                  params: ServiceWorker.StopAllWorkersParams;
                  result: ServiceWorker.StopAllWorkersResult;
              };
              stopWorker: {
                  params: ServiceWorker.StopWorkerParams;
                  result: ServiceWorker.StopWorkerResult;
              };
              unregister: {
                  params: ServiceWorker.UnregisterParams;
                  result: ServiceWorker.UnregisterResult;
              };
              updateRegistration: {
                  params: ServiceWorker.UpdateRegistrationParams;
                  result: ServiceWorker.UpdateRegistrationResult;
              };
          };
          events: {
              workerErrorReported: {
                  params: ServiceWorker.WorkerErrorReportedEvent;
              };
              workerRegistrationUpdated: {
                  params: ServiceWorker.WorkerRegistrationUpdatedEvent;
              };
              workerVersionUpdated: {
                  params: ServiceWorker.WorkerVersionUpdatedEvent;
              };
          };
      }
      /**
       * Types of the 'ServiceWorker' domain.
       */
      namespace ServiceWorker {
          /**
           * Parameters of the 'ServiceWorker.deliverPushMessage' method.
           */
          interface DeliverPushMessageParams {
              origin: string;
              registrationId: RegistrationID;
              data: string;
          }
          /**
           * Return value of the 'ServiceWorker.deliverPushMessage' method.
           */
          interface DeliverPushMessageResult {
          }
          /**
           * Parameters of the 'ServiceWorker.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'ServiceWorker.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'ServiceWorker.dispatchSyncEvent' method.
           */
          interface DispatchSyncEventParams {
              origin: string;
              registrationId: RegistrationID;
              tag: string;
              lastChance: boolean;
          }
          /**
           * Return value of the 'ServiceWorker.dispatchSyncEvent' method.
           */
          interface DispatchSyncEventResult {
          }
          /**
           * Parameters of the 'ServiceWorker.dispatchPeriodicSyncEvent' method.
           */
          interface DispatchPeriodicSyncEventParams {
              origin: string;
              registrationId: RegistrationID;
              tag: string;
          }
          /**
           * Return value of the 'ServiceWorker.dispatchPeriodicSyncEvent' method.
           */
          interface DispatchPeriodicSyncEventResult {
          }
          /**
           * Parameters of the 'ServiceWorker.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'ServiceWorker.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'ServiceWorker.inspectWorker' method.
           */
          interface InspectWorkerParams {
              versionId: string;
          }
          /**
           * Return value of the 'ServiceWorker.inspectWorker' method.
           */
          interface InspectWorkerResult {
          }
          /**
           * Parameters of the 'ServiceWorker.setForceUpdateOnPageLoad' method.
           */
          interface SetForceUpdateOnPageLoadParams {
              forceUpdateOnPageLoad: boolean;
          }
          /**
           * Return value of the 'ServiceWorker.setForceUpdateOnPageLoad' method.
           */
          interface SetForceUpdateOnPageLoadResult {
          }
          /**
           * Parameters of the 'ServiceWorker.skipWaiting' method.
           */
          interface SkipWaitingParams {
              scopeURL: string;
          }
          /**
           * Return value of the 'ServiceWorker.skipWaiting' method.
           */
          interface SkipWaitingResult {
          }
          /**
           * Parameters of the 'ServiceWorker.startWorker' method.
           */
          interface StartWorkerParams {
              scopeURL: string;
          }
          /**
           * Return value of the 'ServiceWorker.startWorker' method.
           */
          interface StartWorkerResult {
          }
          /**
           * Parameters of the 'ServiceWorker.stopAllWorkers' method.
           */
          interface StopAllWorkersParams {
          }
          /**
           * Return value of the 'ServiceWorker.stopAllWorkers' method.
           */
          interface StopAllWorkersResult {
          }
          /**
           * Parameters of the 'ServiceWorker.stopWorker' method.
           */
          interface StopWorkerParams {
              versionId: string;
          }
          /**
           * Return value of the 'ServiceWorker.stopWorker' method.
           */
          interface StopWorkerResult {
          }
          /**
           * Parameters of the 'ServiceWorker.unregister' method.
           */
          interface UnregisterParams {
              scopeURL: string;
          }
          /**
           * Return value of the 'ServiceWorker.unregister' method.
           */
          interface UnregisterResult {
          }
          /**
           * Parameters of the 'ServiceWorker.updateRegistration' method.
           */
          interface UpdateRegistrationParams {
              scopeURL: string;
          }
          /**
           * Return value of the 'ServiceWorker.updateRegistration' method.
           */
          interface UpdateRegistrationResult {
          }
          /**
           * Parameters of the 'ServiceWorker.workerErrorReported' event.
           */
          interface WorkerErrorReportedEvent {
              errorMessage: ServiceWorkerErrorMessage;
          }
          /**
           * Parameters of the 'ServiceWorker.workerRegistrationUpdated' event.
           */
          interface WorkerRegistrationUpdatedEvent {
              registrations: ServiceWorkerRegistration[];
          }
          /**
           * Parameters of the 'ServiceWorker.workerVersionUpdated' event.
           */
          interface WorkerVersionUpdatedEvent {
              versions: ServiceWorkerVersion[];
          }
          type RegistrationID = string;
          /**
           * ServiceWorker registration.
           */
          interface ServiceWorkerRegistration {
              registrationId: RegistrationID;
              scopeURL: string;
              isDeleted: boolean;
          }
          type ServiceWorkerVersionRunningStatus = 'stopped' | 'starting' | 'running' | 'stopping';
          type ServiceWorkerVersionStatus = 'new' | 'installing' | 'installed' | 'activating' | 'activated' | 'redundant';
          /**
           * ServiceWorker version.
           */
          interface ServiceWorkerVersion {
              versionId: string;
              registrationId: RegistrationID;
              scriptURL: string;
              runningStatus: ServiceWorkerVersionRunningStatus;
              status: ServiceWorkerVersionStatus;
              /**
               * The Last-Modified header value of the main script.
               */
              scriptLastModified?: number;
              /**
               * The time at which the response headers of the main script were received from the server.
               * For cached script it is the last time the cache entry was validated.
               */
              scriptResponseTime?: number;
              controlledClients?: Target.TargetID[];
              targetId?: Target.TargetID;
              routerRules?: string;
          }
          /**
           * ServiceWorker error message.
           */
          interface ServiceWorkerErrorMessage {
              errorMessage: string;
              registrationId: RegistrationID;
              versionId: string;
              sourceURL: string;
              lineNumber: integer;
              columnNumber: integer;
          }
      }
      /**
       * Methods and events of the 'Storage' domain.
       */
      interface StorageApi {
          requests: {
              /**
               * Returns a storage key given a frame id.
               */
              getStorageKeyForFrame: {
                  params: Storage.GetStorageKeyForFrameParams;
                  result: Storage.GetStorageKeyForFrameResult;
              };
              /**
               * Clears storage for origin.
               */
              clearDataForOrigin: {
                  params: Storage.ClearDataForOriginParams;
                  result: Storage.ClearDataForOriginResult;
              };
              /**
               * Clears storage for storage key.
               */
              clearDataForStorageKey: {
                  params: Storage.ClearDataForStorageKeyParams;
                  result: Storage.ClearDataForStorageKeyResult;
              };
              /**
               * Returns all browser cookies.
               */
              getCookies: {
                  params: Storage.GetCookiesParams;
                  result: Storage.GetCookiesResult;
              };
              /**
               * Sets given cookies.
               */
              setCookies: {
                  params: Storage.SetCookiesParams;
                  result: Storage.SetCookiesResult;
              };
              /**
               * Clears cookies.
               */
              clearCookies: {
                  params: Storage.ClearCookiesParams;
                  result: Storage.ClearCookiesResult;
              };
              /**
               * Returns usage and quota in bytes.
               */
              getUsageAndQuota: {
                  params: Storage.GetUsageAndQuotaParams;
                  result: Storage.GetUsageAndQuotaResult;
              };
              /**
               * Override quota for the specified origin
               */
              overrideQuotaForOrigin: {
                  params: Storage.OverrideQuotaForOriginParams;
                  result: Storage.OverrideQuotaForOriginResult;
              };
              /**
               * Registers origin to be notified when an update occurs to its cache storage list.
               */
              trackCacheStorageForOrigin: {
                  params: Storage.TrackCacheStorageForOriginParams;
                  result: Storage.TrackCacheStorageForOriginResult;
              };
              /**
               * Registers storage key to be notified when an update occurs to its cache storage list.
               */
              trackCacheStorageForStorageKey: {
                  params: Storage.TrackCacheStorageForStorageKeyParams;
                  result: Storage.TrackCacheStorageForStorageKeyResult;
              };
              /**
               * Registers origin to be notified when an update occurs to its IndexedDB.
               */
              trackIndexedDBForOrigin: {
                  params: Storage.TrackIndexedDBForOriginParams;
                  result: Storage.TrackIndexedDBForOriginResult;
              };
              /**
               * Registers storage key to be notified when an update occurs to its IndexedDB.
               */
              trackIndexedDBForStorageKey: {
                  params: Storage.TrackIndexedDBForStorageKeyParams;
                  result: Storage.TrackIndexedDBForStorageKeyResult;
              };
              /**
               * Unregisters origin from receiving notifications for cache storage.
               */
              untrackCacheStorageForOrigin: {
                  params: Storage.UntrackCacheStorageForOriginParams;
                  result: Storage.UntrackCacheStorageForOriginResult;
              };
              /**
               * Unregisters storage key from receiving notifications for cache storage.
               */
              untrackCacheStorageForStorageKey: {
                  params: Storage.UntrackCacheStorageForStorageKeyParams;
                  result: Storage.UntrackCacheStorageForStorageKeyResult;
              };
              /**
               * Unregisters origin from receiving notifications for IndexedDB.
               */
              untrackIndexedDBForOrigin: {
                  params: Storage.UntrackIndexedDBForOriginParams;
                  result: Storage.UntrackIndexedDBForOriginResult;
              };
              /**
               * Unregisters storage key from receiving notifications for IndexedDB.
               */
              untrackIndexedDBForStorageKey: {
                  params: Storage.UntrackIndexedDBForStorageKeyParams;
                  result: Storage.UntrackIndexedDBForStorageKeyResult;
              };
              /**
               * Returns the number of stored Trust Tokens per issuer for the
               * current browsing context.
               */
              getTrustTokens: {
                  params: Storage.GetTrustTokensParams;
                  result: Storage.GetTrustTokensResult;
              };
              /**
               * Removes all Trust Tokens issued by the provided issuerOrigin.
               * Leaves other stored data, including the issuer's Redemption Records, intact.
               */
              clearTrustTokens: {
                  params: Storage.ClearTrustTokensParams;
                  result: Storage.ClearTrustTokensResult;
              };
              /**
               * Gets details for a named interest group.
               */
              getInterestGroupDetails: {
                  params: Storage.GetInterestGroupDetailsParams;
                  result: Storage.GetInterestGroupDetailsResult;
              };
              /**
               * Enables/Disables issuing of interestGroupAccessed events.
               */
              setInterestGroupTracking: {
                  params: Storage.SetInterestGroupTrackingParams;
                  result: Storage.SetInterestGroupTrackingResult;
              };
              /**
               * Gets metadata for an origin's shared storage.
               */
              getSharedStorageMetadata: {
                  params: Storage.GetSharedStorageMetadataParams;
                  result: Storage.GetSharedStorageMetadataResult;
              };
              /**
               * Gets the entries in an given origin's shared storage.
               */
              getSharedStorageEntries: {
                  params: Storage.GetSharedStorageEntriesParams;
                  result: Storage.GetSharedStorageEntriesResult;
              };
              /**
               * Sets entry with `key` and `value` for a given origin's shared storage.
               */
              setSharedStorageEntry: {
                  params: Storage.SetSharedStorageEntryParams;
                  result: Storage.SetSharedStorageEntryResult;
              };
              /**
               * Deletes entry for `key` (if it exists) for a given origin's shared storage.
               */
              deleteSharedStorageEntry: {
                  params: Storage.DeleteSharedStorageEntryParams;
                  result: Storage.DeleteSharedStorageEntryResult;
              };
              /**
               * Clears all entries for a given origin's shared storage.
               */
              clearSharedStorageEntries: {
                  params: Storage.ClearSharedStorageEntriesParams;
                  result: Storage.ClearSharedStorageEntriesResult;
              };
              /**
               * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
               */
              resetSharedStorageBudget: {
                  params: Storage.ResetSharedStorageBudgetParams;
                  result: Storage.ResetSharedStorageBudgetResult;
              };
              /**
               * Enables/disables issuing of sharedStorageAccessed events.
               */
              setSharedStorageTracking: {
                  params: Storage.SetSharedStorageTrackingParams;
                  result: Storage.SetSharedStorageTrackingResult;
              };
              /**
               * Set tracking for a storage key's buckets.
               */
              setStorageBucketTracking: {
                  params: Storage.SetStorageBucketTrackingParams;
                  result: Storage.SetStorageBucketTrackingResult;
              };
              /**
               * Deletes the Storage Bucket with the given storage key and bucket name.
               */
              deleteStorageBucket: {
                  params: Storage.DeleteStorageBucketParams;
                  result: Storage.DeleteStorageBucketResult;
              };
              /**
               * Deletes state for sites identified as potential bounce trackers, immediately.
               */
              runBounceTrackingMitigations: {
                  params: Storage.RunBounceTrackingMitigationsParams;
                  result: Storage.RunBounceTrackingMitigationsResult;
              };
              /**
               * https://wicg.github.io/attribution-reporting-api/
               */
              setAttributionReportingLocalTestingMode: {
                  params: Storage.SetAttributionReportingLocalTestingModeParams;
                  result: Storage.SetAttributionReportingLocalTestingModeResult;
              };
              /**
               * Enables/disables issuing of Attribution Reporting events.
               */
              setAttributionReportingTracking: {
                  params: Storage.SetAttributionReportingTrackingParams;
                  result: Storage.SetAttributionReportingTrackingResult;
              };
          };
          events: {
              /**
               * A cache's contents have been modified.
               */
              cacheStorageContentUpdated: {
                  params: Storage.CacheStorageContentUpdatedEvent;
              };
              /**
               * A cache has been added/deleted.
               */
              cacheStorageListUpdated: {
                  params: Storage.CacheStorageListUpdatedEvent;
              };
              /**
               * The origin's IndexedDB object store has been modified.
               */
              indexedDBContentUpdated: {
                  params: Storage.IndexedDBContentUpdatedEvent;
              };
              /**
               * The origin's IndexedDB database list has been modified.
               */
              indexedDBListUpdated: {
                  params: Storage.IndexedDBListUpdatedEvent;
              };
              /**
               * One of the interest groups was accessed by the associated page.
               */
              interestGroupAccessed: {
                  params: Storage.InterestGroupAccessedEvent;
              };
              /**
               * Shared storage was accessed by the associated page.
               * The following parameters are included in all events.
               */
              sharedStorageAccessed: {
                  params: Storage.SharedStorageAccessedEvent;
              };
              storageBucketCreatedOrUpdated: {
                  params: Storage.StorageBucketCreatedOrUpdatedEvent;
              };
              storageBucketDeleted: {
                  params: Storage.StorageBucketDeletedEvent;
              };
              attributionReportingSourceRegistered: {
                  params: Storage.AttributionReportingSourceRegisteredEvent;
              };
              attributionReportingTriggerRegistered: {
                  params: Storage.AttributionReportingTriggerRegisteredEvent;
              };
          };
      }
      /**
       * Types of the 'Storage' domain.
       */
      namespace Storage {
          /**
           * Parameters of the 'Storage.getStorageKeyForFrame' method.
           */
          interface GetStorageKeyForFrameParams {
              frameId: Page.FrameId;
          }
          /**
           * Return value of the 'Storage.getStorageKeyForFrame' method.
           */
          interface GetStorageKeyForFrameResult {
              storageKey: SerializedStorageKey;
          }
          /**
           * Parameters of the 'Storage.clearDataForOrigin' method.
           */
          interface ClearDataForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
              /**
               * Comma separated list of StorageType to clear.
               */
              storageTypes: string;
          }
          /**
           * Return value of the 'Storage.clearDataForOrigin' method.
           */
          interface ClearDataForOriginResult {
          }
          /**
           * Parameters of the 'Storage.clearDataForStorageKey' method.
           */
          interface ClearDataForStorageKeyParams {
              /**
               * Storage key.
               */
              storageKey: string;
              /**
               * Comma separated list of StorageType to clear.
               */
              storageTypes: string;
          }
          /**
           * Return value of the 'Storage.clearDataForStorageKey' method.
           */
          interface ClearDataForStorageKeyResult {
          }
          /**
           * Parameters of the 'Storage.getCookies' method.
           */
          interface GetCookiesParams {
              /**
               * Browser context to use when called on the browser endpoint.
               */
              browserContextId?: Browser.BrowserContextID;
          }
          /**
           * Return value of the 'Storage.getCookies' method.
           */
          interface GetCookiesResult {
              /**
               * Array of cookie objects.
               */
              cookies: Network.Cookie[];
          }
          /**
           * Parameters of the 'Storage.setCookies' method.
           */
          interface SetCookiesParams {
              /**
               * Cookies to be set.
               */
              cookies: Network.CookieParam[];
              /**
               * Browser context to use when called on the browser endpoint.
               */
              browserContextId?: Browser.BrowserContextID;
          }
          /**
           * Return value of the 'Storage.setCookies' method.
           */
          interface SetCookiesResult {
          }
          /**
           * Parameters of the 'Storage.clearCookies' method.
           */
          interface ClearCookiesParams {
              /**
               * Browser context to use when called on the browser endpoint.
               */
              browserContextId?: Browser.BrowserContextID;
          }
          /**
           * Return value of the 'Storage.clearCookies' method.
           */
          interface ClearCookiesResult {
          }
          /**
           * Parameters of the 'Storage.getUsageAndQuota' method.
           */
          interface GetUsageAndQuotaParams {
              /**
               * Security origin.
               */
              origin: string;
          }
          /**
           * Return value of the 'Storage.getUsageAndQuota' method.
           */
          interface GetUsageAndQuotaResult {
              /**
               * Storage usage (bytes).
               */
              usage: number;
              /**
               * Storage quota (bytes).
               */
              quota: number;
              /**
               * Whether or not the origin has an active storage quota override
               */
              overrideActive: boolean;
              /**
               * Storage usage per type (bytes).
               */
              usageBreakdown: UsageForType[];
          }
          /**
           * Parameters of the 'Storage.overrideQuotaForOrigin' method.
           */
          interface OverrideQuotaForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
              /**
               * The quota size (in bytes) to override the original quota with.
               * If this is called multiple times, the overridden quota will be equal to
               * the quotaSize provided in the final call. If this is called without
               * specifying a quotaSize, the quota will be reset to the default value for
               * the specified origin. If this is called multiple times with different
               * origins, the override will be maintained for each origin until it is
               * disabled (called without a quotaSize).
               */
              quotaSize?: number;
          }
          /**
           * Return value of the 'Storage.overrideQuotaForOrigin' method.
           */
          interface OverrideQuotaForOriginResult {
          }
          /**
           * Parameters of the 'Storage.trackCacheStorageForOrigin' method.
           */
          interface TrackCacheStorageForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
          }
          /**
           * Return value of the 'Storage.trackCacheStorageForOrigin' method.
           */
          interface TrackCacheStorageForOriginResult {
          }
          /**
           * Parameters of the 'Storage.trackCacheStorageForStorageKey' method.
           */
          interface TrackCacheStorageForStorageKeyParams {
              /**
               * Storage key.
               */
              storageKey: string;
          }
          /**
           * Return value of the 'Storage.trackCacheStorageForStorageKey' method.
           */
          interface TrackCacheStorageForStorageKeyResult {
          }
          /**
           * Parameters of the 'Storage.trackIndexedDBForOrigin' method.
           */
          interface TrackIndexedDBForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
          }
          /**
           * Return value of the 'Storage.trackIndexedDBForOrigin' method.
           */
          interface TrackIndexedDBForOriginResult {
          }
          /**
           * Parameters of the 'Storage.trackIndexedDBForStorageKey' method.
           */
          interface TrackIndexedDBForStorageKeyParams {
              /**
               * Storage key.
               */
              storageKey: string;
          }
          /**
           * Return value of the 'Storage.trackIndexedDBForStorageKey' method.
           */
          interface TrackIndexedDBForStorageKeyResult {
          }
          /**
           * Parameters of the 'Storage.untrackCacheStorageForOrigin' method.
           */
          interface UntrackCacheStorageForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
          }
          /**
           * Return value of the 'Storage.untrackCacheStorageForOrigin' method.
           */
          interface UntrackCacheStorageForOriginResult {
          }
          /**
           * Parameters of the 'Storage.untrackCacheStorageForStorageKey' method.
           */
          interface UntrackCacheStorageForStorageKeyParams {
              /**
               * Storage key.
               */
              storageKey: string;
          }
          /**
           * Return value of the 'Storage.untrackCacheStorageForStorageKey' method.
           */
          interface UntrackCacheStorageForStorageKeyResult {
          }
          /**
           * Parameters of the 'Storage.untrackIndexedDBForOrigin' method.
           */
          interface UntrackIndexedDBForOriginParams {
              /**
               * Security origin.
               */
              origin: string;
          }
          /**
           * Return value of the 'Storage.untrackIndexedDBForOrigin' method.
           */
          interface UntrackIndexedDBForOriginResult {
          }
          /**
           * Parameters of the 'Storage.untrackIndexedDBForStorageKey' method.
           */
          interface UntrackIndexedDBForStorageKeyParams {
              /**
               * Storage key.
               */
              storageKey: string;
          }
          /**
           * Return value of the 'Storage.untrackIndexedDBForStorageKey' method.
           */
          interface UntrackIndexedDBForStorageKeyResult {
          }
          /**
           * Parameters of the 'Storage.getTrustTokens' method.
           */
          interface GetTrustTokensParams {
          }
          /**
           * Return value of the 'Storage.getTrustTokens' method.
           */
          interface GetTrustTokensResult {
              tokens: TrustTokens[];
          }
          /**
           * Parameters of the 'Storage.clearTrustTokens' method.
           */
          interface ClearTrustTokensParams {
              issuerOrigin: string;
          }
          /**
           * Return value of the 'Storage.clearTrustTokens' method.
           */
          interface ClearTrustTokensResult {
              /**
               * True if any tokens were deleted, false otherwise.
               */
              didDeleteTokens: boolean;
          }
          /**
           * Parameters of the 'Storage.getInterestGroupDetails' method.
           */
          interface GetInterestGroupDetailsParams {
              ownerOrigin: string;
              name: string;
          }
          /**
           * Return value of the 'Storage.getInterestGroupDetails' method.
           */
          interface GetInterestGroupDetailsResult {
              details: InterestGroupDetails;
          }
          /**
           * Parameters of the 'Storage.setInterestGroupTracking' method.
           */
          interface SetInterestGroupTrackingParams {
              enable: boolean;
          }
          /**
           * Return value of the 'Storage.setInterestGroupTracking' method.
           */
          interface SetInterestGroupTrackingResult {
          }
          /**
           * Parameters of the 'Storage.getSharedStorageMetadata' method.
           */
          interface GetSharedStorageMetadataParams {
              ownerOrigin: string;
          }
          /**
           * Return value of the 'Storage.getSharedStorageMetadata' method.
           */
          interface GetSharedStorageMetadataResult {
              metadata: SharedStorageMetadata;
          }
          /**
           * Parameters of the 'Storage.getSharedStorageEntries' method.
           */
          interface GetSharedStorageEntriesParams {
              ownerOrigin: string;
          }
          /**
           * Return value of the 'Storage.getSharedStorageEntries' method.
           */
          interface GetSharedStorageEntriesResult {
              entries: SharedStorageEntry[];
          }
          /**
           * Parameters of the 'Storage.setSharedStorageEntry' method.
           */
          interface SetSharedStorageEntryParams {
              ownerOrigin: string;
              key: string;
              value: string;
              /**
               * If `ignoreIfPresent` is included and true, then only sets the entry if
               * `key` doesn't already exist.
               */
              ignoreIfPresent?: boolean;
          }
          /**
           * Return value of the 'Storage.setSharedStorageEntry' method.
           */
          interface SetSharedStorageEntryResult {
          }
          /**
           * Parameters of the 'Storage.deleteSharedStorageEntry' method.
           */
          interface DeleteSharedStorageEntryParams {
              ownerOrigin: string;
              key: string;
          }
          /**
           * Return value of the 'Storage.deleteSharedStorageEntry' method.
           */
          interface DeleteSharedStorageEntryResult {
          }
          /**
           * Parameters of the 'Storage.clearSharedStorageEntries' method.
           */
          interface ClearSharedStorageEntriesParams {
              ownerOrigin: string;
          }
          /**
           * Return value of the 'Storage.clearSharedStorageEntries' method.
           */
          interface ClearSharedStorageEntriesResult {
          }
          /**
           * Parameters of the 'Storage.resetSharedStorageBudget' method.
           */
          interface ResetSharedStorageBudgetParams {
              ownerOrigin: string;
          }
          /**
           * Return value of the 'Storage.resetSharedStorageBudget' method.
           */
          interface ResetSharedStorageBudgetResult {
          }
          /**
           * Parameters of the 'Storage.setSharedStorageTracking' method.
           */
          interface SetSharedStorageTrackingParams {
              enable: boolean;
          }
          /**
           * Return value of the 'Storage.setSharedStorageTracking' method.
           */
          interface SetSharedStorageTrackingResult {
          }
          /**
           * Parameters of the 'Storage.setStorageBucketTracking' method.
           */
          interface SetStorageBucketTrackingParams {
              storageKey: string;
              enable: boolean;
          }
          /**
           * Return value of the 'Storage.setStorageBucketTracking' method.
           */
          interface SetStorageBucketTrackingResult {
          }
          /**
           * Parameters of the 'Storage.deleteStorageBucket' method.
           */
          interface DeleteStorageBucketParams {
              bucket: StorageBucket;
          }
          /**
           * Return value of the 'Storage.deleteStorageBucket' method.
           */
          interface DeleteStorageBucketResult {
          }
          /**
           * Parameters of the 'Storage.runBounceTrackingMitigations' method.
           */
          interface RunBounceTrackingMitigationsParams {
          }
          /**
           * Return value of the 'Storage.runBounceTrackingMitigations' method.
           */
          interface RunBounceTrackingMitigationsResult {
              deletedSites: string[];
          }
          /**
           * Parameters of the 'Storage.setAttributionReportingLocalTestingMode' method.
           */
          interface SetAttributionReportingLocalTestingModeParams {
              /**
               * If enabled, noise is suppressed and reports are sent immediately.
               */
              enabled: boolean;
          }
          /**
           * Return value of the 'Storage.setAttributionReportingLocalTestingMode' method.
           */
          interface SetAttributionReportingLocalTestingModeResult {
          }
          /**
           * Parameters of the 'Storage.setAttributionReportingTracking' method.
           */
          interface SetAttributionReportingTrackingParams {
              enable: boolean;
          }
          /**
           * Return value of the 'Storage.setAttributionReportingTracking' method.
           */
          interface SetAttributionReportingTrackingResult {
          }
          /**
           * Parameters of the 'Storage.cacheStorageContentUpdated' event.
           */
          interface CacheStorageContentUpdatedEvent {
              /**
               * Origin to update.
               */
              origin: string;
              /**
               * Storage key to update.
               */
              storageKey: string;
              /**
               * Storage bucket to update.
               */
              bucketId: string;
              /**
               * Name of cache in origin.
               */
              cacheName: string;
          }
          /**
           * Parameters of the 'Storage.cacheStorageListUpdated' event.
           */
          interface CacheStorageListUpdatedEvent {
              /**
               * Origin to update.
               */
              origin: string;
              /**
               * Storage key to update.
               */
              storageKey: string;
              /**
               * Storage bucket to update.
               */
              bucketId: string;
          }
          /**
           * Parameters of the 'Storage.indexedDBContentUpdated' event.
           */
          interface IndexedDBContentUpdatedEvent {
              /**
               * Origin to update.
               */
              origin: string;
              /**
               * Storage key to update.
               */
              storageKey: string;
              /**
               * Storage bucket to update.
               */
              bucketId: string;
              /**
               * Database to update.
               */
              databaseName: string;
              /**
               * ObjectStore to update.
               */
              objectStoreName: string;
          }
          /**
           * Parameters of the 'Storage.indexedDBListUpdated' event.
           */
          interface IndexedDBListUpdatedEvent {
              /**
               * Origin to update.
               */
              origin: string;
              /**
               * Storage key to update.
               */
              storageKey: string;
              /**
               * Storage bucket to update.
               */
              bucketId: string;
          }
          /**
           * Parameters of the 'Storage.interestGroupAccessed' event.
           */
          interface InterestGroupAccessedEvent {
              accessTime: Network.TimeSinceEpoch;
              type: InterestGroupAccessType;
              ownerOrigin: string;
              name: string;
          }
          /**
           * Parameters of the 'Storage.sharedStorageAccessed' event.
           */
          interface SharedStorageAccessedEvent {
              /**
               * Time of the access.
               */
              accessTime: Network.TimeSinceEpoch;
              /**
               * Enum value indicating the Shared Storage API method invoked.
               */
              type: SharedStorageAccessType;
              /**
               * DevTools Frame Token for the primary frame tree's root.
               */
              mainFrameId: Page.FrameId;
              /**
               * Serialized origin for the context that invoked the Shared Storage API.
               */
              ownerOrigin: string;
              /**
               * The sub-parameters warapped by `params` are all optional and their
               * presence/absence depends on `type`.
               */
              params: SharedStorageAccessParams;
          }
          /**
           * Parameters of the 'Storage.storageBucketCreatedOrUpdated' event.
           */
          interface StorageBucketCreatedOrUpdatedEvent {
              bucketInfo: StorageBucketInfo;
          }
          /**
           * Parameters of the 'Storage.storageBucketDeleted' event.
           */
          interface StorageBucketDeletedEvent {
              bucketId: string;
          }
          /**
           * Parameters of the 'Storage.attributionReportingSourceRegistered' event.
           */
          interface AttributionReportingSourceRegisteredEvent {
              registration: AttributionReportingSourceRegistration;
              result: AttributionReportingSourceRegistrationResult;
          }
          /**
           * Parameters of the 'Storage.attributionReportingTriggerRegistered' event.
           */
          interface AttributionReportingTriggerRegisteredEvent {
              registration: AttributionReportingTriggerRegistration;
              eventLevel: AttributionReportingEventLevelResult;
              aggregatable: AttributionReportingAggregatableResult;
          }
          type SerializedStorageKey = string;
          /**
           * Enum of possible storage types.
           */
          type StorageType = 'appcache' | 'cookies' | 'file_systems' | 'indexeddb' | 'local_storage' | 'shader_cache' | 'websql' | 'service_workers' | 'cache_storage' | 'interest_groups' | 'shared_storage' | 'storage_buckets' | 'all' | 'other';
          /**
           * Usage for a storage type.
           */
          interface UsageForType {
              /**
               * Name of storage type.
               */
              storageType: StorageType;
              /**
               * Storage usage (bytes).
               */
              usage: number;
          }
          /**
           * Pair of issuer origin and number of available (signed, but not used) Trust
           * Tokens from that issuer.
           */
          interface TrustTokens {
              issuerOrigin: string;
              count: number;
          }
          /**
           * Enum of interest group access types.
           */
          type InterestGroupAccessType = 'join' | 'leave' | 'update' | 'loaded' | 'bid' | 'win' | 'additionalBid' | 'additionalBidWin' | 'clear';
          /**
           * Ad advertising element inside an interest group.
           */
          interface InterestGroupAd {
              renderURL: string;
              metadata?: string;
          }
          /**
           * The full details of an interest group.
           */
          interface InterestGroupDetails {
              ownerOrigin: string;
              name: string;
              expirationTime: Network.TimeSinceEpoch;
              joiningOrigin: string;
              biddingLogicURL?: string;
              biddingWasmHelperURL?: string;
              updateURL?: string;
              trustedBiddingSignalsURL?: string;
              trustedBiddingSignalsKeys: string[];
              userBiddingSignals?: string;
              ads: InterestGroupAd[];
              adComponents: InterestGroupAd[];
          }
          /**
           * Enum of shared storage access types.
           */
          type SharedStorageAccessType = 'documentAddModule' | 'documentSelectURL' | 'documentRun' | 'documentSet' | 'documentAppend' | 'documentDelete' | 'documentClear' | 'workletSet' | 'workletAppend' | 'workletDelete' | 'workletClear' | 'workletGet' | 'workletKeys' | 'workletEntries' | 'workletLength' | 'workletRemainingBudget';
          /**
           * Struct for a single key-value pair in an origin's shared storage.
           */
          interface SharedStorageEntry {
              key: string;
              value: string;
          }
          /**
           * Details for an origin's shared storage.
           */
          interface SharedStorageMetadata {
              creationTime: Network.TimeSinceEpoch;
              length: integer;
              remainingBudget: number;
          }
          /**
           * Pair of reporting metadata details for a candidate URL for `selectURL()`.
           */
          interface SharedStorageReportingMetadata {
              eventType: string;
              reportingUrl: string;
          }
          /**
           * Bundles a candidate URL with its reporting metadata.
           */
          interface SharedStorageUrlWithMetadata {
              /**
               * Spec of candidate URL.
               */
              url: string;
              /**
               * Any associated reporting metadata.
               */
              reportingMetadata: SharedStorageReportingMetadata[];
          }
          /**
           * Bundles the parameters for shared storage access events whose
           * presence/absence can vary according to SharedStorageAccessType.
           */
          interface SharedStorageAccessParams {
              /**
               * Spec of the module script URL.
               * Present only for SharedStorageAccessType.documentAddModule.
               */
              scriptSourceUrl?: string;
              /**
               * Name of the registered operation to be run.
               * Present only for SharedStorageAccessType.documentRun and
               * SharedStorageAccessType.documentSelectURL.
               */
              operationName?: string;
              /**
               * The operation's serialized data in bytes (converted to a string).
               * Present only for SharedStorageAccessType.documentRun and
               * SharedStorageAccessType.documentSelectURL.
               */
              serializedData?: string;
              /**
               * Array of candidate URLs' specs, along with any associated metadata.
               * Present only for SharedStorageAccessType.documentSelectURL.
               */
              urlsWithMetadata?: SharedStorageUrlWithMetadata[];
              /**
               * Key for a specific entry in an origin's shared storage.
               * Present only for SharedStorageAccessType.documentSet,
               * SharedStorageAccessType.documentAppend,
               * SharedStorageAccessType.documentDelete,
               * SharedStorageAccessType.workletSet,
               * SharedStorageAccessType.workletAppend,
               * SharedStorageAccessType.workletDelete, and
               * SharedStorageAccessType.workletGet.
               */
              key?: string;
              /**
               * Value for a specific entry in an origin's shared storage.
               * Present only for SharedStorageAccessType.documentSet,
               * SharedStorageAccessType.documentAppend,
               * SharedStorageAccessType.workletSet, and
               * SharedStorageAccessType.workletAppend.
               */
              value?: string;
              /**
               * Whether or not to set an entry for a key if that key is already present.
               * Present only for SharedStorageAccessType.documentSet and
               * SharedStorageAccessType.workletSet.
               */
              ignoreIfPresent?: boolean;
          }
          type StorageBucketsDurability = 'relaxed' | 'strict';
          interface StorageBucket {
              storageKey: SerializedStorageKey;
              /**
               * If not specified, it is the default bucket of the storageKey.
               */
              name?: string;
          }
          interface StorageBucketInfo {
              bucket: StorageBucket;
              id: string;
              expiration: Network.TimeSinceEpoch;
              /**
               * Storage quota (bytes).
               */
              quota: number;
              persistent: boolean;
              durability: StorageBucketsDurability;
          }
          type AttributionReportingSourceType = 'navigation' | 'event';
          type UnsignedInt64AsBase10 = string;
          type UnsignedInt128AsBase16 = string;
          type SignedInt64AsBase10 = string;
          interface AttributionReportingFilterDataEntry {
              key: string;
              values: string[];
          }
          interface AttributionReportingFilterConfig {
              filterValues: AttributionReportingFilterDataEntry[];
              /**
               * duration in seconds
               */
              lookbackWindow?: integer;
          }
          interface AttributionReportingFilterPair {
              filters: AttributionReportingFilterConfig[];
              notFilters: AttributionReportingFilterConfig[];
          }
          interface AttributionReportingAggregationKeysEntry {
              key: string;
              value: UnsignedInt128AsBase16;
          }
          interface AttributionReportingEventReportWindows {
              /**
               * duration in seconds
               */
              start: integer;
              /**
               * duration in seconds
               */
              ends: integer[];
          }
          interface AttributionReportingTriggerSpec {
              /**
               * number instead of integer because not all uint32 can be represented by
               * int
               */
              triggerData: number[];
              eventReportWindows: AttributionReportingEventReportWindows;
          }
          type AttributionReportingTriggerDataMatching = 'exact' | 'modulus';
          interface AttributionReportingSourceRegistration {
              time: Network.TimeSinceEpoch;
              /**
               * duration in seconds
               */
              expiry: integer;
              triggerSpecs: AttributionReportingTriggerSpec[];
              /**
               * duration in seconds
               */
              aggregatableReportWindow: integer;
              type: AttributionReportingSourceType;
              sourceOrigin: string;
              reportingOrigin: string;
              destinationSites: string[];
              eventId: UnsignedInt64AsBase10;
              priority: SignedInt64AsBase10;
              filterData: AttributionReportingFilterDataEntry[];
              aggregationKeys: AttributionReportingAggregationKeysEntry[];
              debugKey?: UnsignedInt64AsBase10;
              triggerDataMatching: AttributionReportingTriggerDataMatching;
          }
          type AttributionReportingSourceRegistrationResult = 'success' | 'internalError' | 'insufficientSourceCapacity' | 'insufficientUniqueDestinationCapacity' | 'excessiveReportingOrigins' | 'prohibitedByBrowserPolicy' | 'successNoised' | 'destinationReportingLimitReached' | 'destinationGlobalLimitReached' | 'destinationBothLimitsReached' | 'reportingOriginsPerSiteLimitReached' | 'exceedsMaxChannelCapacity';
          type AttributionReportingSourceRegistrationTimeConfig = 'include' | 'exclude';
          interface AttributionReportingAggregatableValueEntry {
              key: string;
              /**
               * number instead of integer because not all uint32 can be represented by
               * int
               */
              value: number;
          }
          interface AttributionReportingEventTriggerData {
              data: UnsignedInt64AsBase10;
              priority: SignedInt64AsBase10;
              dedupKey?: UnsignedInt64AsBase10;
              filters: AttributionReportingFilterPair;
          }
          interface AttributionReportingAggregatableTriggerData {
              keyPiece: UnsignedInt128AsBase16;
              sourceKeys: string[];
              filters: AttributionReportingFilterPair;
          }
          interface AttributionReportingAggregatableDedupKey {
              dedupKey?: UnsignedInt64AsBase10;
              filters: AttributionReportingFilterPair;
          }
          interface AttributionReportingTriggerRegistration {
              filters: AttributionReportingFilterPair;
              debugKey?: UnsignedInt64AsBase10;
              aggregatableDedupKeys: AttributionReportingAggregatableDedupKey[];
              eventTriggerData: AttributionReportingEventTriggerData[];
              aggregatableTriggerData: AttributionReportingAggregatableTriggerData[];
              aggregatableValues: AttributionReportingAggregatableValueEntry[];
              debugReporting: boolean;
              aggregationCoordinatorOrigin?: string;
              sourceRegistrationTimeConfig: AttributionReportingSourceRegistrationTimeConfig;
              triggerContextId?: string;
          }
          type AttributionReportingEventLevelResult = 'success' | 'successDroppedLowerPriority' | 'internalError' | 'noCapacityForAttributionDestination' | 'noMatchingSources' | 'deduplicated' | 'excessiveAttributions' | 'priorityTooLow' | 'neverAttributedSource' | 'excessiveReportingOrigins' | 'noMatchingSourceFilterData' | 'prohibitedByBrowserPolicy' | 'noMatchingConfigurations' | 'excessiveReports' | 'falselyAttributedSource' | 'reportWindowPassed' | 'notRegistered' | 'reportWindowNotStarted' | 'noMatchingTriggerData';
          type AttributionReportingAggregatableResult = 'success' | 'internalError' | 'noCapacityForAttributionDestination' | 'noMatchingSources' | 'excessiveAttributions' | 'excessiveReportingOrigins' | 'noHistograms' | 'insufficientBudget' | 'noMatchingSourceFilterData' | 'notRegistered' | 'prohibitedByBrowserPolicy' | 'deduplicated' | 'reportWindowPassed' | 'excessiveReports';
      }
      /**
       * Methods and events of the 'SystemInfo' domain.
       */
      interface SystemInfoApi {
          requests: {
              /**
               * Returns information about the system.
               */
              getInfo: {
                  params: SystemInfo.GetInfoParams;
                  result: SystemInfo.GetInfoResult;
              };
              /**
               * Returns information about the feature state.
               */
              getFeatureState: {
                  params: SystemInfo.GetFeatureStateParams;
                  result: SystemInfo.GetFeatureStateResult;
              };
              /**
               * Returns information about all running processes.
               */
              getProcessInfo: {
                  params: SystemInfo.GetProcessInfoParams;
                  result: SystemInfo.GetProcessInfoResult;
              };
          };
          events: {};
      }
      /**
       * Types of the 'SystemInfo' domain.
       */
      namespace SystemInfo {
          /**
           * Parameters of the 'SystemInfo.getInfo' method.
           */
          interface GetInfoParams {
          }
          /**
           * Return value of the 'SystemInfo.getInfo' method.
           */
          interface GetInfoResult {
              /**
               * Information about the GPUs on the system.
               */
              gpu: GPUInfo;
              /**
               * A platform-dependent description of the model of the machine. On Mac OS, this is, for
               * example, 'MacBookPro'. Will be the empty string if not supported.
               */
              modelName: string;
              /**
               * A platform-dependent description of the version of the machine. On Mac OS, this is, for
               * example, '10.1'. Will be the empty string if not supported.
               */
              modelVersion: string;
              /**
               * The command line string used to launch the browser. Will be the empty string if not
               * supported.
               */
              commandLine: string;
          }
          /**
           * Parameters of the 'SystemInfo.getFeatureState' method.
           */
          interface GetFeatureStateParams {
              featureState: string;
          }
          /**
           * Return value of the 'SystemInfo.getFeatureState' method.
           */
          interface GetFeatureStateResult {
              featureEnabled: boolean;
          }
          /**
           * Parameters of the 'SystemInfo.getProcessInfo' method.
           */
          interface GetProcessInfoParams {
          }
          /**
           * Return value of the 'SystemInfo.getProcessInfo' method.
           */
          interface GetProcessInfoResult {
              /**
               * An array of process info blocks.
               */
              processInfo: ProcessInfo[];
          }
          /**
           * Describes a single graphics processor (GPU).
           */
          interface GPUDevice {
              /**
               * PCI ID of the GPU vendor, if available; 0 otherwise.
               */
              vendorId: number;
              /**
               * PCI ID of the GPU device, if available; 0 otherwise.
               */
              deviceId: number;
              /**
               * Sub sys ID of the GPU, only available on Windows.
               */
              subSysId?: number;
              /**
               * Revision of the GPU, only available on Windows.
               */
              revision?: number;
              /**
               * String description of the GPU vendor, if the PCI ID is not available.
               */
              vendorString: string;
              /**
               * String description of the GPU device, if the PCI ID is not available.
               */
              deviceString: string;
              /**
               * String description of the GPU driver vendor.
               */
              driverVendor: string;
              /**
               * String description of the GPU driver version.
               */
              driverVersion: string;
          }
          /**
           * Describes the width and height dimensions of an entity.
           */
          interface Size {
              /**
               * Width in pixels.
               */
              width: integer;
              /**
               * Height in pixels.
               */
              height: integer;
          }
          /**
           * Describes a supported video decoding profile with its associated minimum and
           * maximum resolutions.
           */
          interface VideoDecodeAcceleratorCapability {
              /**
               * Video codec profile that is supported, e.g. VP9 Profile 2.
               */
              profile: string;
              /**
               * Maximum video dimensions in pixels supported for this |profile|.
               */
              maxResolution: Size;
              /**
               * Minimum video dimensions in pixels supported for this |profile|.
               */
              minResolution: Size;
          }
          /**
           * Describes a supported video encoding profile with its associated maximum
           * resolution and maximum framerate.
           */
          interface VideoEncodeAcceleratorCapability {
              /**
               * Video codec profile that is supported, e.g H264 Main.
               */
              profile: string;
              /**
               * Maximum video dimensions in pixels supported for this |profile|.
               */
              maxResolution: Size;
              /**
               * Maximum encoding framerate in frames per second supported for this
               * |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
               * 24000/1001 fps, etc.
               */
              maxFramerateNumerator: integer;
              maxFramerateDenominator: integer;
          }
          /**
           * YUV subsampling type of the pixels of a given image.
           */
          type SubsamplingFormat = 'yuv420' | 'yuv422' | 'yuv444';
          /**
           * Image format of a given image.
           */
          type ImageType = 'jpeg' | 'webp' | 'unknown';
          /**
           * Describes a supported image decoding profile with its associated minimum and
           * maximum resolutions and subsampling.
           */
          interface ImageDecodeAcceleratorCapability {
              /**
               * Image coded, e.g. Jpeg.
               */
              imageType: ImageType;
              /**
               * Maximum supported dimensions of the image in pixels.
               */
              maxDimensions: Size;
              /**
               * Minimum supported dimensions of the image in pixels.
               */
              minDimensions: Size;
              /**
               * Optional array of supported subsampling formats, e.g. 4:2:0, if known.
               */
              subsamplings: SubsamplingFormat[];
          }
          /**
           * Provides information about the GPU(s) on the system.
           */
          interface GPUInfo {
              /**
               * The graphics devices on the system. Element 0 is the primary GPU.
               */
              devices: GPUDevice[];
              /**
               * An optional dictionary of additional GPU related attributes.
               */
              auxAttributes?: Record<string, unknown>;
              /**
               * An optional dictionary of graphics features and their status.
               */
              featureStatus?: Record<string, unknown>;
              /**
               * An optional array of GPU driver bug workarounds.
               */
              driverBugWorkarounds: string[];
              /**
               * Supported accelerated video decoding capabilities.
               */
              videoDecoding: VideoDecodeAcceleratorCapability[];
              /**
               * Supported accelerated video encoding capabilities.
               */
              videoEncoding: VideoEncodeAcceleratorCapability[];
              /**
               * Supported accelerated image decoding capabilities.
               */
              imageDecoding: ImageDecodeAcceleratorCapability[];
          }
          /**
           * Represents process info.
           */
          interface ProcessInfo {
              /**
               * Specifies process type.
               */
              type: string;
              /**
               * Specifies process id.
               */
              id: integer;
              /**
               * Specifies cumulative CPU usage in seconds across all threads of the
               * process since the process start.
               */
              cpuTime: number;
          }
      }
      /**
       * Methods and events of the 'Target' domain.
       */
      interface TargetApi {
          requests: {
              /**
               * Activates (focuses) the target.
               */
              activateTarget: {
                  params: Target.ActivateTargetParams;
                  result: Target.ActivateTargetResult;
              };
              /**
               * Attaches to the target with given id.
               */
              attachToTarget: {
                  params: Target.AttachToTargetParams;
                  result: Target.AttachToTargetResult;
              };
              /**
               * Attaches to the browser target, only uses flat sessionId mode.
               */
              attachToBrowserTarget: {
                  params: Target.AttachToBrowserTargetParams;
                  result: Target.AttachToBrowserTargetResult;
              };
              /**
               * Closes the target. If the target is a page that gets closed too.
               */
              closeTarget: {
                  params: Target.CloseTargetParams;
                  result: Target.CloseTargetResult;
              };
              /**
               * Inject object to the target's main frame that provides a communication
               * channel with browser target.
               *
               * Injected object will be available as `window[bindingName]`.
               *
               * The object has the follwing API:
               * - `binding.send(json)` - a method to send messages over the remote debugging protocol
               * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
               */
              exposeDevToolsProtocol: {
                  params: Target.ExposeDevToolsProtocolParams;
                  result: Target.ExposeDevToolsProtocolResult;
              };
              /**
               * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
               * one.
               */
              createBrowserContext: {
                  params: Target.CreateBrowserContextParams;
                  result: Target.CreateBrowserContextResult;
              };
              /**
               * Returns all browser contexts created with `Target.createBrowserContext` method.
               */
              getBrowserContexts: {
                  params: Target.GetBrowserContextsParams;
                  result: Target.GetBrowserContextsResult;
              };
              /**
               * Creates a new page.
               */
              createTarget: {
                  params: Target.CreateTargetParams;
                  result: Target.CreateTargetResult;
              };
              /**
               * Detaches session with given id.
               */
              detachFromTarget: {
                  params: Target.DetachFromTargetParams;
                  result: Target.DetachFromTargetResult;
              };
              /**
               * Deletes a BrowserContext. All the belonging pages will be closed without calling their
               * beforeunload hooks.
               */
              disposeBrowserContext: {
                  params: Target.DisposeBrowserContextParams;
                  result: Target.DisposeBrowserContextResult;
              };
              /**
               * Returns information about a target.
               */
              getTargetInfo: {
                  params: Target.GetTargetInfoParams;
                  result: Target.GetTargetInfoResult;
              };
              /**
               * Retrieves a list of available targets.
               */
              getTargets: {
                  params: Target.GetTargetsParams;
                  result: Target.GetTargetsResult;
              };
              /**
               * Sends protocol message over session with given id.
               * Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
               * and crbug.com/991325.
               * @deprecated
               */
              sendMessageToTarget: {
                  params: Target.SendMessageToTargetParams;
                  result: Target.SendMessageToTargetResult;
              };
              /**
               * Controls whether to automatically attach to new targets which are considered to be related to
               * this one. When turned on, attaches to all existing related targets as well. When turned off,
               * automatically detaches from all currently attached targets.
               * This also clears all targets added by `autoAttachRelated` from the list of targets to watch
               * for creation of related targets.
               */
              setAutoAttach: {
                  params: Target.SetAutoAttachParams;
                  result: Target.SetAutoAttachResult;
              };
              /**
               * Adds the specified target to the list of targets that will be monitored for any related target
               * creation (such as child frames, child workers and new versions of service worker) and reported
               * through `attachedToTarget`. The specified target is also auto-attached.
               * This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
               * `setAutoAttach`. Only available at the Browser target.
               */
              autoAttachRelated: {
                  params: Target.AutoAttachRelatedParams;
                  result: Target.AutoAttachRelatedResult;
              };
              /**
               * Controls whether to discover available targets and notify via
               * `targetCreated/targetInfoChanged/targetDestroyed` events.
               */
              setDiscoverTargets: {
                  params: Target.SetDiscoverTargetsParams;
                  result: Target.SetDiscoverTargetsResult;
              };
              /**
               * Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
               * `true`.
               */
              setRemoteLocations: {
                  params: Target.SetRemoteLocationsParams;
                  result: Target.SetRemoteLocationsResult;
              };
          };
          events: {
              /**
               * Issued when attached to target because of auto-attach or `attachToTarget` command.
               */
              attachedToTarget: {
                  params: Target.AttachedToTargetEvent;
              };
              /**
               * Issued when detached from target for any reason (including `detachFromTarget` command). Can be
               * issued multiple times per target if multiple sessions have been attached to it.
               */
              detachedFromTarget: {
                  params: Target.DetachedFromTargetEvent;
              };
              /**
               * Notifies about a new protocol message received from the session (as reported in
               * `attachedToTarget` event).
               */
              receivedMessageFromTarget: {
                  params: Target.ReceivedMessageFromTargetEvent;
              };
              /**
               * Issued when a possible inspection target is created.
               */
              targetCreated: {
                  params: Target.TargetCreatedEvent;
              };
              /**
               * Issued when a target is destroyed.
               */
              targetDestroyed: {
                  params: Target.TargetDestroyedEvent;
              };
              /**
               * Issued when a target has crashed.
               */
              targetCrashed: {
                  params: Target.TargetCrashedEvent;
              };
              /**
               * Issued when some information about a target has changed. This only happens between
               * `targetCreated` and `targetDestroyed`.
               */
              targetInfoChanged: {
                  params: Target.TargetInfoChangedEvent;
              };
          };
      }
      /**
       * Types of the 'Target' domain.
       */
      namespace Target {
          /**
           * Parameters of the 'Target.activateTarget' method.
           */
          interface ActivateTargetParams {
              targetId: TargetID;
          }
          /**
           * Return value of the 'Target.activateTarget' method.
           */
          interface ActivateTargetResult {
          }
          /**
           * Parameters of the 'Target.attachToTarget' method.
           */
          interface AttachToTargetParams {
              targetId: TargetID;
              /**
               * Enables "flat" access to the session via specifying sessionId attribute in the commands.
               * We plan to make this the default, deprecate non-flattened mode,
               * and eventually retire it. See crbug.com/991325.
               */
              flatten?: boolean;
          }
          /**
           * Return value of the 'Target.attachToTarget' method.
           */
          interface AttachToTargetResult {
              /**
               * Id assigned to the session.
               */
              sessionId: SessionID;
          }
          /**
           * Parameters of the 'Target.attachToBrowserTarget' method.
           */
          interface AttachToBrowserTargetParams {
          }
          /**
           * Return value of the 'Target.attachToBrowserTarget' method.
           */
          interface AttachToBrowserTargetResult {
              /**
               * Id assigned to the session.
               */
              sessionId: SessionID;
          }
          /**
           * Parameters of the 'Target.closeTarget' method.
           */
          interface CloseTargetParams {
              targetId: TargetID;
          }
          /**
           * Return value of the 'Target.closeTarget' method.
           */
          interface CloseTargetResult {
              /**
               * Always set to true. If an error occurs, the response indicates protocol error.
               * @deprecated
               */
              success: boolean;
          }
          /**
           * Parameters of the 'Target.exposeDevToolsProtocol' method.
           */
          interface ExposeDevToolsProtocolParams {
              targetId: TargetID;
              /**
               * Binding name, 'cdp' if not specified.
               */
              bindingName?: string;
          }
          /**
           * Return value of the 'Target.exposeDevToolsProtocol' method.
           */
          interface ExposeDevToolsProtocolResult {
          }
          /**
           * Parameters of the 'Target.createBrowserContext' method.
           */
          interface CreateBrowserContextParams {
              /**
               * If specified, disposes this context when debugging session disconnects.
               */
              disposeOnDetach?: boolean;
              /**
               * Proxy server, similar to the one passed to --proxy-server
               */
              proxyServer?: string;
              /**
               * Proxy bypass list, similar to the one passed to --proxy-bypass-list
               */
              proxyBypassList?: string;
              /**
               * An optional list of origins to grant unlimited cross-origin access to.
               * Parts of the URL other than those constituting origin are ignored.
               */
              originsWithUniversalNetworkAccess?: string[];
          }
          /**
           * Return value of the 'Target.createBrowserContext' method.
           */
          interface CreateBrowserContextResult {
              /**
               * The id of the context created.
               */
              browserContextId: Browser.BrowserContextID;
          }
          /**
           * Parameters of the 'Target.getBrowserContexts' method.
           */
          interface GetBrowserContextsParams {
          }
          /**
           * Return value of the 'Target.getBrowserContexts' method.
           */
          interface GetBrowserContextsResult {
              /**
               * An array of browser context ids.
               */
              browserContextIds: Browser.BrowserContextID[];
          }
          /**
           * Parameters of the 'Target.createTarget' method.
           */
          interface CreateTargetParams {
              /**
               * The initial URL the page will be navigated to. An empty string indicates about:blank.
               */
              url: string;
              /**
               * Frame width in DIP (headless chrome only).
               */
              width?: integer;
              /**
               * Frame height in DIP (headless chrome only).
               */
              height?: integer;
              /**
               * The browser context to create the page in.
               */
              browserContextId?: Browser.BrowserContextID;
              /**
               * Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
               * not supported on MacOS yet, false by default).
               */
              enableBeginFrameControl?: boolean;
              /**
               * Whether to create a new Window or Tab (chrome-only, false by default).
               */
              newWindow?: boolean;
              /**
               * Whether to create the target in background or foreground (chrome-only,
               * false by default).
               */
              background?: boolean;
              /**
               * Whether to create the target of type "tab".
               */
              forTab?: boolean;
          }
          /**
           * Return value of the 'Target.createTarget' method.
           */
          interface CreateTargetResult {
              /**
               * The id of the page opened.
               */
              targetId: TargetID;
          }
          /**
           * Parameters of the 'Target.detachFromTarget' method.
           */
          interface DetachFromTargetParams {
              /**
               * Session to detach.
               */
              sessionId?: SessionID;
              /**
               * Deprecated.
               * @deprecated
               */
              targetId?: TargetID;
          }
          /**
           * Return value of the 'Target.detachFromTarget' method.
           */
          interface DetachFromTargetResult {
          }
          /**
           * Parameters of the 'Target.disposeBrowserContext' method.
           */
          interface DisposeBrowserContextParams {
              browserContextId: Browser.BrowserContextID;
          }
          /**
           * Return value of the 'Target.disposeBrowserContext' method.
           */
          interface DisposeBrowserContextResult {
          }
          /**
           * Parameters of the 'Target.getTargetInfo' method.
           */
          interface GetTargetInfoParams {
              targetId?: TargetID;
          }
          /**
           * Return value of the 'Target.getTargetInfo' method.
           */
          interface GetTargetInfoResult {
              targetInfo: TargetInfo;
          }
          /**
           * Parameters of the 'Target.getTargets' method.
           */
          interface GetTargetsParams {
              /**
               * Only targets matching filter will be reported. If filter is not specified
               * and target discovery is currently enabled, a filter used for target discovery
               * is used for consistency.
               */
              filter?: TargetFilter;
          }
          /**
           * Return value of the 'Target.getTargets' method.
           */
          interface GetTargetsResult {
              /**
               * The list of targets.
               */
              targetInfos: TargetInfo[];
          }
          /**
           * Parameters of the 'Target.sendMessageToTarget' method.
           */
          interface SendMessageToTargetParams {
              message: string;
              /**
               * Identifier of the session.
               */
              sessionId?: SessionID;
              /**
               * Deprecated.
               * @deprecated
               */
              targetId?: TargetID;
          }
          /**
           * Return value of the 'Target.sendMessageToTarget' method.
           */
          interface SendMessageToTargetResult {
          }
          /**
           * Parameters of the 'Target.setAutoAttach' method.
           */
          interface SetAutoAttachParams {
              /**
               * Whether to auto-attach to related targets.
               */
              autoAttach: boolean;
              /**
               * Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
               * to run paused targets.
               */
              waitForDebuggerOnStart: boolean;
              /**
               * Enables "flat" access to the session via specifying sessionId attribute in the commands.
               * We plan to make this the default, deprecate non-flattened mode,
               * and eventually retire it. See crbug.com/991325.
               */
              flatten?: boolean;
              /**
               * Only targets matching filter will be attached.
               */
              filter?: TargetFilter;
          }
          /**
           * Return value of the 'Target.setAutoAttach' method.
           */
          interface SetAutoAttachResult {
          }
          /**
           * Parameters of the 'Target.autoAttachRelated' method.
           */
          interface AutoAttachRelatedParams {
              targetId: TargetID;
              /**
               * Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
               * to run paused targets.
               */
              waitForDebuggerOnStart: boolean;
              /**
               * Only targets matching filter will be attached.
               */
              filter?: TargetFilter;
          }
          /**
           * Return value of the 'Target.autoAttachRelated' method.
           */
          interface AutoAttachRelatedResult {
          }
          /**
           * Parameters of the 'Target.setDiscoverTargets' method.
           */
          interface SetDiscoverTargetsParams {
              /**
               * Whether to discover available targets.
               */
              discover: boolean;
              /**
               * Only targets matching filter will be attached. If `discover` is false,
               * `filter` must be omitted or empty.
               */
              filter?: TargetFilter;
          }
          /**
           * Return value of the 'Target.setDiscoverTargets' method.
           */
          interface SetDiscoverTargetsResult {
          }
          /**
           * Parameters of the 'Target.setRemoteLocations' method.
           */
          interface SetRemoteLocationsParams {
              /**
               * List of remote locations.
               */
              locations: RemoteLocation[];
          }
          /**
           * Return value of the 'Target.setRemoteLocations' method.
           */
          interface SetRemoteLocationsResult {
          }
          /**
           * Parameters of the 'Target.attachedToTarget' event.
           */
          interface AttachedToTargetEvent {
              /**
               * Identifier assigned to the session used to send/receive messages.
               */
              sessionId: SessionID;
              targetInfo: TargetInfo;
              waitingForDebugger: boolean;
          }
          /**
           * Parameters of the 'Target.detachedFromTarget' event.
           */
          interface DetachedFromTargetEvent {
              /**
               * Detached session identifier.
               */
              sessionId: SessionID;
              /**
               * Deprecated.
               * @deprecated
               */
              targetId?: TargetID;
          }
          /**
           * Parameters of the 'Target.receivedMessageFromTarget' event.
           */
          interface ReceivedMessageFromTargetEvent {
              /**
               * Identifier of a session which sends a message.
               */
              sessionId: SessionID;
              message: string;
              /**
               * Deprecated.
               * @deprecated
               */
              targetId?: TargetID;
          }
          /**
           * Parameters of the 'Target.targetCreated' event.
           */
          interface TargetCreatedEvent {
              targetInfo: TargetInfo;
          }
          /**
           * Parameters of the 'Target.targetDestroyed' event.
           */
          interface TargetDestroyedEvent {
              targetId: TargetID;
          }
          /**
           * Parameters of the 'Target.targetCrashed' event.
           */
          interface TargetCrashedEvent {
              targetId: TargetID;
              /**
               * Termination status type.
               */
              status: string;
              /**
               * Termination error code.
               */
              errorCode: integer;
          }
          /**
           * Parameters of the 'Target.targetInfoChanged' event.
           */
          interface TargetInfoChangedEvent {
              targetInfo: TargetInfo;
          }
          type TargetID = string;
          /**
           * Unique identifier of attached debugging session.
           */
          type SessionID = string;
          interface TargetInfo {
              targetId: TargetID;
              type: string;
              title: string;
              url: string;
              /**
               * Whether the target has an attached client.
               */
              attached: boolean;
              /**
               * Opener target Id
               */
              openerId?: TargetID;
              /**
               * Whether the target has access to the originating window.
               */
              canAccessOpener: boolean;
              /**
               * Frame id of originating window (is only set if target has an opener).
               */
              openerFrameId?: Page.FrameId;
              browserContextId?: Browser.BrowserContextID;
              /**
               * Provides additional details for specific target types. For example, for
               * the type of "page", this may be set to "portal" or "prerender".
               */
              subtype?: string;
          }
          /**
           * A filter used by target query/discovery/auto-attach operations.
           */
          interface FilterEntry {
              /**
               * If set, causes exclusion of mathcing targets from the list.
               */
              exclude?: boolean;
              /**
               * If not present, matches any type.
               */
              type?: string;
          }
          /**
           * The entries in TargetFilter are matched sequentially against targets and
           * the first entry that matches determines if the target is included or not,
           * depending on the value of `exclude` field in the entry.
           * If filter is not specified, the one assumed is
           * [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
           * (i.e. include everything but `browser` and `tab`).
           */
          type TargetFilter = FilterEntry[];
          interface RemoteLocation {
              host: string;
              port: integer;
          }
      }
      /**
       * Methods and events of the 'Tethering' domain.
       */
      interface TetheringApi {
          requests: {
              /**
               * Request browser port binding.
               */
              bind: {
                  params: Tethering.BindParams;
                  result: Tethering.BindResult;
              };
              /**
               * Request browser port unbinding.
               */
              unbind: {
                  params: Tethering.UnbindParams;
                  result: Tethering.UnbindResult;
              };
          };
          events: {
              /**
               * Informs that port was successfully bound and got a specified connection id.
               */
              accepted: {
                  params: Tethering.AcceptedEvent;
              };
          };
      }
      /**
       * Types of the 'Tethering' domain.
       */
      namespace Tethering {
          /**
           * Parameters of the 'Tethering.bind' method.
           */
          interface BindParams {
              /**
               * Port number to bind.
               */
              port: integer;
          }
          /**
           * Return value of the 'Tethering.bind' method.
           */
          interface BindResult {
          }
          /**
           * Parameters of the 'Tethering.unbind' method.
           */
          interface UnbindParams {
              /**
               * Port number to unbind.
               */
              port: integer;
          }
          /**
           * Return value of the 'Tethering.unbind' method.
           */
          interface UnbindResult {
          }
          /**
           * Parameters of the 'Tethering.accepted' event.
           */
          interface AcceptedEvent {
              /**
               * Port number that was successfully bound.
               */
              port: integer;
              /**
               * Connection id to be used.
               */
              connectionId: string;
          }
      }
      /**
       * Methods and events of the 'Tracing' domain.
       */
      interface TracingApi {
          requests: {
              /**
               * Stop trace events collection.
               */
              end: {
                  params: Tracing.EndParams;
                  result: Tracing.EndResult;
              };
              /**
               * Gets supported tracing categories.
               */
              getCategories: {
                  params: Tracing.GetCategoriesParams;
                  result: Tracing.GetCategoriesResult;
              };
              /**
               * Record a clock sync marker in the trace.
               */
              recordClockSyncMarker: {
                  params: Tracing.RecordClockSyncMarkerParams;
                  result: Tracing.RecordClockSyncMarkerResult;
              };
              /**
               * Request a global memory dump.
               */
              requestMemoryDump: {
                  params: Tracing.RequestMemoryDumpParams;
                  result: Tracing.RequestMemoryDumpResult;
              };
              /**
               * Start trace events collection.
               */
              start: {
                  params: Tracing.StartParams;
                  result: Tracing.StartResult;
              };
          };
          events: {
              bufferUsage: {
                  params: Tracing.BufferUsageEvent;
              };
              /**
               * Contains a bucket of collected trace events. When tracing is stopped collected events will be
               * sent as a sequence of dataCollected events followed by tracingComplete event.
               */
              dataCollected: {
                  params: Tracing.DataCollectedEvent;
              };
              /**
               * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
               * delivered via dataCollected events.
               */
              tracingComplete: {
                  params: Tracing.TracingCompleteEvent;
              };
          };
      }
      /**
       * Types of the 'Tracing' domain.
       */
      namespace Tracing {
          /**
           * Parameters of the 'Tracing.end' method.
           */
          interface EndParams {
          }
          /**
           * Return value of the 'Tracing.end' method.
           */
          interface EndResult {
          }
          /**
           * Parameters of the 'Tracing.getCategories' method.
           */
          interface GetCategoriesParams {
          }
          /**
           * Return value of the 'Tracing.getCategories' method.
           */
          interface GetCategoriesResult {
              /**
               * A list of supported tracing categories.
               */
              categories: string[];
          }
          /**
           * Parameters of the 'Tracing.recordClockSyncMarker' method.
           */
          interface RecordClockSyncMarkerParams {
              /**
               * The ID of this clock sync marker
               */
              syncId: string;
          }
          /**
           * Return value of the 'Tracing.recordClockSyncMarker' method.
           */
          interface RecordClockSyncMarkerResult {
          }
          /**
           * Parameters of the 'Tracing.requestMemoryDump' method.
           */
          interface RequestMemoryDumpParams {
              /**
               * Enables more deterministic results by forcing garbage collection
               */
              deterministic?: boolean;
              /**
               * Specifies level of details in memory dump. Defaults to "detailed".
               */
              levelOfDetail?: MemoryDumpLevelOfDetail;
          }
          /**
           * Return value of the 'Tracing.requestMemoryDump' method.
           */
          interface RequestMemoryDumpResult {
              /**
               * GUID of the resulting global memory dump.
               */
              dumpGuid: string;
              /**
               * True iff the global memory dump succeeded.
               */
              success: boolean;
          }
          /**
           * Parameters of the 'Tracing.start' method.
           */
          interface StartParams {
              /**
               * Category/tag filter
               * @deprecated
               */
              categories?: string;
              /**
               * Tracing options
               * @deprecated
               */
              options?: string;
              /**
               * If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
               */
              bufferUsageReportingInterval?: number;
              /**
               * Whether to report trace events as series of dataCollected events or to save trace to a
               * stream (defaults to `ReportEvents`).
               */
              transferMode?: 'ReportEvents' | 'ReturnAsStream';
              /**
               * Trace data format to use. This only applies when using `ReturnAsStream`
               * transfer mode (defaults to `json`).
               */
              streamFormat?: StreamFormat;
              /**
               * Compression format to use. This only applies when using `ReturnAsStream`
               * transfer mode (defaults to `none`)
               */
              streamCompression?: StreamCompression;
              traceConfig?: TraceConfig;
              /**
               * Base64-encoded serialized perfetto.protos.TraceConfig protobuf message
               * When specified, the parameters `categories`, `options`, `traceConfig`
               * are ignored. (Encoded as a base64 string when passed over JSON)
               */
              perfettoConfig?: string;
              /**
               * Backend type (defaults to `auto`)
               */
              tracingBackend?: TracingBackend;
          }
          /**
           * Return value of the 'Tracing.start' method.
           */
          interface StartResult {
          }
          /**
           * Parameters of the 'Tracing.bufferUsage' event.
           */
          interface BufferUsageEvent {
              /**
               * A number in range [0..1] that indicates the used size of event buffer as a fraction of its
               * total size.
               */
              percentFull?: number;
              /**
               * An approximate number of events in the trace log.
               */
              eventCount?: number;
              /**
               * A number in range [0..1] that indicates the used size of event buffer as a fraction of its
               * total size.
               */
              value?: number;
          }
          /**
           * Parameters of the 'Tracing.dataCollected' event.
           */
          interface DataCollectedEvent {
              value: Record<string, unknown>[];
          }
          /**
           * Parameters of the 'Tracing.tracingComplete' event.
           */
          interface TracingCompleteEvent {
              /**
               * Indicates whether some trace data is known to have been lost, e.g. because the trace ring
               * buffer wrapped around.
               */
              dataLossOccurred: boolean;
              /**
               * A handle of the stream that holds resulting trace data.
               */
              stream?: IO.StreamHandle;
              /**
               * Trace data format of returned stream.
               */
              traceFormat?: StreamFormat;
              /**
               * Compression format of returned stream.
               */
              streamCompression?: StreamCompression;
          }
          /**
           * Configuration for memory dump. Used only when "memory-infra" category is enabled.
           */
          interface MemoryDumpConfig {
              [key: string]: any;
          }
          interface TraceConfig {
              /**
               * Controls how the trace buffer stores data.
               */
              recordMode?: 'recordUntilFull' | 'recordContinuously' | 'recordAsMuchAsPossible' | 'echoToConsole';
              /**
               * Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
               * of 200 MB would be used.
               */
              traceBufferSizeInKb?: number;
              /**
               * Turns on JavaScript stack sampling.
               */
              enableSampling?: boolean;
              /**
               * Turns on system tracing.
               */
              enableSystrace?: boolean;
              /**
               * Turns on argument filter.
               */
              enableArgumentFilter?: boolean;
              /**
               * Included category filters.
               */
              includedCategories?: string[];
              /**
               * Excluded category filters.
               */
              excludedCategories?: string[];
              /**
               * Configuration to synthesize the delays in tracing.
               */
              syntheticDelays?: string[];
              /**
               * Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
               */
              memoryDumpConfig?: MemoryDumpConfig;
          }
          /**
           * Data format of a trace. Can be either the legacy JSON format or the
           * protocol buffer format. Note that the JSON format will be deprecated soon.
           */
          type StreamFormat = 'json' | 'proto';
          /**
           * Compression type to use for traces returned via streams.
           */
          type StreamCompression = 'none' | 'gzip';
          /**
           * Details exposed when memory request explicitly declared.
           * Keep consistent with memory_dump_request_args.h and
           * memory_instrumentation.mojom
           */
          type MemoryDumpLevelOfDetail = 'background' | 'light' | 'detailed';
          /**
           * Backend type to use for tracing. `chrome` uses the Chrome-integrated
           * tracing service and is supported on all platforms. `system` is only
           * supported on Chrome OS and uses the Perfetto system tracing service.
           * `auto` chooses `system` when the perfettoConfig provided to Tracing.start
           * specifies at least one non-Chrome data source; otherwise uses `chrome`.
           */
          type TracingBackend = 'auto' | 'chrome' | 'system';
      }
      /**
       * Methods and events of the 'Fetch' domain.
       */
      interface FetchApi {
          requests: {
              /**
               * Disables the fetch domain.
               */
              disable: {
                  params: Fetch.DisableParams;
                  result: Fetch.DisableResult;
              };
              /**
               * Enables issuing of requestPaused events. A request will be paused until client
               * calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
               */
              enable: {
                  params: Fetch.EnableParams;
                  result: Fetch.EnableResult;
              };
              /**
               * Causes the request to fail with specified reason.
               */
              failRequest: {
                  params: Fetch.FailRequestParams;
                  result: Fetch.FailRequestResult;
              };
              /**
               * Provides response to the request.
               */
              fulfillRequest: {
                  params: Fetch.FulfillRequestParams;
                  result: Fetch.FulfillRequestResult;
              };
              /**
               * Continues the request, optionally modifying some of its parameters.
               */
              continueRequest: {
                  params: Fetch.ContinueRequestParams;
                  result: Fetch.ContinueRequestResult;
              };
              /**
               * Continues a request supplying authChallengeResponse following authRequired event.
               */
              continueWithAuth: {
                  params: Fetch.ContinueWithAuthParams;
                  result: Fetch.ContinueWithAuthResult;
              };
              /**
               * Continues loading of the paused response, optionally modifying the
               * response headers. If either responseCode or headers are modified, all of them
               * must be present.
               */
              continueResponse: {
                  params: Fetch.ContinueResponseParams;
                  result: Fetch.ContinueResponseResult;
              };
              /**
               * Causes the body of the response to be received from the server and
               * returned as a single string. May only be issued for a request that
               * is paused in the Response stage and is mutually exclusive with
               * takeResponseBodyForInterceptionAsStream. Calling other methods that
               * affect the request or disabling fetch domain before body is received
               * results in an undefined behavior.
               * Note that the response body is not available for redirects. Requests
               * paused in the _redirect received_ state may be differentiated by
               * `responseCode` and presence of `location` response header, see
               * comments to `requestPaused` for details.
               */
              getResponseBody: {
                  params: Fetch.GetResponseBodyParams;
                  result: Fetch.GetResponseBodyResult;
              };
              /**
               * Returns a handle to the stream representing the response body.
               * The request must be paused in the HeadersReceived stage.
               * Note that after this command the request can't be continued
               * as is -- client either needs to cancel it or to provide the
               * response body.
               * The stream only supports sequential read, IO.read will fail if the position
               * is specified.
               * This method is mutually exclusive with getResponseBody.
               * Calling other methods that affect the request or disabling fetch
               * domain before body is received results in an undefined behavior.
               */
              takeResponseBodyAsStream: {
                  params: Fetch.TakeResponseBodyAsStreamParams;
                  result: Fetch.TakeResponseBodyAsStreamResult;
              };
          };
          events: {
              /**
               * Issued when the domain is enabled and the request URL matches the
               * specified filter. The request is paused until the client responds
               * with one of continueRequest, failRequest or fulfillRequest.
               * The stage of the request can be determined by presence of responseErrorReason
               * and responseStatusCode -- the request is at the response stage if either
               * of these fields is present and in the request stage otherwise.
               * Redirect responses and subsequent requests are reported similarly to regular
               * responses and requests. Redirect responses may be distinguished by the value
               * of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
               * presence of the `location` header. Requests resulting from a redirect will
               * have `redirectedRequestId` field set.
               */
              requestPaused: {
                  params: Fetch.RequestPausedEvent;
              };
              /**
               * Issued when the domain is enabled with handleAuthRequests set to true.
               * The request is paused until client responds with continueWithAuth.
               */
              authRequired: {
                  params: Fetch.AuthRequiredEvent;
              };
          };
      }
      /**
       * Types of the 'Fetch' domain.
       */
      namespace Fetch {
          /**
           * Parameters of the 'Fetch.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Fetch.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Fetch.enable' method.
           */
          interface EnableParams {
              /**
               * If specified, only requests matching any of these patterns will produce
               * fetchRequested event and will be paused until clients response. If not set,
               * all requests will be affected.
               */
              patterns?: RequestPattern[];
              /**
               * If true, authRequired events will be issued and requests will be paused
               * expecting a call to continueWithAuth.
               */
              handleAuthRequests?: boolean;
          }
          /**
           * Return value of the 'Fetch.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Fetch.failRequest' method.
           */
          interface FailRequestParams {
              /**
               * An id the client received in requestPaused event.
               */
              requestId: RequestId;
              /**
               * Causes the request to fail with the given reason.
               */
              errorReason: Network.ErrorReason;
          }
          /**
           * Return value of the 'Fetch.failRequest' method.
           */
          interface FailRequestResult {
          }
          /**
           * Parameters of the 'Fetch.fulfillRequest' method.
           */
          interface FulfillRequestParams {
              /**
               * An id the client received in requestPaused event.
               */
              requestId: RequestId;
              /**
               * An HTTP response code.
               */
              responseCode: integer;
              /**
               * Response headers.
               */
              responseHeaders?: HeaderEntry[];
              /**
               * Alternative way of specifying response headers as a \0-separated
               * series of name: value pairs. Prefer the above method unless you
               * need to represent some non-UTF8 values that can't be transmitted
               * over the protocol as text. (Encoded as a base64 string when passed over JSON)
               */
              binaryResponseHeaders?: string;
              /**
               * A response body. If absent, original response body will be used if
               * the request is intercepted at the response stage and empty body
               * will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
               */
              body?: string;
              /**
               * A textual representation of responseCode.
               * If absent, a standard phrase matching responseCode is used.
               */
              responsePhrase?: string;
          }
          /**
           * Return value of the 'Fetch.fulfillRequest' method.
           */
          interface FulfillRequestResult {
          }
          /**
           * Parameters of the 'Fetch.continueRequest' method.
           */
          interface ContinueRequestParams {
              /**
               * An id the client received in requestPaused event.
               */
              requestId: RequestId;
              /**
               * If set, the request url will be modified in a way that's not observable by page.
               */
              url?: string;
              /**
               * If set, the request method is overridden.
               */
              method?: string;
              /**
               * If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
               */
              postData?: string;
              /**
               * If set, overrides the request headers. Note that the overrides do not
               * extend to subsequent redirect hops, if a redirect happens. Another override
               * may be applied to a different request produced by a redirect.
               */
              headers?: HeaderEntry[];
              /**
               * If set, overrides response interception behavior for this request.
               */
              interceptResponse?: boolean;
          }
          /**
           * Return value of the 'Fetch.continueRequest' method.
           */
          interface ContinueRequestResult {
          }
          /**
           * Parameters of the 'Fetch.continueWithAuth' method.
           */
          interface ContinueWithAuthParams {
              /**
               * An id the client received in authRequired event.
               */
              requestId: RequestId;
              /**
               * Response to  with an authChallenge.
               */
              authChallengeResponse: AuthChallengeResponse;
          }
          /**
           * Return value of the 'Fetch.continueWithAuth' method.
           */
          interface ContinueWithAuthResult {
          }
          /**
           * Parameters of the 'Fetch.continueResponse' method.
           */
          interface ContinueResponseParams {
              /**
               * An id the client received in requestPaused event.
               */
              requestId: RequestId;
              /**
               * An HTTP response code. If absent, original response code will be used.
               */
              responseCode?: integer;
              /**
               * A textual representation of responseCode.
               * If absent, a standard phrase matching responseCode is used.
               */
              responsePhrase?: string;
              /**
               * Response headers. If absent, original response headers will be used.
               */
              responseHeaders?: HeaderEntry[];
              /**
               * Alternative way of specifying response headers as a \0-separated
               * series of name: value pairs. Prefer the above method unless you
               * need to represent some non-UTF8 values that can't be transmitted
               * over the protocol as text. (Encoded as a base64 string when passed over JSON)
               */
              binaryResponseHeaders?: string;
          }
          /**
           * Return value of the 'Fetch.continueResponse' method.
           */
          interface ContinueResponseResult {
          }
          /**
           * Parameters of the 'Fetch.getResponseBody' method.
           */
          interface GetResponseBodyParams {
              /**
               * Identifier for the intercepted request to get body for.
               */
              requestId: RequestId;
          }
          /**
           * Return value of the 'Fetch.getResponseBody' method.
           */
          interface GetResponseBodyResult {
              /**
               * Response body.
               */
              body: string;
              /**
               * True, if content was sent as base64.
               */
              base64Encoded: boolean;
          }
          /**
           * Parameters of the 'Fetch.takeResponseBodyAsStream' method.
           */
          interface TakeResponseBodyAsStreamParams {
              requestId: RequestId;
          }
          /**
           * Return value of the 'Fetch.takeResponseBodyAsStream' method.
           */
          interface TakeResponseBodyAsStreamResult {
              stream: IO.StreamHandle;
          }
          /**
           * Parameters of the 'Fetch.requestPaused' event.
           */
          interface RequestPausedEvent {
              /**
               * Each request the page makes will have a unique id.
               */
              requestId: RequestId;
              /**
               * The details of the request.
               */
              request: Network.Request;
              /**
               * The id of the frame that initiated the request.
               */
              frameId: Page.FrameId;
              /**
               * How the requested resource will be used.
               */
              resourceType: Network.ResourceType;
              /**
               * Response error if intercepted at response stage.
               */
              responseErrorReason?: Network.ErrorReason;
              /**
               * Response code if intercepted at response stage.
               */
              responseStatusCode?: integer;
              /**
               * Response status text if intercepted at response stage.
               */
              responseStatusText?: string;
              /**
               * Response headers if intercepted at the response stage.
               */
              responseHeaders?: HeaderEntry[];
              /**
               * If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
               * then this networkId will be the same as the requestId present in the requestWillBeSent event.
               */
              networkId?: Network.RequestId;
              /**
               * If the request is due to a redirect response from the server, the id of the request that
               * has caused the redirect.
               */
              redirectedRequestId?: RequestId;
          }
          /**
           * Parameters of the 'Fetch.authRequired' event.
           */
          interface AuthRequiredEvent {
              /**
               * Each request the page makes will have a unique id.
               */
              requestId: RequestId;
              /**
               * The details of the request.
               */
              request: Network.Request;
              /**
               * The id of the frame that initiated the request.
               */
              frameId: Page.FrameId;
              /**
               * How the requested resource will be used.
               */
              resourceType: Network.ResourceType;
              /**
               * Details of the Authorization Challenge encountered.
               * If this is set, client should respond with continueRequest that
               * contains AuthChallengeResponse.
               */
              authChallenge: AuthChallenge;
          }
          /**
           * Unique request identifier.
           */
          type RequestId = string;
          /**
           * Stages of the request to handle. Request will intercept before the request is
           * sent. Response will intercept after the response is received (but before response
           * body is received).
           */
          type RequestStage = 'Request' | 'Response';
          interface RequestPattern {
              /**
               * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
               * backslash. Omitting is equivalent to `"*"`.
               */
              urlPattern?: string;
              /**
               * If set, only requests for matching resource types will be intercepted.
               */
              resourceType?: Network.ResourceType;
              /**
               * Stage at which to begin intercepting requests. Default is Request.
               */
              requestStage?: RequestStage;
          }
          /**
           * Response HTTP header entry
           */
          interface HeaderEntry {
              name: string;
              value: string;
          }
          /**
           * Authorization challenge for HTTP status code 401 or 407.
           */
          interface AuthChallenge {
              /**
               * Source of the authentication challenge.
               */
              source?: 'Server' | 'Proxy';
              /**
               * Origin of the challenger.
               */
              origin: string;
              /**
               * The authentication scheme used, such as basic or digest
               */
              scheme: string;
              /**
               * The realm of the challenge. May be empty.
               */
              realm: string;
          }
          /**
           * Response to an AuthChallenge.
           */
          interface AuthChallengeResponse {
              /**
               * The decision on what to do in response to the authorization challenge.  Default means
               * deferring to the default behavior of the net stack, which will likely either the Cancel
               * authentication or display a popup dialog box.
               */
              response: 'Default' | 'CancelAuth' | 'ProvideCredentials';
              /**
               * The username to provide, possibly empty. Should only be set if response is
               * ProvideCredentials.
               */
              username?: string;
              /**
               * The password to provide, possibly empty. Should only be set if response is
               * ProvideCredentials.
               */
              password?: string;
          }
      }
      /**
       * Methods and events of the 'WebAudio' domain.
       */
      interface WebAudioApi {
          requests: {
              /**
               * Enables the WebAudio domain and starts sending context lifetime events.
               */
              enable: {
                  params: WebAudio.EnableParams;
                  result: WebAudio.EnableResult;
              };
              /**
               * Disables the WebAudio domain.
               */
              disable: {
                  params: WebAudio.DisableParams;
                  result: WebAudio.DisableResult;
              };
              /**
               * Fetch the realtime data from the registered contexts.
               */
              getRealtimeData: {
                  params: WebAudio.GetRealtimeDataParams;
                  result: WebAudio.GetRealtimeDataResult;
              };
          };
          events: {
              /**
               * Notifies that a new BaseAudioContext has been created.
               */
              contextCreated: {
                  params: WebAudio.ContextCreatedEvent;
              };
              /**
               * Notifies that an existing BaseAudioContext will be destroyed.
               */
              contextWillBeDestroyed: {
                  params: WebAudio.ContextWillBeDestroyedEvent;
              };
              /**
               * Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
               */
              contextChanged: {
                  params: WebAudio.ContextChangedEvent;
              };
              /**
               * Notifies that the construction of an AudioListener has finished.
               */
              audioListenerCreated: {
                  params: WebAudio.AudioListenerCreatedEvent;
              };
              /**
               * Notifies that a new AudioListener has been created.
               */
              audioListenerWillBeDestroyed: {
                  params: WebAudio.AudioListenerWillBeDestroyedEvent;
              };
              /**
               * Notifies that a new AudioNode has been created.
               */
              audioNodeCreated: {
                  params: WebAudio.AudioNodeCreatedEvent;
              };
              /**
               * Notifies that an existing AudioNode has been destroyed.
               */
              audioNodeWillBeDestroyed: {
                  params: WebAudio.AudioNodeWillBeDestroyedEvent;
              };
              /**
               * Notifies that a new AudioParam has been created.
               */
              audioParamCreated: {
                  params: WebAudio.AudioParamCreatedEvent;
              };
              /**
               * Notifies that an existing AudioParam has been destroyed.
               */
              audioParamWillBeDestroyed: {
                  params: WebAudio.AudioParamWillBeDestroyedEvent;
              };
              /**
               * Notifies that two AudioNodes are connected.
               */
              nodesConnected: {
                  params: WebAudio.NodesConnectedEvent;
              };
              /**
               * Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
               */
              nodesDisconnected: {
                  params: WebAudio.NodesDisconnectedEvent;
              };
              /**
               * Notifies that an AudioNode is connected to an AudioParam.
               */
              nodeParamConnected: {
                  params: WebAudio.NodeParamConnectedEvent;
              };
              /**
               * Notifies that an AudioNode is disconnected to an AudioParam.
               */
              nodeParamDisconnected: {
                  params: WebAudio.NodeParamDisconnectedEvent;
              };
          };
      }
      /**
       * Types of the 'WebAudio' domain.
       */
      namespace WebAudio {
          /**
           * Parameters of the 'WebAudio.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'WebAudio.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'WebAudio.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'WebAudio.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'WebAudio.getRealtimeData' method.
           */
          interface GetRealtimeDataParams {
              contextId: GraphObjectId;
          }
          /**
           * Return value of the 'WebAudio.getRealtimeData' method.
           */
          interface GetRealtimeDataResult {
              realtimeData: ContextRealtimeData;
          }
          /**
           * Parameters of the 'WebAudio.contextCreated' event.
           */
          interface ContextCreatedEvent {
              context: BaseAudioContext;
          }
          /**
           * Parameters of the 'WebAudio.contextWillBeDestroyed' event.
           */
          interface ContextWillBeDestroyedEvent {
              contextId: GraphObjectId;
          }
          /**
           * Parameters of the 'WebAudio.contextChanged' event.
           */
          interface ContextChangedEvent {
              context: BaseAudioContext;
          }
          /**
           * Parameters of the 'WebAudio.audioListenerCreated' event.
           */
          interface AudioListenerCreatedEvent {
              listener: AudioListener;
          }
          /**
           * Parameters of the 'WebAudio.audioListenerWillBeDestroyed' event.
           */
          interface AudioListenerWillBeDestroyedEvent {
              contextId: GraphObjectId;
              listenerId: GraphObjectId;
          }
          /**
           * Parameters of the 'WebAudio.audioNodeCreated' event.
           */
          interface AudioNodeCreatedEvent {
              node: AudioNode;
          }
          /**
           * Parameters of the 'WebAudio.audioNodeWillBeDestroyed' event.
           */
          interface AudioNodeWillBeDestroyedEvent {
              contextId: GraphObjectId;
              nodeId: GraphObjectId;
          }
          /**
           * Parameters of the 'WebAudio.audioParamCreated' event.
           */
          interface AudioParamCreatedEvent {
              param: AudioParam;
          }
          /**
           * Parameters of the 'WebAudio.audioParamWillBeDestroyed' event.
           */
          interface AudioParamWillBeDestroyedEvent {
              contextId: GraphObjectId;
              nodeId: GraphObjectId;
              paramId: GraphObjectId;
          }
          /**
           * Parameters of the 'WebAudio.nodesConnected' event.
           */
          interface NodesConnectedEvent {
              contextId: GraphObjectId;
              sourceId: GraphObjectId;
              destinationId: GraphObjectId;
              sourceOutputIndex?: number;
              destinationInputIndex?: number;
          }
          /**
           * Parameters of the 'WebAudio.nodesDisconnected' event.
           */
          interface NodesDisconnectedEvent {
              contextId: GraphObjectId;
              sourceId: GraphObjectId;
              destinationId: GraphObjectId;
              sourceOutputIndex?: number;
              destinationInputIndex?: number;
          }
          /**
           * Parameters of the 'WebAudio.nodeParamConnected' event.
           */
          interface NodeParamConnectedEvent {
              contextId: GraphObjectId;
              sourceId: GraphObjectId;
              destinationId: GraphObjectId;
              sourceOutputIndex?: number;
          }
          /**
           * Parameters of the 'WebAudio.nodeParamDisconnected' event.
           */
          interface NodeParamDisconnectedEvent {
              contextId: GraphObjectId;
              sourceId: GraphObjectId;
              destinationId: GraphObjectId;
              sourceOutputIndex?: number;
          }
          /**
           * An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
           */
          type GraphObjectId = string;
          /**
           * Enum of BaseAudioContext types
           */
          type ContextType = 'realtime' | 'offline';
          /**
           * Enum of AudioContextState from the spec
           */
          type ContextState = 'suspended' | 'running' | 'closed';
          /**
           * Enum of AudioNode types
           */
          type NodeType = string;
          /**
           * Enum of AudioNode::ChannelCountMode from the spec
           */
          type ChannelCountMode = 'clamped-max' | 'explicit' | 'max';
          /**
           * Enum of AudioNode::ChannelInterpretation from the spec
           */
          type ChannelInterpretation = 'discrete' | 'speakers';
          /**
           * Enum of AudioParam types
           */
          type ParamType = string;
          /**
           * Enum of AudioParam::AutomationRate from the spec
           */
          type AutomationRate = 'a-rate' | 'k-rate';
          /**
           * Fields in AudioContext that change in real-time.
           */
          interface ContextRealtimeData {
              /**
               * The current context time in second in BaseAudioContext.
               */
              currentTime: number;
              /**
               * The time spent on rendering graph divided by render quantum duration,
               * and multiplied by 100. 100 means the audio renderer reached the full
               * capacity and glitch may occur.
               */
              renderCapacity: number;
              /**
               * A running mean of callback interval.
               */
              callbackIntervalMean: number;
              /**
               * A running variance of callback interval.
               */
              callbackIntervalVariance: number;
          }
          /**
           * Protocol object for BaseAudioContext
           */
          interface BaseAudioContext {
              contextId: GraphObjectId;
              contextType: ContextType;
              contextState: ContextState;
              realtimeData?: ContextRealtimeData;
              /**
               * Platform-dependent callback buffer size.
               */
              callbackBufferSize: number;
              /**
               * Number of output channels supported by audio hardware in use.
               */
              maxOutputChannelCount: number;
              /**
               * Context sample rate.
               */
              sampleRate: number;
          }
          /**
           * Protocol object for AudioListener
           */
          interface AudioListener {
              listenerId: GraphObjectId;
              contextId: GraphObjectId;
          }
          /**
           * Protocol object for AudioNode
           */
          interface AudioNode {
              nodeId: GraphObjectId;
              contextId: GraphObjectId;
              nodeType: NodeType;
              numberOfInputs: number;
              numberOfOutputs: number;
              channelCount: number;
              channelCountMode: ChannelCountMode;
              channelInterpretation: ChannelInterpretation;
          }
          /**
           * Protocol object for AudioParam
           */
          interface AudioParam {
              paramId: GraphObjectId;
              nodeId: GraphObjectId;
              contextId: GraphObjectId;
              paramType: ParamType;
              rate: AutomationRate;
              defaultValue: number;
              minValue: number;
              maxValue: number;
          }
      }
      /**
       * Methods and events of the 'WebAuthn' domain.
       */
      interface WebAuthnApi {
          requests: {
              /**
               * Enable the WebAuthn domain and start intercepting credential storage and
               * retrieval with a virtual authenticator.
               */
              enable: {
                  params: WebAuthn.EnableParams;
                  result: WebAuthn.EnableResult;
              };
              /**
               * Disable the WebAuthn domain.
               */
              disable: {
                  params: WebAuthn.DisableParams;
                  result: WebAuthn.DisableResult;
              };
              /**
               * Creates and adds a virtual authenticator.
               */
              addVirtualAuthenticator: {
                  params: WebAuthn.AddVirtualAuthenticatorParams;
                  result: WebAuthn.AddVirtualAuthenticatorResult;
              };
              /**
               * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
               */
              setResponseOverrideBits: {
                  params: WebAuthn.SetResponseOverrideBitsParams;
                  result: WebAuthn.SetResponseOverrideBitsResult;
              };
              /**
               * Removes the given authenticator.
               */
              removeVirtualAuthenticator: {
                  params: WebAuthn.RemoveVirtualAuthenticatorParams;
                  result: WebAuthn.RemoveVirtualAuthenticatorResult;
              };
              /**
               * Adds the credential to the specified authenticator.
               */
              addCredential: {
                  params: WebAuthn.AddCredentialParams;
                  result: WebAuthn.AddCredentialResult;
              };
              /**
               * Returns a single credential stored in the given virtual authenticator that
               * matches the credential ID.
               */
              getCredential: {
                  params: WebAuthn.GetCredentialParams;
                  result: WebAuthn.GetCredentialResult;
              };
              /**
               * Returns all the credentials stored in the given virtual authenticator.
               */
              getCredentials: {
                  params: WebAuthn.GetCredentialsParams;
                  result: WebAuthn.GetCredentialsResult;
              };
              /**
               * Removes a credential from the authenticator.
               */
              removeCredential: {
                  params: WebAuthn.RemoveCredentialParams;
                  result: WebAuthn.RemoveCredentialResult;
              };
              /**
               * Clears all the credentials from the specified device.
               */
              clearCredentials: {
                  params: WebAuthn.ClearCredentialsParams;
                  result: WebAuthn.ClearCredentialsResult;
              };
              /**
               * Sets whether User Verification succeeds or fails for an authenticator.
               * The default is true.
               */
              setUserVerified: {
                  params: WebAuthn.SetUserVerifiedParams;
                  result: WebAuthn.SetUserVerifiedResult;
              };
              /**
               * Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
               * The default is true.
               */
              setAutomaticPresenceSimulation: {
                  params: WebAuthn.SetAutomaticPresenceSimulationParams;
                  result: WebAuthn.SetAutomaticPresenceSimulationResult;
              };
          };
          events: {
              /**
               * Triggered when a credential is added to an authenticator.
               */
              credentialAdded: {
                  params: WebAuthn.CredentialAddedEvent;
              };
              /**
               * Triggered when a credential is used in a webauthn assertion.
               */
              credentialAsserted: {
                  params: WebAuthn.CredentialAssertedEvent;
              };
          };
      }
      /**
       * Types of the 'WebAuthn' domain.
       */
      namespace WebAuthn {
          /**
           * Parameters of the 'WebAuthn.enable' method.
           */
          interface EnableParams {
              /**
               * Whether to enable the WebAuthn user interface. Enabling the UI is
               * recommended for debugging and demo purposes, as it is closer to the real
               * experience. Disabling the UI is recommended for automated testing.
               * Supported at the embedder's discretion if UI is available.
               * Defaults to false.
               */
              enableUI?: boolean;
          }
          /**
           * Return value of the 'WebAuthn.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'WebAuthn.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'WebAuthn.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'WebAuthn.addVirtualAuthenticator' method.
           */
          interface AddVirtualAuthenticatorParams {
              options: VirtualAuthenticatorOptions;
          }
          /**
           * Return value of the 'WebAuthn.addVirtualAuthenticator' method.
           */
          interface AddVirtualAuthenticatorResult {
              authenticatorId: AuthenticatorId;
          }
          /**
           * Parameters of the 'WebAuthn.setResponseOverrideBits' method.
           */
          interface SetResponseOverrideBitsParams {
              authenticatorId: AuthenticatorId;
              /**
               * If isBogusSignature is set, overrides the signature in the authenticator response to be zero.
               * Defaults to false.
               */
              isBogusSignature?: boolean;
              /**
               * If isBadUV is set, overrides the UV bit in the flags in the authenticator response to
               * be zero. Defaults to false.
               */
              isBadUV?: boolean;
              /**
               * If isBadUP is set, overrides the UP bit in the flags in the authenticator response to
               * be zero. Defaults to false.
               */
              isBadUP?: boolean;
          }
          /**
           * Return value of the 'WebAuthn.setResponseOverrideBits' method.
           */
          interface SetResponseOverrideBitsResult {
          }
          /**
           * Parameters of the 'WebAuthn.removeVirtualAuthenticator' method.
           */
          interface RemoveVirtualAuthenticatorParams {
              authenticatorId: AuthenticatorId;
          }
          /**
           * Return value of the 'WebAuthn.removeVirtualAuthenticator' method.
           */
          interface RemoveVirtualAuthenticatorResult {
          }
          /**
           * Parameters of the 'WebAuthn.addCredential' method.
           */
          interface AddCredentialParams {
              authenticatorId: AuthenticatorId;
              credential: Credential;
          }
          /**
           * Return value of the 'WebAuthn.addCredential' method.
           */
          interface AddCredentialResult {
          }
          /**
           * Parameters of the 'WebAuthn.getCredential' method.
           */
          interface GetCredentialParams {
              authenticatorId: AuthenticatorId;
              credentialId: string;
          }
          /**
           * Return value of the 'WebAuthn.getCredential' method.
           */
          interface GetCredentialResult {
              credential: Credential;
          }
          /**
           * Parameters of the 'WebAuthn.getCredentials' method.
           */
          interface GetCredentialsParams {
              authenticatorId: AuthenticatorId;
          }
          /**
           * Return value of the 'WebAuthn.getCredentials' method.
           */
          interface GetCredentialsResult {
              credentials: Credential[];
          }
          /**
           * Parameters of the 'WebAuthn.removeCredential' method.
           */
          interface RemoveCredentialParams {
              authenticatorId: AuthenticatorId;
              credentialId: string;
          }
          /**
           * Return value of the 'WebAuthn.removeCredential' method.
           */
          interface RemoveCredentialResult {
          }
          /**
           * Parameters of the 'WebAuthn.clearCredentials' method.
           */
          interface ClearCredentialsParams {
              authenticatorId: AuthenticatorId;
          }
          /**
           * Return value of the 'WebAuthn.clearCredentials' method.
           */
          interface ClearCredentialsResult {
          }
          /**
           * Parameters of the 'WebAuthn.setUserVerified' method.
           */
          interface SetUserVerifiedParams {
              authenticatorId: AuthenticatorId;
              isUserVerified: boolean;
          }
          /**
           * Return value of the 'WebAuthn.setUserVerified' method.
           */
          interface SetUserVerifiedResult {
          }
          /**
           * Parameters of the 'WebAuthn.setAutomaticPresenceSimulation' method.
           */
          interface SetAutomaticPresenceSimulationParams {
              authenticatorId: AuthenticatorId;
              enabled: boolean;
          }
          /**
           * Return value of the 'WebAuthn.setAutomaticPresenceSimulation' method.
           */
          interface SetAutomaticPresenceSimulationResult {
          }
          /**
           * Parameters of the 'WebAuthn.credentialAdded' event.
           */
          interface CredentialAddedEvent {
              authenticatorId: AuthenticatorId;
              credential: Credential;
          }
          /**
           * Parameters of the 'WebAuthn.credentialAsserted' event.
           */
          interface CredentialAssertedEvent {
              authenticatorId: AuthenticatorId;
              credential: Credential;
          }
          type AuthenticatorId = string;
          type AuthenticatorProtocol = 'u2f' | 'ctap2';
          type Ctap2Version = 'ctap2_0' | 'ctap2_1';
          type AuthenticatorTransport = 'usb' | 'nfc' | 'ble' | 'cable' | 'internal';
          interface VirtualAuthenticatorOptions {
              protocol: AuthenticatorProtocol;
              /**
               * Defaults to ctap2_0. Ignored if |protocol| == u2f.
               */
              ctap2Version?: Ctap2Version;
              transport: AuthenticatorTransport;
              /**
               * Defaults to false.
               */
              hasResidentKey?: boolean;
              /**
               * Defaults to false.
               */
              hasUserVerification?: boolean;
              /**
               * If set to true, the authenticator will support the largeBlob extension.
               * https://w3c.github.io/webauthn#largeBlob
               * Defaults to false.
               */
              hasLargeBlob?: boolean;
              /**
               * If set to true, the authenticator will support the credBlob extension.
               * https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
               * Defaults to false.
               */
              hasCredBlob?: boolean;
              /**
               * If set to true, the authenticator will support the minPinLength extension.
               * https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
               * Defaults to false.
               */
              hasMinPinLength?: boolean;
              /**
               * If set to true, the authenticator will support the prf extension.
               * https://w3c.github.io/webauthn/#prf-extension
               * Defaults to false.
               */
              hasPrf?: boolean;
              /**
               * If set to true, tests of user presence will succeed immediately.
               * Otherwise, they will not be resolved. Defaults to true.
               */
              automaticPresenceSimulation?: boolean;
              /**
               * Sets whether User Verification succeeds or fails for an authenticator.
               * Defaults to false.
               */
              isUserVerified?: boolean;
              /**
               * Credentials created by this authenticator will have the backup
               * eligibility (BE) flag set to this value. Defaults to false.
               * https://w3c.github.io/webauthn/#sctn-credential-backup
               */
              defaultBackupEligibility?: boolean;
              /**
               * Credentials created by this authenticator will have the backup state
               * (BS) flag set to this value. Defaults to false.
               * https://w3c.github.io/webauthn/#sctn-credential-backup
               */
              defaultBackupState?: boolean;
          }
          interface Credential {
              credentialId: string;
              isResidentCredential: boolean;
              /**
               * Relying Party ID the credential is scoped to. Must be set when adding a
               * credential.
               */
              rpId?: string;
              /**
               * The ECDSA P-256 private key in PKCS#8 format. (Encoded as a base64 string when passed over JSON)
               */
              privateKey: string;
              /**
               * An opaque byte sequence with a maximum size of 64 bytes mapping the
               * credential to a specific user. (Encoded as a base64 string when passed over JSON)
               */
              userHandle?: string;
              /**
               * Signature counter. This is incremented by one for each successful
               * assertion.
               * See https://w3c.github.io/webauthn/#signature-counter
               */
              signCount: integer;
              /**
               * The large blob associated with the credential.
               * See https://w3c.github.io/webauthn/#sctn-large-blob-extension (Encoded as a base64 string when passed over JSON)
               */
              largeBlob?: string;
          }
      }
      /**
       * Methods and events of the 'Media' domain.
       */
      interface MediaApi {
          requests: {
              /**
               * Enables the Media domain
               */
              enable: {
                  params: Media.EnableParams;
                  result: Media.EnableResult;
              };
              /**
               * Disables the Media domain.
               */
              disable: {
                  params: Media.DisableParams;
                  result: Media.DisableResult;
              };
          };
          events: {
              /**
               * This can be called multiple times, and can be used to set / override /
               * remove player properties. A null propValue indicates removal.
               */
              playerPropertiesChanged: {
                  params: Media.PlayerPropertiesChangedEvent;
              };
              /**
               * Send events as a list, allowing them to be batched on the browser for less
               * congestion. If batched, events must ALWAYS be in chronological order.
               */
              playerEventsAdded: {
                  params: Media.PlayerEventsAddedEvent;
              };
              /**
               * Send a list of any messages that need to be delivered.
               */
              playerMessagesLogged: {
                  params: Media.PlayerMessagesLoggedEvent;
              };
              /**
               * Send a list of any errors that need to be delivered.
               */
              playerErrorsRaised: {
                  params: Media.PlayerErrorsRaisedEvent;
              };
              /**
               * Called whenever a player is created, or when a new agent joins and receives
               * a list of active players. If an agent is restored, it will receive the full
               * list of player ids and all events again.
               */
              playersCreated: {
                  params: Media.PlayersCreatedEvent;
              };
          };
      }
      /**
       * Types of the 'Media' domain.
       */
      namespace Media {
          /**
           * Parameters of the 'Media.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Media.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Media.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Media.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Media.playerPropertiesChanged' event.
           */
          interface PlayerPropertiesChangedEvent {
              playerId: PlayerId;
              properties: PlayerProperty[];
          }
          /**
           * Parameters of the 'Media.playerEventsAdded' event.
           */
          interface PlayerEventsAddedEvent {
              playerId: PlayerId;
              events: PlayerEvent[];
          }
          /**
           * Parameters of the 'Media.playerMessagesLogged' event.
           */
          interface PlayerMessagesLoggedEvent {
              playerId: PlayerId;
              messages: PlayerMessage[];
          }
          /**
           * Parameters of the 'Media.playerErrorsRaised' event.
           */
          interface PlayerErrorsRaisedEvent {
              playerId: PlayerId;
              errors: PlayerError[];
          }
          /**
           * Parameters of the 'Media.playersCreated' event.
           */
          interface PlayersCreatedEvent {
              players: PlayerId[];
          }
          /**
           * Players will get an ID that is unique within the agent context.
           */
          type PlayerId = string;
          type Timestamp = number;
          /**
           * Have one type per entry in MediaLogRecord::Type
           * Corresponds to kMessage
           */
          interface PlayerMessage {
              /**
               * Keep in sync with MediaLogMessageLevel
               * We are currently keeping the message level 'error' separate from the
               * PlayerError type because right now they represent different things,
               * this one being a DVLOG(ERROR) style log message that gets printed
               * based on what log level is selected in the UI, and the other is a
               * representation of a media::PipelineStatus object. Soon however we're
               * going to be moving away from using PipelineStatus for errors and
               * introducing a new error type which should hopefully let us integrate
               * the error log level into the PlayerError type.
               */
              level: 'error' | 'warning' | 'info' | 'debug';
              message: string;
          }
          /**
           * Corresponds to kMediaPropertyChange
           */
          interface PlayerProperty {
              name: string;
              value: string;
          }
          /**
           * Corresponds to kMediaEventTriggered
           */
          interface PlayerEvent {
              timestamp: Timestamp;
              value: string;
          }
          /**
           * Represents logged source line numbers reported in an error.
           * NOTE: file and line are from chromium c++ implementation code, not js.
           */
          interface PlayerErrorSourceLocation {
              file: string;
              line: integer;
          }
          /**
           * Corresponds to kMediaError
           */
          interface PlayerError {
              errorType: string;
              /**
               * Code is the numeric enum entry for a specific set of error codes, such
               * as PipelineStatusCodes in media/base/pipeline_status.h
               */
              code: integer;
              /**
               * A trace of where this error was caused / where it passed through.
               */
              stack: PlayerErrorSourceLocation[];
              /**
               * Errors potentially have a root cause error, ie, a DecoderError might be
               * caused by an WindowsError
               */
              cause: PlayerError[];
              /**
               * Extra data attached to an error, such as an HRESULT, Video Codec, etc.
               */
              data: Record<string, unknown>;
          }
      }
      /**
       * Methods and events of the 'DeviceAccess' domain.
       */
      interface DeviceAccessApi {
          requests: {
              /**
               * Enable events in this domain.
               */
              enable: {
                  params: DeviceAccess.EnableParams;
                  result: DeviceAccess.EnableResult;
              };
              /**
               * Disable events in this domain.
               */
              disable: {
                  params: DeviceAccess.DisableParams;
                  result: DeviceAccess.DisableResult;
              };
              /**
               * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
               */
              selectPrompt: {
                  params: DeviceAccess.SelectPromptParams;
                  result: DeviceAccess.SelectPromptResult;
              };
              /**
               * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
               */
              cancelPrompt: {
                  params: DeviceAccess.CancelPromptParams;
                  result: DeviceAccess.CancelPromptResult;
              };
          };
          events: {
              /**
               * A device request opened a user prompt to select a device. Respond with the
               * selectPrompt or cancelPrompt command.
               */
              deviceRequestPrompted: {
                  params: DeviceAccess.DeviceRequestPromptedEvent;
              };
          };
      }
      /**
       * Types of the 'DeviceAccess' domain.
       */
      namespace DeviceAccess {
          /**
           * Parameters of the 'DeviceAccess.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'DeviceAccess.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'DeviceAccess.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'DeviceAccess.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'DeviceAccess.selectPrompt' method.
           */
          interface SelectPromptParams {
              id: RequestId;
              deviceId: DeviceId;
          }
          /**
           * Return value of the 'DeviceAccess.selectPrompt' method.
           */
          interface SelectPromptResult {
          }
          /**
           * Parameters of the 'DeviceAccess.cancelPrompt' method.
           */
          interface CancelPromptParams {
              id: RequestId;
          }
          /**
           * Return value of the 'DeviceAccess.cancelPrompt' method.
           */
          interface CancelPromptResult {
          }
          /**
           * Parameters of the 'DeviceAccess.deviceRequestPrompted' event.
           */
          interface DeviceRequestPromptedEvent {
              id: RequestId;
              devices: PromptDevice[];
          }
          /**
           * Device request id.
           */
          type RequestId = string;
          /**
           * A device id.
           */
          type DeviceId = string;
          /**
           * Device information displayed in a user prompt to select a device.
           */
          interface PromptDevice {
              id: DeviceId;
              /**
               * Display name as it appears in a device request user prompt.
               */
              name: string;
          }
      }
      /**
       * Methods and events of the 'Preload' domain.
       */
      interface PreloadApi {
          requests: {
              enable: {
                  params: Preload.EnableParams;
                  result: Preload.EnableResult;
              };
              disable: {
                  params: Preload.DisableParams;
                  result: Preload.DisableResult;
              };
          };
          events: {
              /**
               * Upsert. Currently, it is only emitted when a rule set added.
               */
              ruleSetUpdated: {
                  params: Preload.RuleSetUpdatedEvent;
              };
              ruleSetRemoved: {
                  params: Preload.RuleSetRemovedEvent;
              };
              /**
               * Fired when a preload enabled state is updated.
               */
              preloadEnabledStateUpdated: {
                  params: Preload.PreloadEnabledStateUpdatedEvent;
              };
              /**
               * Fired when a prefetch attempt is updated.
               */
              prefetchStatusUpdated: {
                  params: Preload.PrefetchStatusUpdatedEvent;
              };
              /**
               * Fired when a prerender attempt is updated.
               */
              prerenderStatusUpdated: {
                  params: Preload.PrerenderStatusUpdatedEvent;
              };
              /**
               * Send a list of sources for all preloading attempts in a document.
               */
              preloadingAttemptSourcesUpdated: {
                  params: Preload.PreloadingAttemptSourcesUpdatedEvent;
              };
          };
      }
      /**
       * Types of the 'Preload' domain.
       */
      namespace Preload {
          /**
           * Parameters of the 'Preload.enable' method.
           */
          interface EnableParams {
          }
          /**
           * Return value of the 'Preload.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'Preload.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'Preload.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'Preload.ruleSetUpdated' event.
           */
          interface RuleSetUpdatedEvent {
              ruleSet: RuleSet;
          }
          /**
           * Parameters of the 'Preload.ruleSetRemoved' event.
           */
          interface RuleSetRemovedEvent {
              id: RuleSetId;
          }
          /**
           * Parameters of the 'Preload.preloadEnabledStateUpdated' event.
           */
          interface PreloadEnabledStateUpdatedEvent {
              disabledByPreference: boolean;
              disabledByDataSaver: boolean;
              disabledByBatterySaver: boolean;
              disabledByHoldbackPrefetchSpeculationRules: boolean;
              disabledByHoldbackPrerenderSpeculationRules: boolean;
          }
          /**
           * Parameters of the 'Preload.prefetchStatusUpdated' event.
           */
          interface PrefetchStatusUpdatedEvent {
              key: PreloadingAttemptKey;
              /**
               * The frame id of the frame initiating prefetch.
               */
              initiatingFrameId: Page.FrameId;
              prefetchUrl: string;
              status: PreloadingStatus;
              prefetchStatus: PrefetchStatus;
              requestId: Network.RequestId;
          }
          /**
           * Parameters of the 'Preload.prerenderStatusUpdated' event.
           */
          interface PrerenderStatusUpdatedEvent {
              key: PreloadingAttemptKey;
              status: PreloadingStatus;
              prerenderStatus?: PrerenderFinalStatus;
              /**
               * This is used to give users more information about the name of Mojo interface
               * that is incompatible with prerender and has caused the cancellation of the attempt.
               */
              disallowedMojoInterface?: string;
              mismatchedHeaders?: PrerenderMismatchedHeaders[];
          }
          /**
           * Parameters of the 'Preload.preloadingAttemptSourcesUpdated' event.
           */
          interface PreloadingAttemptSourcesUpdatedEvent {
              loaderId: Network.LoaderId;
              preloadingAttemptSources: PreloadingAttemptSource[];
          }
          /**
           * Unique id
           */
          type RuleSetId = string;
          /**
           * Corresponds to SpeculationRuleSet
           */
          interface RuleSet {
              id: RuleSetId;
              /**
               * Identifies a document which the rule set is associated with.
               */
              loaderId: Network.LoaderId;
              /**
               * Source text of JSON representing the rule set. If it comes from
               * `<script>` tag, it is the textContent of the node. Note that it is
               * a JSON for valid case.
               *
               * See also:
               * - https://wicg.github.io/nav-speculation/speculation-rules.html
               * - https://github.com/WICG/nav-speculation/blob/main/triggers.md
               */
              sourceText: string;
              /**
               * A speculation rule set is either added through an inline
               * `<script>` tag or through an external resource via the
               * 'Speculation-Rules' HTTP header. For the first case, we include
               * the BackendNodeId of the relevant `<script>` tag. For the second
               * case, we include the external URL where the rule set was loaded
               * from, and also RequestId if Network domain is enabled.
               *
               * See also:
               * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script
               * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
               */
              backendNodeId?: DOM.BackendNodeId;
              url?: string;
              requestId?: Network.RequestId;
              /**
               * Error information
               * `errorMessage` is null iff `errorType` is null.
               */
              errorType?: RuleSetErrorType;
              /**
               * TODO(https://crbug.com/1425354): Replace this property with structured error.
               * @deprecated
               */
              errorMessage?: string;
          }
          type RuleSetErrorType = 'SourceIsNotJsonObject' | 'InvalidRulesSkipped';
          /**
           * The type of preloading attempted. It corresponds to
           * mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
           * isn't being used by clients).
           */
          type SpeculationAction = 'Prefetch' | 'Prerender';
          /**
           * Corresponds to mojom::SpeculationTargetHint.
           * See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
           */
          type SpeculationTargetHint = 'Blank' | 'Self';
          /**
           * A key that identifies a preloading attempt.
           *
           * The url used is the url specified by the trigger (i.e. the initial URL), and
           * not the final url that is navigated to. For example, prerendering allows
           * same-origin main frame navigations during the attempt, but the attempt is
           * still keyed with the initial URL.
           */
          interface PreloadingAttemptKey {
              loaderId: Network.LoaderId;
              action: SpeculationAction;
              url: string;
              targetHint?: SpeculationTargetHint;
          }
          /**
           * Lists sources for a preloading attempt, specifically the ids of rule sets
           * that had a speculation rule that triggered the attempt, and the
           * BackendNodeIds of <a href> or <area href> elements that triggered the
           * attempt (in the case of attempts triggered by a document rule). It is
           * possible for mulitple rule sets and links to trigger a single attempt.
           */
          interface PreloadingAttemptSource {
              key: PreloadingAttemptKey;
              ruleSetIds: RuleSetId[];
              nodeIds: DOM.BackendNodeId[];
          }
          /**
           * List of FinalStatus reasons for Prerender2.
           */
          type PrerenderFinalStatus = 'Activated' | 'Destroyed' | 'LowEndDevice' | 'InvalidSchemeRedirect' | 'InvalidSchemeNavigation' | 'NavigationRequestBlockedByCsp' | 'MainFrameNavigation' | 'MojoBinderPolicy' | 'RendererProcessCrashed' | 'RendererProcessKilled' | 'Download' | 'TriggerDestroyed' | 'NavigationNotCommitted' | 'NavigationBadHttpStatus' | 'ClientCertRequested' | 'NavigationRequestNetworkError' | 'CancelAllHostsForTesting' | 'DidFailLoad' | 'Stop' | 'SslCertificateError' | 'LoginAuthRequested' | 'UaChangeRequiresReload' | 'BlockedByClient' | 'AudioOutputDeviceRequested' | 'MixedContent' | 'TriggerBackgrounded' | 'MemoryLimitExceeded' | 'DataSaverEnabled' | 'TriggerUrlHasEffectiveUrl' | 'ActivatedBeforeStarted' | 'InactivePageRestriction' | 'StartFailed' | 'TimeoutBackgrounded' | 'CrossSiteRedirectInInitialNavigation' | 'CrossSiteNavigationInInitialNavigation' | 'SameSiteCrossOriginRedirectNotOptInInInitialNavigation' | 'SameSiteCrossOriginNavigationNotOptInInInitialNavigation' | 'ActivationNavigationParameterMismatch' | 'ActivatedInBackground' | 'EmbedderHostDisallowed' | 'ActivationNavigationDestroyedBeforeSuccess' | 'TabClosedByUserGesture' | 'TabClosedWithoutUserGesture' | 'PrimaryMainFrameRendererProcessCrashed' | 'PrimaryMainFrameRendererProcessKilled' | 'ActivationFramePolicyNotCompatible' | 'PreloadingDisabled' | 'BatterySaverEnabled' | 'ActivatedDuringMainFrameNavigation' | 'PreloadingUnsupportedByWebContents' | 'CrossSiteRedirectInMainFrameNavigation' | 'CrossSiteNavigationInMainFrameNavigation' | 'SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation' | 'SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation' | 'MemoryPressureOnTrigger' | 'MemoryPressureAfterTriggered' | 'PrerenderingDisabledByDevTools' | 'SpeculationRuleRemoved' | 'ActivatedWithAuxiliaryBrowsingContexts' | 'MaxNumOfRunningEagerPrerendersExceeded' | 'MaxNumOfRunningNonEagerPrerendersExceeded' | 'MaxNumOfRunningEmbedderPrerendersExceeded' | 'PrerenderingUrlHasEffectiveUrl' | 'RedirectedPrerenderingUrlHasEffectiveUrl' | 'ActivationUrlHasEffectiveUrl';
          /**
           * Preloading status values, see also PreloadingTriggeringOutcome. This
           * status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
           */
          type PreloadingStatus = 'Pending' | 'Running' | 'Ready' | 'Success' | 'Failure' | 'NotSupported';
          /**
           * TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and
           * filter out the ones that aren't necessary to the developers.
           */
          type PrefetchStatus = 'PrefetchAllowed' | 'PrefetchFailedIneligibleRedirect' | 'PrefetchFailedInvalidRedirect' | 'PrefetchFailedMIMENotSupported' | 'PrefetchFailedNetError' | 'PrefetchFailedNon2XX' | 'PrefetchFailedPerPageLimitExceeded' | 'PrefetchEvictedAfterCandidateRemoved' | 'PrefetchEvictedForNewerPrefetch' | 'PrefetchHeldback' | 'PrefetchIneligibleRetryAfter' | 'PrefetchIsPrivacyDecoy' | 'PrefetchIsStale' | 'PrefetchNotEligibleBrowserContextOffTheRecord' | 'PrefetchNotEligibleDataSaverEnabled' | 'PrefetchNotEligibleExistingProxy' | 'PrefetchNotEligibleHostIsNonUnique' | 'PrefetchNotEligibleNonDefaultStoragePartition' | 'PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy' | 'PrefetchNotEligibleSchemeIsNotHttps' | 'PrefetchNotEligibleUserHasCookies' | 'PrefetchNotEligibleUserHasServiceWorker' | 'PrefetchNotEligibleBatterySaverEnabled' | 'PrefetchNotEligiblePreloadingDisabled' | 'PrefetchNotFinishedInTime' | 'PrefetchNotStarted' | 'PrefetchNotUsedCookiesChanged' | 'PrefetchProxyNotAvailable' | 'PrefetchResponseUsed' | 'PrefetchSuccessfulButNotUsed' | 'PrefetchNotUsedProbeFailed';
          /**
           * Information of headers to be displayed when the header mismatch occurred.
           */
          interface PrerenderMismatchedHeaders {
              headerName: string;
              initialValue?: string;
              activationValue?: string;
          }
      }
      /**
       * Methods and events of the 'FedCm' domain.
       */
      interface FedCmApi {
          requests: {
              enable: {
                  params: FedCm.EnableParams;
                  result: FedCm.EnableResult;
              };
              disable: {
                  params: FedCm.DisableParams;
                  result: FedCm.DisableResult;
              };
              selectAccount: {
                  params: FedCm.SelectAccountParams;
                  result: FedCm.SelectAccountResult;
              };
              clickDialogButton: {
                  params: FedCm.ClickDialogButtonParams;
                  result: FedCm.ClickDialogButtonResult;
              };
              dismissDialog: {
                  params: FedCm.DismissDialogParams;
                  result: FedCm.DismissDialogResult;
              };
              /**
               * Resets the cooldown time, if any, to allow the next FedCM call to show
               * a dialog even if one was recently dismissed by the user.
               */
              resetCooldown: {
                  params: FedCm.ResetCooldownParams;
                  result: FedCm.ResetCooldownResult;
              };
          };
          events: {
              dialogShown: {
                  params: FedCm.DialogShownEvent;
              };
              /**
               * Triggered when a dialog is closed, either by user action, JS abort,
               * or a command below.
               */
              dialogClosed: {
                  params: FedCm.DialogClosedEvent;
              };
          };
      }
      /**
       * Types of the 'FedCm' domain.
       */
      namespace FedCm {
          /**
           * Parameters of the 'FedCm.enable' method.
           */
          interface EnableParams {
              /**
               * Allows callers to disable the promise rejection delay that would
               * normally happen, if this is unimportant to what's being tested.
               * (step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)
               */
              disableRejectionDelay?: boolean;
          }
          /**
           * Return value of the 'FedCm.enable' method.
           */
          interface EnableResult {
          }
          /**
           * Parameters of the 'FedCm.disable' method.
           */
          interface DisableParams {
          }
          /**
           * Return value of the 'FedCm.disable' method.
           */
          interface DisableResult {
          }
          /**
           * Parameters of the 'FedCm.selectAccount' method.
           */
          interface SelectAccountParams {
              dialogId: string;
              accountIndex: integer;
          }
          /**
           * Return value of the 'FedCm.selectAccount' method.
           */
          interface SelectAccountResult {
          }
          /**
           * Parameters of the 'FedCm.clickDialogButton' method.
           */
          interface ClickDialogButtonParams {
              dialogId: string;
              dialogButton: DialogButton;
          }
          /**
           * Return value of the 'FedCm.clickDialogButton' method.
           */
          interface ClickDialogButtonResult {
          }
          /**
           * Parameters of the 'FedCm.dismissDialog' method.
           */
          interface DismissDialogParams {
              dialogId: string;
              triggerCooldown?: boolean;
          }
          /**
           * Return value of the 'FedCm.dismissDialog' method.
           */
          interface DismissDialogResult {
          }
          /**
           * Parameters of the 'FedCm.resetCooldown' method.
           */
          interface ResetCooldownParams {
          }
          /**
           * Return value of the 'FedCm.resetCooldown' method.
           */
          interface ResetCooldownResult {
          }
          /**
           * Parameters of the 'FedCm.dialogShown' event.
           */
          interface DialogShownEvent {
              dialogId: string;
              dialogType: DialogType;
              accounts: Account[];
              /**
               * These exist primarily so that the caller can verify the
               * RP context was used appropriately.
               */
              title: string;
              subtitle?: string;
          }
          /**
           * Parameters of the 'FedCm.dialogClosed' event.
           */
          interface DialogClosedEvent {
              dialogId: string;
          }
          /**
           * Whether this is a sign-up or sign-in action for this account, i.e.
           * whether this account has ever been used to sign in to this RP before.
           */
          type LoginState = 'SignIn' | 'SignUp';
          /**
           * The types of FedCM dialogs.
           */
          type DialogType = 'AccountChooser' | 'AutoReauthn' | 'ConfirmIdpLogin' | 'Error';
          /**
           * The buttons on the FedCM dialog.
           */
          type DialogButton = 'ConfirmIdpLoginContinue' | 'ErrorGotIt' | 'ErrorMoreDetails';
          /**
           * Corresponds to IdentityRequestAccount
           */
          interface Account {
              accountId: string;
              email: string;
              name: string;
              givenName: string;
              pictureUrl: string;
              idpConfigUrl: string;
              idpLoginUrl: string;
              loginState: LoginState;
              /**
               * These two are only set if the loginState is signUp
               */
              termsOfServiceUrl?: string;
              privacyPolicyUrl?: string;
          }
      }
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/errors' {
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { Transportable } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  export const enum ProtocolErrorCode {
      ParseError = -32700,
      InvalidRequest = -32600,
      MethodNotFound = -32601,
      InvalidParams = -32602,
      InternalError = -32603,
      ServerError = -32000
  }
  /**
   * Base error extended by all other errors the library emits.
   */
  export class CdpError extends Error {
  }
  export interface IProtocolErrorCause {
      code: number;
      method: string;
      message: string;
  }
  /**
   * Class thrown on an error returned from the remote CDP server.
   */
  export class ProtocolError extends CdpError {
      readonly cause: IProtocolErrorCause;
      /**
       * Creates a correctly-typed error from the protocol cause.
       */
      static from(cause: IProtocolErrorCause, originalStack: string | undefined): ProtocolError;
      constructor(cause: IProtocolErrorCause, originalStack?: string);
      serialize(id: number): CdpProtocol.IError;
  }
  export class ProtocolParseError extends ProtocolError {
  }
  export class InvalidRequestError extends ProtocolError {
  }
  export class MethodNotFoundError extends ProtocolError {
      static create(method: string): MethodNotFoundError;
  }
  export class InvalidParametersError extends ProtocolError {
  }
  export class InternalError extends ProtocolError {
  }
  export class ServerError extends ProtocolError {
  }
  /**
   * Error thrown from CDP commands if the connection is closed before the
   * command returns.
   */
  export class ConnectionClosedError extends CdpError {
      readonly cause?: Error;
      constructor(cause?: Error, originalStack?: string);
  }
  /**
   * Error emitted on the {@link Connection.onDidReceiveError} when
   * deserialization of input fails.
   */
  export class DeserializationError extends CdpError {
      readonly cause: Error;
      readonly protocolMessage: Transportable;
      constructor(cause: Error, protocolMessage: Transportable);
  }
  /**
   * Error emitted on the {@link Connection.onDidReceiveError} when a message
   * is received for an unknown session.
   */
  export class UnknownSessionError extends CdpError {
      readonly protocolMessage: CdpProtocol.Message;
      constructor(protocolMessage: CdpProtocol.Message);
  }
  /**
   * Error emitted on the {@link Connection.onDidReceiveError} when a the process
   * of emitted a received message results in an error. Usually this will be
   * from user code.
   */
  export class MessageProcessingError extends CdpError {
      readonly cause: Error;
      readonly protocolMessage: CdpProtocol.Message;
      constructor(cause: Error, protocolMessage: CdpProtocol.Message);
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/index' {
  export * from '@yodaos-jsar/dom/src/agent/cdp/api';
  export { ICancellationToken } from '@yodaos-jsar/dom/src/agent/cdp/cancellation';
  export * from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  export * from '@yodaos-jsar/dom/src/agent/cdp/client';
  export * from '@yodaos-jsar/dom/src/agent/cdp/connection';
  export * from '@yodaos-jsar/dom/src/agent/cdp/definitions';
  export * from '@yodaos-jsar/dom/src/agent/cdp/errors';
  export * from '@yodaos-jsar/dom/src/agent/cdp/serializer/index';
  export * from '@yodaos-jsar/dom/src/agent/cdp/server';
  export * from '@yodaos-jsar/dom/src/agent/cdp/transport/index';

}
declare module '@yodaos-jsar/dom/src/agent/cdp/serializer/index' {
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { Transportable } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  export interface ISerializer {
      /**
       * Serializes the message for the wire.
       */
      serialize(message: CdpProtocol.Message): Transportable;
      /**
       * Deserializes a message from the wire.
       */
      deserialize(message: Transportable): CdpProtocol.Message;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/serializer/json' {
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { Transportable } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  import { ISerializer } from '@yodaos-jsar/dom/src/agent/cdp/serializer/index';
  export class JsonSerializer implements ISerializer {
      private decoder?;
      serialize(message: CdpProtocol.Message): Transportable;
      deserialize(message: Transportable): CdpProtocol.Message;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/server' {
  import { CdpServerEventDispatcher, CdpServerMethodHandlers } from '@yodaos-jsar/dom/src/agent/cdp/api';
  import { CdpProtocol } from '@yodaos-jsar/dom/src/agent/cdp/cdp-protocol';
  import { CdpSession } from '@yodaos-jsar/dom/src/agent/cdp/cdp-session';
  /**
   * A CDP session that allows a handler to be installed for coming method
   * calls from a client, and sending events.
   */
  export class ServerCdpSession<TDomains> extends CdpSession {
      private readonly handlerErrorEmitter;
      /**
       * Helper to emit typed events.
       */
      readonly eventDispatcher: CdpServerEventDispatcher<TDomains>;
      /**
       * Emitter that fires if there's an uncaught error in a handler method.
       */
      readonly onDidThrowHandlerError: import("cockatiel").Event<Error>;
      /**
       * API implementation for the server. It should be set when the server is
       * first acquired.
       */
      api?: CdpServerMethodHandlers<TDomains>;
      /**
       * @override
       */
      injectMessage(cmd: CdpProtocol.Message): void;
      /**
       * Sends a raw message on the session.
       */
      send(message: CdpProtocol.Message): void;
      private handleUnknown;
      private handleCall;
      protected disposeInner(): void;
  }

}
declare module '@yodaos-jsar/dom/src/agent/cdp/transport/index' {
  import { Event, IDisposable } from 'cockatiel';
  export type Transportable = string | Uint8Array;
  export interface ITransport extends IDisposable {
      /**
       * Event that fires when a message is received.
       */
      readonly onMessage: Event<Transportable>;
      /**
       * Event that fires when the transport is closed, possibly with an error
       * that caused the transport to close.
       */
      readonly onEnd: Event<Error | undefined>;
      /**
       * Sends a serialized message over the transport.
       */
      send(message: Transportable): void;
  }
  export { LoopbackTransport } from '@yodaos-jsar/dom/src/agent/cdp/transport/loopback';

}
declare module '@yodaos-jsar/dom/src/agent/cdp/transport/loopback' {
  import { ITransport, Transportable } from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  /**
   * Transport that allows manual control, useful for testing.
   */
  export class LoopbackTransport implements ITransport {
      private readonly messageEmitter;
      private readonly endEmitter;
      private readonly didSendEmitter;
      readonly onMessage: import("cockatiel").Event<Transportable>;
      readonly onEnd: import("cockatiel").Event<Error>;
      /**
       * Fires when send() is called.
       */
      readonly onDidSend: import("cockatiel").Event<Transportable>;
      /**
       * Causes `onMessage` to fire, as if a message was received.
       */
      receive(message: Transportable): void;
      /**
       * Causes `onEnd` to fire, optionally with an error.
       */
      endWith(error?: Error): void;
      /** @inheritdoc */
      send(message: Transportable): void;
      /** @inheritdoc */
      dispose(): void;
  }

}
declare module '@yodaos-jsar/dom/src/agent/console' {
  import type { BaseWindowImpl } from '@yodaos-jsar/dom/src/agent/window';
  export function createConsole(nativeConsole: Console, window: BaseWindowImpl): Console;

}
declare module '@yodaos-jsar/dom/src/agent/navigator' {
  import { NativeDocument, UserAgent as NativeUserAgent } from '@yodaos-jsar/dom/src/impl-interfaces';
  import XRSystemImpl from '@yodaos-jsar/dom/src/living/xr/XRSystem';
  export class NavigatorImpl implements Navigator {
      clipboard: Clipboard;
      credentials: CredentialsContainer;
      doNotTrack: string;
      geolocation: Geolocation;
      get maxTouchPoints(): number;
      mediaCapabilities: MediaCapabilities;
      mediaDevices: MediaDevices;
      mediaSession: MediaSession;
      permissions: Permissions;
      serviceWorker: ServiceWorkerContainer;
      userActivation: UserActivation;
      wakeLock: WakeLock;
      get gpu(): GPU;
      get xr(): XRSystem;
      get webdriver(): boolean;
      get cookieEnabled(): boolean;
      get appCodeName(): string;
      get appName(): string;
      get appVersion(): string;
      get platform(): string;
      get product(): string;
      get productSub(): string;
      get userAgent(): string;
      get vendor(): string;
      get vendorSub(): string;
      get language(): string;
      get languages(): readonly string[];
      locks: LockManager;
      onLine: boolean;
      mimeTypes: MimeTypeArray;
      pdfViewerEnabled: boolean;
      plugins: PluginArray;
      hardwareConcurrency: number;
      storage: StorageManager;
      protected _nativeUserAgent: NativeUserAgent;
      protected _xrSystem: XRSystemImpl;
      constructor(hostObject: NativeDocument, _args: any, _privateData?: any);
      canShare(_data?: ShareData): boolean;
      getGamepads(): Gamepad[];
      requestMIDIAccess(options?: MIDIOptions): Promise<MIDIAccess>;
      requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]): Promise<MediaKeySystemAccess>;
      sendBeacon(url: string | URL, data?: BodyInit): boolean;
      share(data?: ShareData): Promise<void>;
      vibrate(pattern: VibratePattern): boolean;
      mozGetVRDevices: (any: any) => any;
      webkitGetUserMedia(constraints: MediaStreamConstraints, successCallback: any, errorCallback: any): void;
      mozGetUserMedia(constraints: MediaStreamConstraints, successCallback: any, errorCallback: any): void;
      msGetUserMedia(constraints: MediaStreamConstraints, successCallback: any, errorCallback: any): void;
      webkitGetGamepads(): Gamepad[];
      msGetGamepads(): Gamepad[];
      webkitGamepads(): Gamepad[];
      clearAppBadge(): Promise<void>;
      setAppBadge(contents?: number): Promise<void>;
      registerProtocolHandler(scheme: string, url: string | URL): void;
      javaEnabled(): boolean;
  }

}
declare module '@yodaos-jsar/dom/src/agent/parser/index' {
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function parseFragment(markup: string, contextElement: HTMLElement): void;
  export function parseIntoDocument(markup: string, ownerDocument: SpatialDocumentImpl): void;

}
declare module '@yodaos-jsar/dom/src/agent/parser/xml-utils' {
  export function toNode(xmlObject: any): Partial<{
      name: string;
      text: string;
      attrs: {
          [key: string]: any;
      };
      children: any[];
  }>;

}
declare module '@yodaos-jsar/dom/src/agent/parser/xsml' {
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function parseIntoDocument(markup: string, ownerDocument: SpatialDocumentImpl): void;

}
declare module '@yodaos-jsar/dom/src/agent/resources/AssetsBundle' {
  import type { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export class AssetsBundle {
      private _document;
      meshes: BABYLON.AbstractMesh[];
      particleSystems: BABYLON.IParticleSystem[];
      skeletons: BABYLON.Skeleton[];
      animationGroups: BABYLON.AnimationGroup[];
      transformNodes: BABYLON.TransformNode[];
      geometries: BABYLON.Geometry[];
      lights: BABYLON.Light[];
      get meshesOrTransformNodes(): (BABYLON.AbstractMesh | BABYLON.TransformNode)[];
      constructor(assets: BABYLON.ISceneLoaderAsyncResult, isGltf: boolean, _document: SpatialDocumentImpl);
      private _invalidate;
      /**
       * Instantiate a new nodes from the assets bundle, it will create the related meshes, transform nodes, skeletons and animation
       * groups.
       *
       * @param selector The selector of the root node to be instantiated, currently only support the name of the node.
       * @param name The name of the new node.
       */
      instantiate(selector: string, name: string): SpatialElement;
      private _createSpatialElement;
      private _walkTransformNodesTree;
  }

}
declare module '@yodaos-jsar/dom/src/agent/resources/ResourceQueue' {
  type ResourceQueueInit = {
      paused: boolean;
      asyncQueue?: AsyncResourceQueue;
  };
  type QueueItemInit = {
      prev: QueueItem;
      element: Element;
      isScript: boolean;
      keepLast: boolean;
      onload?: (data?: any) => Promise<void>;
      onerror?: (e: Error) => Promise<void>;
  };
  class QueueItemBase {
      data: any;
      error: Error;
      fired: boolean;
      finished: boolean;
      onload: QueueItemInit['onload'];
      onerror: QueueItemInit['onerror'];
  }
  class QueueItem extends QueueItemBase {
      #private;
      prev: QueueItem;
      next: QueueItem;
      element: Element;
      isScript: boolean;
      keepLast: boolean;
      constructor(q: ResourceQueue, init: QueueItemInit);
      check(): void;
  }
  class AsyncQueueItem extends QueueItemBase {
      dependentItem: AsyncQueueItem;
      constructor(onload: QueueItemInit['onload'], onerror: QueueItemInit['onerror'], dependentItem: AsyncQueueItem);
  }
  class ResourceQueueBase {
      _listener: () => void;
      _notify(): void;
      setListener(listener: () => void): void;
  }
  export class AsyncResourceQueue extends ResourceQueueBase {
      items: Set<AsyncQueueItem>;
      dependentItems: Set<AsyncQueueItem>;
      count(): number;
      _check(item: AsyncQueueItem): void;
      push(request: Promise<any>, onload: QueueItemInit['onload'], onerror: QueueItemInit['onerror'], dependentItem: AsyncQueueItem): Promise<boolean | void>;
      notifyItem(_syncItem: QueueItem): void;
  }
  /**
   * Queue for all resources to be download except async scripts.
   * Async scripts have their own queue `AsyncResourceQueue`.
   */
  export class ResourceQueue extends ResourceQueueBase {
      paused: boolean;
      tail: QueueItem;
      /**
       * @internal
       */
      _asyncQueue: AsyncResourceQueue;
      constructor({ paused, asyncQueue }?: ResourceQueueInit);
      /**
       * Retrieves the last script in the resource queue.
       * @returns The last script in the queue, or null if no script is found.
       */
      getLastScript(): QueueItem;
      _hasMoreScripts(): boolean;
      push(request: Promise<any>, onload: QueueItemInit['onload'], onerror: QueueItemInit['onerror'], keepLast?: boolean, element?: Element): Promise<void>;
      resume(): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/resources/ResourceQueue.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/timers' {
  import type { NativeDocument } from 'src/impl-interfaces';
  import type { BaseWindowImpl } from '@yodaos-jsar/dom/src/agent/window';
  type TimerConfig = {
      hostObject: NativeDocument;
      methodContext: BaseWindowImpl;
      repeat: boolean;
      previousHandle?: number;
  };
  export function timerInitializationSteps(handler: TimerHandler, timeout: number, args: any[], config: TimerConfig): number;
  export function clearTimer(handle: number): void;
  export function stopAllTimers(): void;
  export {};

}
declare module '@yodaos-jsar/dom/src/agent/window' {
  import * as taffy from '@bindings/taffy';
  import { MediaPlayerBackend, NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { AssetsBundle } from '@yodaos-jsar/dom/src/agent/resources/AssetsBundle';
  import type { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import type CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  import { CustomElementRegistryImpl } from '@yodaos-jsar/dom/src/living/custom-elements/CustomElementRegistry';
  import { GlobalEventHandlersImpl } from '@yodaos-jsar/dom/src/living/nodes/GlobalEventHandlers';
  import type NoiseImpl from '@yodaos-jsar/dom/src/living/crypto/Noise';
  import type XRPoseImpl from '@yodaos-jsar/dom/src/living/xr/XRPose';
  import type XRRigidTransformImpl from '@yodaos-jsar/dom/src/living/xr/XRRigidTransform';
  import type XRSessionImpl from '@yodaos-jsar/dom/src/living/xr/XRSession';
  import type DOMPointReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMPointReadOnly';
  import type DOMPointImpl from '@yodaos-jsar/dom/src/living/geometry/DOMPoint';
  import type DOMRectReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRectReadOnly';
  import type DOMRectImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRect';
  import { CdpServerImplementation } from '@yodaos-jsar/dom/src/agent/cdp/cdp-implementation';
  export type WindowOrDOMInit<T extends NativeDocument> = {
      url?: string;
      nativeDocument: T;
      referrer?: string;
      contentType?: string;
      storageQuota?: number;
      runScripts?: 'dangerously' | 'outside-only' | 'never';
      id?: string;
      /**
       * Configuration for the devtools.
       */
      devtools?: Partial<{
          /**
           * Whether to enable the logging at first.
           */
          log: boolean;
      }>;
  };
  /**
   * A `BaseWindowImpl` which implements the window interfaces, and will be the global object to be used
   * in the XSML TypeScript.
   */
  export interface BaseWindowImpl<T extends NativeDocument = NativeDocument> extends EventTarget, GlobalEventHandlersImpl {
  }
  export class BaseWindowImpl<T extends NativeDocument = NativeDocument> extends EventTarget implements Window {
      #private;
      /**
       * NOTE: This is only available when the NativeDocument implements `cdpTransport`.
       */
      _cdpImplementation: CdpServerImplementation | null;
      /**
       * Bypass the following properties from global context.
       */
      URL: {
          new (url: string | URL, base?: string | URL): URL;
          prototype: URL;
          canParse(url: string | URL, base?: string): boolean;
          createObjectURL(obj: Blob | MediaSource): string;
          revokeObjectURL(url: string): void;
      };
      Blob: {
          new (blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;
          prototype: Blob;
      };
      /**
       * WebSocket
       */
      WebSocket: (url: string, protocols?: string | string[]) => WebSocket;
      /**
       * Web Crypto
       */
      Noise: typeof NoiseImpl;
      /**
       * Images & Canvas
       */
      ImageData: typeof ImageData;
      OffscreenCanvas: typeof OffscreenCanvas;
      /**
       * DOM Geometry Interfaces
       */
      DOMRect: typeof DOMRectImpl;
      DOMRectReadOnly: typeof DOMRectReadOnlyImpl;
      DOMPoint: typeof DOMPointImpl;
      DOMPointReadOnly: typeof DOMPointReadOnlyImpl;
      /**
       * WebXR Device API
       */
      XRPose: typeof XRPoseImpl;
      XRRigidTransform: typeof XRRigidTransformImpl;
      XRSession: typeof XRSessionImpl;
      /**
       * Event handlers
       */
      onafterprint: (this: WindowEventHandlers, ev: Event) => any;
      onbeforeprint: (this: WindowEventHandlers, ev: Event) => any;
      onbeforeunload: (this: WindowEventHandlers, ev: BeforeUnloadEvent) => any;
      ongamepadconnected: (this: WindowEventHandlers, ev: GamepadEvent) => any;
      ongamepaddisconnected: (this: WindowEventHandlers, ev: GamepadEvent) => any;
      onhashchange: (this: WindowEventHandlers, ev: HashChangeEvent) => any;
      onlanguagechange: (this: WindowEventHandlers, ev: Event) => any;
      onmessage: (this: WindowEventHandlers, ev: MessageEvent<any>) => any;
      onmessageerror: (this: WindowEventHandlers, ev: MessageEvent<any>) => any;
      onoffline: (this: WindowEventHandlers, ev: Event) => any;
      ononline: (this: WindowEventHandlers, ev: Event) => any;
      onpagehide: (this: WindowEventHandlers, ev: PageTransitionEvent) => any;
      onpageshow: (this: WindowEventHandlers, ev: PageTransitionEvent) => any;
      onpopstate: (this: WindowEventHandlers, ev: PopStateEvent) => any;
      onrejectionhandled: (this: WindowEventHandlers, ev: PromiseRejectionEvent) => any;
      onunhandledrejection: (this: WindowEventHandlers, ev: PromiseRejectionEvent) => any;
      onstorage: (this: WindowEventHandlers, ev: StorageEvent) => any;
      onunload: (this: WindowEventHandlers, ev: Event) => any;
      constructor(init: WindowOrDOMInit<T>);
      /**
       * Internals access
       */
      /**
       * @internal
       *
       * Prepare some fields internally.
       */
      _prepare(): void;
      /**
       * @internal
       *
       * This creates a new assets bundle from the given assets.
       *
       * @param id
       * @param assets
       * @param isGltf
       */
      _createAssetsBundle(id: string, assets: BABYLON.ISceneLoaderAsyncResult, isGltf: boolean): void;
      /**
       * @internal
       *
       * This returns if the assets bundle with the given id exists.
       *
       * @param id
       * @returns
       */
      _hasAssetsBundle(id: string): boolean;
      /**
       * @internal
       *
       * This returns the assets bundle with the given id.
       *
       * @param id
       * @returns
       */
      _getAssetsBundle(id: string): AssetsBundle;
      /**
       * @internal
       */
      _customElementRegistry: CustomElementRegistryImpl;
      /**
       * @internal
       */
      get _nativeDocument(): NativeDocument;
      /**
       * @internal
       */
      get _listOfAudioPlayers(): Set<MediaPlayerBackend>;
      /**
       * @internal
       *
       * The Layout library shared allocators.
       *
       * craft3d: 3d layout
       * taffy: 2d layout
       */
      _taffyAllocator: taffy.Allocator;
      [index: number]: Window;
      get length(): number;
      get clientInformation(): Navigator;
      get closed(): boolean;
      get customElements(): CustomElementRegistry;
      get devicePixelRatio(): number;
      get document(): Document;
      get event(): Event;
      get external(): External;
      get frameElement(): Element;
      get frames(): Window;
      get history(): History;
      get innerHeight(): number;
      get innerWidth(): number;
      get location(): Location;
      set location(href: Location);
      get locationbar(): BarProp;
      get menubar(): BarProp;
      get name(): string;
      navigator: Navigator;
      ondevicemotion: (this: Window, ev: DeviceMotionEvent) => any;
      ondeviceorientation: (this: Window, ev: DeviceOrientationEvent) => any;
      onorientationchange: (this: Window, ev: Event) => any;
      get opener(): Window;
      get orientation(): number;
      get outerHeight(): number;
      get outerWidth(): number;
      get pageXOffset(): number;
      get pageYOffset(): number;
      get parent(): Window;
      get personalbar(): BarProp;
      get screen(): Screen;
      get screenLeft(): number;
      get screenTop(): number;
      get screenX(): number;
      get screenY(): number;
      get scrollX(): number;
      get scrollY(): number;
      get scrollbars(): BarProp;
      get self(): Window & typeof globalThis;
      get speechSynthesis(): SpeechSynthesis;
      get status(): string;
      get statusbar(): BarProp;
      get toolbar(): BarProp;
      get top(): Window;
      get console(): Console;
      visualViewport: VisualViewport;
      window: Window & typeof globalThis;
      alert(message?: any): void;
      blur(): void;
      cancelIdleCallback(handle: number): void;
      captureEvents(): void;
      close(): void;
      confirm(message?: string): boolean;
      focus(): void;
      /**
       * Returns the computed style of an element.
       * @param elt - The element to get the computed style for.
       * @param pseudoElt - Optional. A string specifying the pseudo-element to get the computed style for.
       * @returns The computed style of the element.
       * @throws Error if `window.getComputedStyle()` is not supported.
       */
      getComputedStyle(elt: Element, pseudoElt?: string): CSSStyleDeclaration;
      getComputedSpatialStyle(elt: SpatialElement, pseudoElt?: string): CSSSpatialStyleDeclaration;
      getSelection(): Selection;
      matchMedia(query: string): MediaQueryList;
      moveBy(x: number, y: number): void;
      moveTo(x: number, y: number): void;
      open(url?: string | URL, target?: string, features?: string): Window;
      postMessage(message: any, targetOrigin: string, transfer?: Transferable[]): void;
      postMessage(message: any, options?: WindowPostMessageOptions): void;
      /**
       * TODO: in XSML, the `print()` method could be used to take a picture based on the current
       * viewer pose.
       */
      print(): void;
      prompt(message?: string, _default?: string): string;
      /**
       * @deprecated
       */
      releaseEvents(): void;
      requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
      resizeBy(x: number, y: number): void;
      resizeTo(width: number, height: number): void;
      scroll(options?: ScrollToOptions): void;
      scroll(x: number, y: number): void;
      scrollBy(options?: ScrollToOptions): void;
      scrollBy(x: number, y: number): void;
      scrollTo(options?: ScrollToOptions): void;
      scrollTo(x: number, y: number): void;
      stop(): void;
      get mozIndexedDB(): IDBFactory;
      get webkitIndexedDB(): IDBFactory;
      get msIndexedDB(): IDBFactory;
      mozRequestAnimationFrame(callback: FrameRequestCallback): number;
      oRequestAnimationFrame(callback: FrameRequestCallback): number;
      get WebGLRenderingContext(): WebGLRenderingContext;
      get CANNON(): any;
      get Audio(): typeof Audio;
      get AudioContext(): AudioContext;
      get webkitAudioContext(): AudioContext;
      cancelAnimationFrame(handle: number): void;
      requestAnimationFrame(callback: FrameRequestCallback): number;
      get localStorage(): Storage;
      get sessionStorage(): Storage;
      get caches(): CacheStorage;
      get crossOriginIsolated(): boolean;
      get crypto(): Crypto;
      get indexedDB(): IDBFactory;
      get isSecureContext(): boolean;
      get origin(): string;
      get performance(): Performance;
      atob(data: string): string;
      btoa(data: string): string;
      createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap>;
      createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number, options?: ImageBitmapOptions): Promise<ImageBitmap>;
      fetch(input: URL | RequestInfo, init?: RequestInit): Promise<Response>;
      queueMicrotask(callback: VoidFunction): void;
      reportError(e: any): void;
      setTimeout(handler: TimerHandler, timeout?: number, ...args: any[]): number;
      setInterval(handler: TimerHandler, timeout?: number, ...args: any[]): number;
      clearInterval(id: number): void;
      clearTimeout(id: number): void;
      structuredClone<T = any>(value: T, options?: StructuredSerializeOptions): T;
      /**
       * FIXME(Yorkie): The below properties are added by Babylon.js, we don't need to implement them but we keep them
       * here for TypeScript to pass the type checking.
       */
      PointerEvent: any;
      Math: Math;
      Uint8Array: Uint8ArrayConstructor;
      Float32Array: Float32ArrayConstructor;
      webkitURL: {
          new (url: string | URL, base?: string | URL): URL;
          prototype: URL;
          canParse(url: string | URL, base?: string): boolean;
          createObjectURL(obj: Blob | MediaSource): string;
          revokeObjectURL(url: string): void;
      };
      mozURL: {
          new (url: string | URL, base?: string | URL): URL;
          prototype: URL;
          canParse(url: string | URL, base?: string): boolean;
          createObjectURL(obj: Blob | MediaSource): string;
          revokeObjectURL(url: string): void;
      };
      msURL: {
          new (url: string | URL, base?: string | URL): URL;
          prototype: URL;
          canParse(url: string | URL, base?: string): boolean;
          createObjectURL(obj: Blob | MediaSource): string;
          revokeObjectURL(url: string): void;
      };
      DracoDecoderModule: any;
      setImmediate(handler: (...args: any[]) => void): number;
  }
  export function createWindow<T extends NativeDocument>(init: WindowOrDOMInit<T>): BaseWindowImpl<T>;

}
declare module '@yodaos-jsar/dom/src/impl-headless' {
  /// <reference types="node_modules/babylonjs/babylon.module" />
  import 'babylonjs';
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import { NativeDocument, NativeEngine, UserAgent } from '@yodaos-jsar/dom/src/impl-interfaces';
  import type ImageDataImpl from '@yodaos-jsar/dom/src/living/image/ImageData';
  export class HeadlessNativeDocument extends EventTarget implements NativeDocument {
      private _startLoop;
      engine: NativeEngine;
      mainCamera: BABYLON.Camera;
      userAgent: UserAgent;
      baseURI: string;
      console: Console;
      attachedDocument: SpatialDocumentImpl<HeadlessNativeDocument>;
      closed: boolean;
      private _scene;
      private _preloadMeshes;
      private _preloadAnimationGroups;
      constructor(_startLoop?: boolean);
      getNativeScene(): BABYLON.Scene;
      getContainerPose(): XRPose;
      getPreloadedMeshes(): Map<string, Array<BABYLON.AbstractMesh | BABYLON.TransformNode>>;
      getPreloadedAnimationGroups(): Map<string, BABYLON.AnimationGroup[]>;
      observeInputEvent(_name?: string): void;
      createBoundTransformNode(_nameOrId: string): BABYLON.TransformNode;
      createImageBitmap(image: ArrayBuffer | ArrayBufferView): Promise<ImageBitmap>;
      decodeImage(_bitmap: ImageBitmap, _size: [number, number]): Promise<ImageDataImpl>;
      stop(): void;
      close(): void;
  }

}
declare module '@yodaos-jsar/dom/src/impl-interfaces' {
  import { ITransport } from '@yodaos-jsar/dom/src/agent/cdp/index';
  import type ImageDataImpl from '@yodaos-jsar/dom/src/living/image/ImageData';
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export interface DOMParser {
      new (document: NativeDocument): DOMParser;
      createDocument(): void;
      createDocumentFragment(): void;
  }
  type ResourceFetchOptions = {
      /**
       * Accept: The Accept request HTTP header advertises which content types,
       *         expressed as MIME types, the client is able to understand.
       */
      accept?: string;
      /**
       * CookieJar: A CookieJar instance to use for this request.
       */
      cookieJar?: any;
      /**
       * Referrer: The referrer of the request.
       */
      referrer?: string;
  };
  /**
   * A `ResourceLoader` is used to load resources, such as scripts, models, textures, audio, etc.
   */
  export interface ResourceLoader {
      /**
       * The method to fetch the given url with the given options.
       *
       * @param url the request url.
       * @param options the request options.
       */
      fetch(url: string, options: ResourceFetchOptions, returnsAs: 'string'): Promise<string>;
      fetch(url: string, options: ResourceFetchOptions, returnsAs: 'json'): Promise<object>;
      fetch(url: string, options: ResourceFetchOptions, returnsAs: 'arraybuffer'): Promise<ArrayBuffer>;
      fetch<T = string | object | ArrayBuffer>(url: string, options: ResourceFetchOptions, returnsAs?: 'string' | 'json' | 'arraybuffer'): Promise<T>;
  }
  export interface RequestManager {
      new (): RequestManager;
      add(req: any): any;
      remove(req: any): any;
      close(): any;
      size(): any;
  }
  export type MediaPlayerConstructor = new () => MediaPlayerBackend;
  export interface MediaPlayerBackend {
      load(buffer: ArrayBuffer | ArrayBufferView, onloaded: () => void): void;
      play(when?: number): void;
      pause(): void;
      canPlayType(type: string): CanPlayTypeResult;
      dispose(): void;
      paused: boolean;
      currentTime: number;
      duration: number;
      volume: number;
      loop: boolean;
      onended: () => void;
  }
  export const xrFeatures: readonly ["anchors", "bounded-floor", "depth-sensing", "dom-overlay", "hand-tracking", "hit-test", "layers", "light-estimation", "local", "local-floor", "secondary-views", "unbounded", "viewer"];
  export type XRFeature = typeof xrFeatures[number];
  export type XRSessionBackendInit = {
      immersiveMode: XRSessionMode;
      requiredFeatures?: XRFeature[];
      optionalFeatures?: XRFeature[];
  };
  export interface XRSessionBackend {
      get enabledFeatures(): readonly XRFeature[];
      request(): Promise<void>;
      requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace | XRBoundedReferenceSpace>;
      end(): Promise<void>;
  }
  export type UserAgentInit = {
      /**
       * Default stylesheet to use for the document.
       */
      defaultStylesheet: string;
      /**
       * The `devicePixelRatio` returns the ratio of the resolution in physical pixels to the
       * resolution in CSS pixels for the current display device.
       */
      devicePixelRatio: number;
  };
  /**
   * Represents a user agent, which is responsible for interacting with the user and managing resources in a web application.
   */
  export interface UserAgent {
      /**
       * The version string of the user agent.
       */
      versionString: string;
      /**
       * The vendor name of the user agent.
       */
      vendor: string;
      /**
       * The vendor subname of the user agent.
       */
      vendorSub: string;
      /**
       * The language of the user agent.
       */
      language: string;
      /**
       * The supported languages of the user agent.
       */
      languages: readonly string[];
      /**
       * See `options.defaultStylesheet`.
       */
      defaultStylesheet: string;
      /**
       * See `options.devicePixelRatio`.
       */
      devicePixelRatio: number;
      /**
       * The approximate amount of device memory in gigabytes.
       */
      deviceMemory?: number;
      /**
       * A `DOMParser` instance is used to parse and load the given XML text content.
       */
      domParser: DOMParser;
      /**
       * `ResourceLoader` instance is used to load resources, such as scripts, models, textures, audio, etc.
       */
      resourceLoader: ResourceLoader;
      /**
       * `RequestManager` instance is used to manage the network requests.
       */
      requestManager: RequestManager;
      /**
       * Sends an alert message to the user. The implementor should display the message in a dialog.
       * @param message The message to alert.
       */
      alert(message?: string): void;
      /**
       * Instructs the user agent to display a dialog with an optional message, and to wait until the user either confirms or cancels the dialog.
       * @param message The message to confirm.
       * @returns A boolean indicating whether OK (true) or Cancel (false) was selected.
       */
      confirm(message?: string): boolean;
      /**
       * Instructs the user agent to display a dialog with an optional message prompting the user to input some text, and to wait until the user either submits the text or cancels the dialog.
       * @param message A string of text to display to the user. Can be omitted if there is nothing to show in the prompt window.
       * @param defaultValue A string containing the default value displayed in the text input field.
       * @returns A string containing the text entered by the user, or `null`.
       */
      prompt(message?: string, defaultValue?: string): string;
      /**
       * Implement the vibrate() method to pulses the vibration hardware on the device.
       */
      vibrate?(pattern: VibratePattern): boolean;
      /**
       * It returns a `WebSocket` constructor, which is used to create a WebSocket connection.
       */
      getWebSocketConstructor?(): typeof WebSocket;
      /**
       * It returns a `MediaPlayer` constructor, which is used to play audio or video as the backend of HTMLMediaElement.
       */
      getMediaPlayerConstructor?(): MediaPlayerConstructor;
      /**
       * It creates a `XRSessionBackend` instance, which is used to create a XRSession and related instances.
       */
      createXRSessionBackend?(init?: XRSessionBackendInit): XRSessionBackend;
      /**
       * Returns if the given `XRSessionMode` is supported.
       * @param mode
       */
      isXRSessionSupported?(mode: XRSessionMode): Promise<boolean>;
  }
  export interface NativeEngine extends BABYLON.Engine {
  }
  /**
   * The entry point that implementation must provide to the native engine.
   */
  export interface NativeDocument extends EventTarget {
      engine: NativeEngine | BABYLON.Engine;
      /**
       * The UserAgent instance that represents the client of executing XSML document.
       */
      userAgent: UserAgent;
      /**
       * The base URI of the document.
       */
      baseURI: string;
      /**
       * A virtual console to log messages, which should be an instance of Console.
       */
      console: Console;
      /**
       * A native document should be attached to a SpatialDocument/Document.
       */
      attachedDocument: SpatialDocumentImpl;
      /**
       * A flag to indicate whether the document is closed.
       */
      closed: boolean;
      /**
       * It returns the underlying native scene instance, currently it's a Babylon.js scene object.
       */
      getNativeScene(): BABYLON.Scene;
      /**
       * It returns a `XRPose` which represents the pose of the container of the document in space.
       */
      getContainerPose(): XRPose;
      /**
       * It returns a `XRPose` which represents the pose of the viewer in space.
       */
      getViewerPose?(): XRPose;
      /**
       * It returns a map of preloaded meshes.
       *
       * When loading a XSML document, the implementation should preload the specific meshes.
       */
      getPreloadedMeshes(): Map<string, Array<BABYLON.AbstractMesh | BABYLON.TransformNode>>;
      /**
       * It returns a map of preloaded animation groups.
       */
      getPreloadedAnimationGroups(): Map<string, BABYLON.AnimationGroup[]>;
      /**
       * To receive given input event from the native engine, the caller should call this method to observe
       * the specific input events.
       *
       * @param name The name of the input event to observe.
       */
      observeInputEvent(name?: string): void;
      /**
       * It creates a TransformNode as a bouding box of the given mesh.
       *
       * @param nameOrId the name or id of this bouding box.
       */
      createBoundTransformNode(nameOrId: string): BABYLON.TransformNode;
      /**
       * It creates a `ImageBitmap` from the given image buffer.
       * @param image
       */
      createImageBitmap(image: ArrayBuffer | ArrayBufferView): Promise<ImageBitmap>;
      /**
       * It decodes a given `ImageBitmap` with the expected size, then returns a promise of ImageData which contains the decoded pixels.
       *
       * @param image The image buffer to decode.
       * @param sizes The size of the image in width and height.
       */
      decodeImage(bitmap: ImageBitmap, size?: [number, number]): Promise<ImageDataImpl>;
      /**
       * This stops further resource loading in the current context.
       */
      stop(): void;
      /**
       * This closes this document, the implementor should release all resources and
       * mark the document's `closed` flag to `true`.
       */
      close(): void;
      /**
       * The transport used by the CDP.
       */
      cdpTransport?: ITransport;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/index' {
  /// <reference types="node_modules/babylonjs/babylon.module" />
  import 'babylonjs';
  import './living/helpers/babylonjs/patches';
  import './living/helpers/babylonjs/loaders/gLTF/index';
  import { BaseWindowImpl, WindowOrDOMInit } from '@yodaos-jsar/dom/src/agent/window';
  import * as cdpImplementation from '@yodaos-jsar/dom/src/agent/cdp/cdp-implementation';
  import * as cdpTransport from '@yodaos-jsar/dom/src/agent/cdp/transport/index';
  import * as nodetype from '@yodaos-jsar/dom/src/living/node-type';
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import { JSARInputEvent } from '@yodaos-jsar/dom/src/input-event';
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  const windowSymbol: unique symbol;
  /**
   * It represents a JSAR DOM instance.
   */
  export class JSARDOM<T extends NativeDocument> {
      id: string;
      [windowSymbol]: BaseWindowImpl<T>;
      private _markupOrUrl;
      private _nativeDocument;
      static get version(): string;
      constructor(markupOrUrl: string, init: WindowOrDOMInit<T>);
      get window(): BaseWindowImpl<T>;
      get document(): SpatialDocumentImpl<T>;
      get nativeDocument(): T;
      /**
       * It starts parsing the markup string and creating the document.
       */
      load(): Promise<void>;
      /**
       * The event "spaceReady" is a new event introduced by JSAR, which means the space initialization is finished.
       * Calling this method will return a promise which will be resolved when the "spaceReady" event is fired.
       */
      waitForSpaceReady(): Promise<void>;
      /**
       * This method is a shortcut to fetch the basic information of a loaded document.
       */
      createDocumentManifest(): Promise<Partial<{
          /**
           * The version of the document spec, defined by <xsml version="{version}" >.
           */
          specVersion: string;
          /**
           * The url of the document.
           */
          url: string;
          /**
           * The title of the document, defined by <title>{title}</title>.
           */
          title: string;
          /**
           * The charset of the document, defined by <meta charset="{charset}" >.
           */
          charset: string;
          /**
           * The description of the document, defined by <meta name="description" content="{description}" >.
           */
          description: string;
          /**
           * The author of the document, defined by <meta name="author" content="{author}" >.
           */
          author: string;
          /**
           * The keywords of the document, defined by <meta name="keywords" content="{keywords}" >.
           */
          keywords: string;
          /**
           * The rating of the document, defined by <meta name="rating" content="{rating}" >.
           */
          rating: string;
          /**
           * The license of the document, defined by <meta name="license" content="{license}" >.
           */
          license: string;
          /**
           * The license url of the document, defined by <meta name="license-url" content="{licenseUrl}" >.
           */
          licenseUrl: string;
          /**
           * The viewport of the document, defined by <meta name="viewport" content="{viewport}" >.
           */
          viewport: {
              initialScale: number;
              maximumScale?: number;
              minimumScale?: number;
          };
      }>>;
      /**
       * Dispose the loaded document and close the window.
       */
      unload(): Promise<void>;
      /**
       * Dispatch the input events to document.
       * @param event
       */
      dispatchInputEvent(event: JSARInputEvent): boolean;
      private _beforeLoad;
  }
  export * from '@yodaos-jsar/dom/src/impl-interfaces';
  export { SpatialDocumentImpl, JSARInputEvent, };
  export namespace nodes {
      const NodeTypes: Readonly<{
          ELEMENT_NODE: 1;
          ATTRIBUTE_NODE: 2;
          TEXT_NODE: 3;
          CDATA_SECTION_NODE: 4;
          ENTITY_REFERENCE_NODE: 5;
          ENTITY_NODE: 6;
          PROCESSING_INSTRUCTION_NODE: 7;
          COMMENT_NODE: 8;
          DOCUMENT_NODE: 9;
          DOCUMENT_TYPE_NODE: 10;
          DOCUMENT_FRAGMENT_NODE: 11;
          NOTATION_NODE: 12;
      }>;
      const isElementNode: typeof nodetype.isElementNode;
      const isAttributeNode: typeof nodetype.isAttributeNode;
      const isTextNode: typeof nodetype.isTextNode;
      const isHTMLElement: typeof nodetype.isHTMLElement;
      const isSpatialElement: typeof nodetype.isSpatialElement;
  }
  export namespace cdp {
      export import ITransport = cdpTransport.ITransport;
      export import LoopbackTransport = cdpTransport.LoopbackTransport;
      export import createRemoteClient = cdpImplementation.createRemoteClient;
  }

}
declare module '@yodaos-jsar/dom/src/index.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/input-event' {
  export enum HandGesture {
      None = -1,
      Grip = 1,
      Palm = 2,
      Pinch = 3,
      OpenPinch = 4
  }
  export enum HandOrientation {
      Up = 0,
      Down = 1,
      Left = 2,
      Right = 3
  }
  export type HandtrackingInputDetail = {
      handId: number;
      joints: Array<{
          position: DOMPointInit;
          rotation: DOMPointInit;
      }>;
      pose?: {
          position: DOMPointInit;
          rotation: DOMPointInit;
      };
      gesture?: HandGesture;
      orientation?: HandOrientation;
  };
  export type RaycastInputDetail = {
      sourceId: string;
      sourceType?: 'hand' | 'head' | 'gamepad' | 'mouse' | 'custom';
      targetSpatialElementInternalGuid: number;
      uvCoord: BABYLON.Nullable<BABYLON.Vector2>;
  };
  export type RaycastActionInputDetail = {
      type: 'up' | 'down' | 'click';
      sourceId: RaycastInputDetail['sourceId'];
  };
  export type JSARInputDetail = HandtrackingInputDetail | RaycastInputDetail | RaycastActionInputDetail;
  export class JSARInputEvent extends Event {
      subType: 'handtracking' | 'raycast' | 'raycast_action';
      detail: JSARInputDetail;
      constructor(subType: 'handtracking', detail: HandtrackingInputDetail);
      constructor(subType: 'raycast', detail: RaycastInputDetail);
      constructor(subType: 'raycast_action', detail: RaycastActionInputDetail);
  }

}
declare module '@yodaos-jsar/dom/src/living/attributes/Attr' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export class AttrImpl extends NodeImpl implements Attr {
      #private;
      specified: boolean;
      constructor(hostObject: NativeDocument, _args: any, privateData: {
          localName: string;
          namespace?: string | null;
          namespacePrefix?: string | null;
          value?: string;
          element?: Element | null;
      });
      get namespaceURI(): string;
      get prefix(): string;
      get localName(): string;
      get name(): string;
      get nodeName(): string;
      get value(): string;
      set value(value: string);
      _setValue(value: string): void;
      get ownerElement(): Element;
      /**
       * @internal
       */
      get _qualifiedName(): string;
      /**
       * @internal
       */
      get _element(): Element | null;
      /**
       * @internal
       */
      set _element(value: Element | null);
  }

}
declare module '@yodaos-jsar/dom/src/living/attributes/NamedNodeMap' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  export default class NamedNodeMapImpl implements NamedNodeMap {
      [index: number]: Attr;
      _nativeDocument: NativeDocument;
      _element: ElementImpl;
      constructor(nativeDocument: NativeDocument, args: Array<any>, privateData: {
          element: ElementImpl;
      });
      private get _attributeList();
      get length(): number;
      getNamedItem(qualifiedName: string): Attr;
      getNamedItemNS(namespace: string, localName: string): Attr;
      item(index: number): Attr;
      removeNamedItem(qualifiedName: string): Attr;
      removeNamedItemNS(namespace: string, localName: string): Attr;
      setNamedItem(attr: Attr): Attr;
      setNamedItemNS(attr: Attr): Attr;
      [Symbol.iterator](): IterableIterator<Attr>;
  }

}
declare module '@yodaos-jsar/dom/src/living/attributes' {
  import { AttrImpl } from '@yodaos-jsar/dom/src/living/attributes/Attr';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  export function hasAttribute(element: ElementImpl, attr: AttrImpl): boolean;
  export function hasAttributeByName(element: ElementImpl, name: string): boolean;
  export function hasAttributeByNameNS(element: ElementImpl, namespace: string, localName: string): boolean;
  export function changeAttribute(element: ElementImpl, attr: AttrImpl, value: string): void;
  export function appendAttribute(element: ElementImpl, attribute: AttrImpl): void;
  export function removeAttribute(element: ElementImpl, attribute: AttrImpl): void;
  export function replaceAttribute(element: ElementImpl, oldAttr: AttrImpl, newAttr: AttrImpl): void;
  export function getAttributeByName(element: ElementImpl, name: string): AttrImpl;
  export function getAttributeByNameNS(element: ElementImpl, namespace: string, localName: string): AttrImpl;
  export function getAttributeValue(element: ElementImpl, localName: string): string;
  export function getAttributeValueNS(element: ElementImpl, namespace: string, localName: string): string;
  export function setAttribute(element: ElementImpl, attr: AttrImpl): AttrImpl;
  export function setAttributeValue(element: ElementImpl, localName: string, value: string, prefix?: string, namespace?: string): void;
  export function setAnExistingAttributeValue(attribute: AttrImpl, value: string): void;
  export function removeAttributeByName(element: ElementImpl, name: string): AttrImpl;
  export function removeAttributeByNameNS(element: ElementImpl, namespace: string, localName: string): AttrImpl;
  export function attributeNames(element: ElementImpl): string[];
  export function hasAttributes(element: ElementImpl): boolean;

}
declare module '@yodaos-jsar/dom/src/living/compatible.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/crypto/Noise' {
  export default class NoiseImpl {
      seed?: number;
      constructor(seed?: number);
      private _simplexN;
      private _perlinN;
      simplex2(x: number, y: number): number;
      simplex3(x: number, y: number, z: number): number;
      simplex4(x: number, y: number, z: number, w: number): number;
      perlin2(x: number, y: number): number;
      perlin3(x: number, y: number, z: number): number;
      perlin4(x: number, y: number, z: number, w: number): number;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSRule' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { css, parseCss } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  export default class CSSRuleImpl implements CSSRule {
      parentRule: CSSRule;
      parentStyleSheet: CSSStyleSheet;
      type: number;
      STYLE_RULE: 1;
      CHARSET_RULE: 2;
      IMPORT_RULE: 3;
      MEDIA_RULE: 4;
      FONT_FACE_RULE: 5;
      PAGE_RULE: 6;
      NAMESPACE_RULE: 10;
      KEYFRAMES_RULE: 7;
      KEYFRAME_RULE: 8;
      SUPPORTS_RULE: 12;
      MATERIAL_RULE: 20;
      protected _hostObject: NativeDocument;
      protected _cssText: string;
      protected _ast: ReturnType<typeof parseCss>;
      protected _node: css.Node;
      constructor(hostObject: NativeDocument, _args: any[], privateData: css.Node & {
          ast: ReturnType<typeof parseCss>;
      });
      get cssText(): string;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSRuleList' {
  export default class CSSRuleListImpl implements CSSRuleList {
      _rules: CSSRule[];
      [index: number]: CSSRule;
      get length(): number;
      item(index: number): CSSRule;
      /**
       * @internal
       */
      _add(rule: CSSRule): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialKeyframeRule' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { parseCss, css } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  import CSSRuleImpl from '@yodaos-jsar/dom/src/living/cssom/CSSRule';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  export default class CSSSpatialKeyframeRule extends CSSRuleImpl {
      private _keyText;
      private _style;
      /**
       * @readonly
       */
      get keyText(): string;
      /**
       * @readonly
       */
      get style(): CSSSpatialStyleDeclaration;
      constructor(hostObject: NativeDocument, args: any[], privateData: {
          keyText: string;
          node: css.KeyFrame;
          ast: ReturnType<typeof parseCss>;
      });
      private _initiateStyle;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialKeyframesRule' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { parseCss, css } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  import CSSRuleImpl from '@yodaos-jsar/dom/src/living/cssom/CSSRule';
  import CSSSpatialKeyframeRule from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialKeyframeRule';
  export default class CSSSpatialKeyframesRule extends CSSRuleImpl {
      private _name;
      private _keyframeRules;
      [index: number]: CSSSpatialKeyframeRule;
      cssRules: CSSRuleList;
      get length(): number;
      get name(): string;
      constructor(hostObject: NativeDocument, args: any[], privateData: {
          node: css.KeyFrames;
          ast: ReturnType<typeof parseCss>;
      });
      private _appendRule;
      appendRule(rule: string): void;
      deleteRule(select: string): void;
      findRule(select: string): CSSSpatialKeyframeRule;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialMaterialRule' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { AtMaterial, parseCss } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  import CSSRuleImpl from '@yodaos-jsar/dom/src/living/cssom/CSSRule';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  export default class CSSSpatialMaterialRule extends CSSRuleImpl {
      readonly style: CSSSpatialStyleDeclaration;
      private _name;
      private _scene;
      private _material;
      get name(): string;
      constructor(hostObject: NativeDocument, args: any[], privateData: {
          node: AtMaterial;
          ast: ReturnType<typeof parseCss>;
      });
      private _initiateStyle;
      private _setMaterialColor;
      private _setMaterialTexture;
      private _getMaterialType;
      private _createMaterial;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration' {
  import { type PropertyValue } from '@yodaos-jsar/dom/src/living/cssom/parsers/index';
  import { type CSSSpatialStyleProperties } from '@yodaos-jsar/dom/src/living/cssom/spatial-properties/index';
  type PropertyPriority = 'important' | null;
  export default interface CSSSpatialStyleDeclaration extends CSSSpatialStyleProperties {
  }
  export default class CSSSpatialStyleDeclaration {
      _length: number;
      _dirty: boolean;
      _values: {
          [key: string]: PropertyValue;
      };
      _importants: {
          [key: string]: PropertyPriority;
      };
      _onChange: (cssText?: string) => void;
      constructor(onChange?: (cssText?: string) => void);
      get cssText(): string;
      set cssText(value: string);
      get length(): number;
      set length(value: number);
      get parentRule(): CSSRule;
      getPropertyValue(name: string): string;
      _getPropertyValue(name: string): PropertyValue;
      setProperty(name: string, value: string, priority?: string): void;
      _setProperty(name: string, value: PropertyValue, priority?: PropertyPriority): void;
      removeProperty(name: string): string;
      getPropertyPriority(name: string): string;
      getPropertyCSSValue(): void;
      getPropertyShorthand(): void;
      isPropertyImplicit(): void;
      item(index: number | string): any;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleRule' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { css } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  import CSSRuleImpl from '@yodaos-jsar/dom/src/living/cssom/CSSRule';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  export default class CSSSpatialStyleRule extends CSSRuleImpl {
      selectorText: string;
      readonly style: CSSSpatialStyleDeclaration;
      readonly styleMap: StylePropertyMap;
      constructor(hostObject: NativeDocument, args: any[], privateData: css.Rule & ConstructorParameters<typeof CSSRuleImpl>[2]);
      _initiateStyle(decls: Array<css.Comment | css.Declaration>): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSStyleRule' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { css } from '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser';
  import CSSRuleImpl from '@yodaos-jsar/dom/src/living/cssom/CSSRule';
  export default class CSSStyleRuleImpl extends CSSRuleImpl implements CSSStyleRule {
      cssRules: CSSRuleList;
      selectorText: string;
      readonly style: CSSStyleDeclaration;
      readonly styleMap: StylePropertyMap;
      constructor(hostObject: NativeDocument, args: any[], privateData: css.Rule & ConstructorParameters<typeof CSSRuleImpl>[2]);
      _initiateStyle(decls: Array<css.Comment | css.Declaration>): void;
      deleteRule(index: number): void;
      insertRule(rule: string, index?: number): number;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/CSSStyleSheet' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import StyleSheetImpl from '@yodaos-jsar/dom/src/living/cssom/StyleSheet';
  export default class CSSStyleSheetImpl extends StyleSheetImpl implements CSSStyleSheet {
      cssRules: CSSRuleList;
      ownerRule: CSSRule;
      /**
       * @deprecated
       */
      rules: CSSRuleList;
      protected _hostObject: NativeDocument;
      protected _isSpatial: boolean;
      static createForImpl(hostObject: NativeDocument, args: [CSSStyleSheetInit?], privateData: {
          isSpatial: boolean;
          cssText?: string;
      }): CSSStyleSheetImpl;
      constructor(init?: CSSStyleSheetInit);
      protected _initWithCssText(cssText: string): void;
      private _addStyleRule;
      private _addMaterialRule;
      private _addKeyframesRule;
      addRule(selector?: string, style?: string, index?: number): number;
      deleteRule(index: number): void;
      insertRule(rule: string, index?: number): number;
      removeRule(index?: number): void;
      replace(text: string): Promise<CSSStyleSheet>;
      replaceSync(text: string): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/StyleSheet' {
  export default class StyleSheetImpl implements StyleSheet {
      disabled: boolean;
      href: string;
      media: MediaList;
      ownerNode: Element | ProcessingInstruction;
      parentStyleSheet: CSSStyleSheet;
      title: string;
      type: string;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/StyleSheetList' {
  export default class StyleSheetListImpl extends Array<CSSStyleSheet> implements StyleSheetList {
      constructor();
      item(index: number): CSSStyleSheet;
      /**
       * @internal
       */
      _add(sheet: CSSStyleSheet): void;
      /**
       * @internal
       */
      _remove(sheet: CSSStyleSheet): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/materials/GridMaterial' {
  import { PropertyValue } from '@yodaos-jsar/dom/src/living/cssom/parsers/index';
  export default class GridMaterial extends BABYLON.StandardMaterial {
      width: number;
      height: number;
      private _enabled;
      private _texture;
      private _cellWidth;
      private _cellHeight;
      private _backgroundColor;
      private _majorLineColor;
      private _minorLineColor;
      private _majorLineThickness;
      private _minorLineThickness;
      private _majorLineFrequency;
      private _displayMajorLines;
      private _displayMinorLines;
      constructor(name: string, scene: BABYLON.Scene, width?: number, height?: number);
      private get _context();
      get cellWidth(): number;
      set cellWidth(value: number | PropertyValue);
      get cellHeight(): number;
      set cellHeight(value: number | PropertyValue);
      get backgroundColor(): string;
      set backgroundColor(value: string);
      get majorLineColor(): string;
      set majorLineColor(value: string);
      get minorLineColor(): string;
      set minorLineColor(value: string);
      get displayMajorLines(): boolean;
      set displayMajorLines(value: boolean);
      get displayMinorLines(): boolean;
      set displayMinorLines(value: boolean);
      _enable(): void;
      _drawGridSystem(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/Error' {
  export class $Error extends Error {
      readonly code: string;
      constructor(code: string, message?: string);
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/character' {
  import { CodePointTest } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const Zero = 48;
  export const Nine = 57;
  export const Dot = 46;
  export const Space = 32;
  export const HTab = 9;
  export const LF = 10;
  export const CR = 13;
  export const UpperA = 65;
  export const LowerA = 97;
  export const UpperF = 70;
  export const LowerF = 102;
  export const UpperM = 77;
  export const LowerM = 109;
  export const UpperS = 83;
  export const LowerS = 115;
  export const UpperZ = 90;
  export const LowerZ = 122;
  export const DoubleQuote = 34;
  export const SingleQuote = 39;
  export const OpenParenthesis = 40;
  export const CloseParenthesis = 41;
  export const Comma = 44;
  export const Backslash = 92;
  export const Hyphen = 45;
  export const Underscore = 95;
  export const isInRange: (cp: number | undefined, min: number, max: number) => cp is number;
  export const isOneOf: (...cps: Array<number>) => CodePointTest;
  export const isNot: (...cps: Array<number>) => CodePointTest;
  export const isWhiteSpace: CodePointTest;
  export const isDigit: CodePointTest;
  export const isUpperAlpha: CodePointTest;
  export const isLowerAlpha: CodePointTest;
  export const isAlpha: CodePointTest;
  export const isNumberStart: CodePointTest;
  export const isHexCharacter: CodePointTest;
  export const isIdentCharacter: CodePointTest;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/fillAnimation' {
  import { CSSAnimation } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const fillAnimation: (patch: Partial<CSSAnimation> & {
      name: string;
  }) => CSSAnimation;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getCubicBezier' {
  import { CSSCubicBezier } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const getCubicBezier: (input: string, start: number) => {
      start: number;
      end: number;
      value: CSSCubicBezier;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getCubicBezier.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getCustomIdent' {
  export const getCustomIdent: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };
  export const getCustomIdentOrNull: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getCustomIdent.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getNumber' {
  export const getNumber: (input: string, start: number) => {
      start: number;
      end: number;
      value: number;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getNumber.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getSteps' {
  import { CSSSteps } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const getSteps: (input: string, start: number) => {
      start: number;
      end: number;
      value: CSSSteps;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getSteps.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getString' {
  export const getString: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/getString.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/index' {
  export * from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const parseSingle: (input: string, startFrom?: number) => {
      start: number;
      end: number;
      value: import("@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type").CSSAnimation;
  };
  export const parse: (input: string) => import("@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type").CSSAnimation[];
  export const serialize: (animation: Partial<import("@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type").CSSAnimation> & {
      name: string;
  }) => string;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/index.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/keyword' {
  export const StepDirection: Set<string>;
  export const TimingFunctionKeyword: Set<string>;
  export const AnimationDirection: Set<string>;
  export const AnimationFillMode: Set<string>;
  export const AnimationPlayState: Set<string>;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/parseAnimationShorthand' {
  import { CSSAnimation } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const parseAnimationShorthand: (input: string) => Generator<CSSAnimation>;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/parseAnimationShorthand.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/parseSingleAnimationShorthand' {
  import { CSSAnimation } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const parseSingleAnimationShorthand: (input: string, startFrom?: number) => {
      start: number;
      end: number;
      value: CSSAnimation;
  };

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/parseSingleAnimationShorthand.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeAnimation' {
  import { CSSAnimation } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const serializeAnimation: (animation: Partial<CSSAnimation> & {
      name: string;
  }) => string;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeAnimation.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeAnimationValue' {
  import { CSSAnimation } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const serializeAnimationValue: <Key extends keyof CSSAnimation>(key: Key, value: CSSAnimation[Key]) => string;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeAnimationValue.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeNumber' {
  export const serializeNumber: (value: number) => string;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/serializeNumber.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/shortest' {
  export const shortest: (...list: Array<string>) => string;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/shortest.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/skip' {
  import { CodePointTest } from '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type';
  export const skip: (input: string, start: number, test: CodePointTest) => number;

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/skip.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/animation-shorthand/type' {
  export interface CodePointTest {
      (cp?: number): cp is number;
  }
  export interface CSSCubicBezier {
      type: 'cubic-bezier';
      value: [number, number, number, number];
  }
  export type CSSStepDirection = 'jump-start' | 'jump-end' | 'jump-none' | 'jump-both' | 'start' | 'end';
  export interface CSSSteps {
      type: 'steps';
      stepCount: number;
      direction: CSSStepDirection;
  }
  export type CSSTimingFunctionKeyword = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'step-start' | 'step-end';
  export type CSSTimingFunction = CSSCubicBezier | CSSSteps | CSSTimingFunctionKeyword;
  export type CSSAnimationDirection = 'normal' | 'reverse' | 'alternate' | 'alternate-reverse';
  export type CSSAnimationFillMode = 'none' | 'forwards' | 'backwards' | 'both';
  export type CSSAnimationPlayState = 'paused' | 'running';
  export interface CSSAnimation {
      name: string;
      duration: number | 'unset';
      timingFunction: CSSTimingFunction | 'unset';
      delay: number | 'unset';
      iterationCount: number | 'infinite' | 'unset';
      direction: CSSAnimationDirection | 'unset';
      fillMode: CSSAnimationFillMode | 'unset';
      playState: CSSAnimationPlayState | 'unset';
  }

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/index' {
  import type CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  import { defineSpatialProperty } from '@yodaos-jsar/dom/src/living/cssom/spatial-properties/helper';
  export enum CSSValueType {
      INTEGER = 1,
      NUMBER = 2,
      LENGTH = 3,
      PERCENT = 4,
      TIMESPAN = 5,
      URL = 6,
      COLOR = 7,
      STRING = 8,
      ANGLE = 9,
      KEYWORD = 10,
      NULL_OR_EMPTY_STR = 11,
      CALC = 12,
      SET = 13,
      UNKNOWN = 999
  }
  const SupportedLengthUnitsArray: readonly ["px", "em", "rem"];
  export type SupportedLengthUnit = typeof SupportedLengthUnitsArray[number];
  export class PropertyValue<T = any> {
      str: string;
      type: CSSValueType;
      value: T;
      static NULL_OR_EMPTY_STR: PropertyValue<any>;
      static createInteger(str: string, radix?: number): PropertyIntegerValue;
      static createNumber(str: string): PropertyNumberValue;
      static createLength(number: number, unit: SupportedLengthUnit): PropertyLengthValue;
      static createPercentage(value: number): PropertyPercentageValue;
      static createTimespan(value: number): PropertyTimespanValue;
      static createUrl(str: string, urlSource: string): PropertyUrlValue;
      static createString(str: string): PropertyStringValue;
      static createColor(r: number, g: number, b: number, a?: number): PropertyColorValue;
      static createAngle(degree: number): PropertyAngleValue;
      static createKeyword(str: string): PropertyKeywordValue;
      static createSet(values: PropertyValue[]): PropertySetValue;
      constructor(type: CSSValueType, str: string, value: T);
      isNumberValue(): this is PropertyNumberValue;
      isIntegerValue(): this is PropertyIntegerValue;
      isLengthValue(): this is PropertyLengthValue;
      isPercentageValue(): this is PropertyPercentageValue;
      isTimespanValue(): this is PropertyTimespanValue;
      isUrlValue(): this is PropertyUrlValue;
      isStringValue(): this is PropertyStringValue;
      isColorValue(): this is PropertyColorValue;
      isAngleValue(): this is PropertyAngleValue;
      isKeywordValue(): this is PropertyKeywordValue;
      isSetValue(): this is PropertyValue<PropertyValue[]>;
      toNumber(): number;
      toLength(): {
          number: number;
          unit: "em" | "px" | "rem";
      };
      toAngle(as?: 'deg' | 'rad' | 'grad'): number;
      toColor(): PropertyColorValue['value'] | undefined;
      toUrlString(): string | undefined;
  }
  export type PropertyIntegerValue = PropertyValue<number>;
  export type PropertyNumberValue = PropertyValue<number>;
  export type PropertyLengthValue = PropertyValue<{
      number: number;
      unit: SupportedLengthUnit;
  }>;
  export type PropertyPercentageValue = PropertyValue<number>;
  export type PropertyTimespanValue = PropertyValue<number>;
  export type PropertyUrlValue = PropertyValue<string>;
  export type PropertyStringValue = PropertyValue<string>;
  export type PropertyColorValue = PropertyValue<{
      r: number;
      g: number;
      b: number;
      a: number;
  }>;
  export type PropertyAngleValue = PropertyValue<number>;
  export type PropertyKeywordValue = PropertyValue<string>;
  export type PropertySetValue = PropertyValue<PropertyValue[]>;
  export function valueType(val: any): CSSValueType | undefined;
  export function toIntegerStr(val: any): PropertyIntegerValue;
  export function toNumberStr(val: any): PropertyValue<number>;
  export function toLengthStr(val: any): PropertyLengthValue;
  export function toPercentStr(val: any): PropertyPercentageValue;
  export function toTimespanStr(val: any): PropertyTimespanValue;
  export function toUrlStr(val: any): PropertyUrlValue;
  export function toStringStr(val: any): PropertyValue<string>;
  export function toColorStr(val: any): PropertyKeywordValue | PropertyColorValue;
  export function toAngleStr(val: any): PropertyAngleValue;
  export function autoCreatePropertyValue(val: any): PropertyValue;
  export function camelToDashed(input: string): string;
  export function dashedToCamel(input: string): string;
  /**
   * isValid(){1,4} | inherit
   * if one, it applies to all
   * if two, the first applies to the top and bottom, and the second to left and right
   * if three, the first applies to the top, the second to left and right, the third bottom
   * if four, top, right, bottom, left
   *
   * @param before
   * @param after
   * @param validator
   * @param parser
   */
  export function implicitSetter(before: string, after: string, partNames: string[], validator: (v: string) => boolean, toPropertyValue: (v: any) => PropertyValue): (this: CSSSpatialStyleDeclaration, v: any) => string;
  export type ShorthandFor = {
      [key: string]: ReturnType<typeof defineSpatialProperty>;
  };
  export function parseShorthand(v: any, shorthandFor: ShorthandFor): {
      [key: string]: string;
  };
  export function shorthandGetter(property: string, shorthandFor: ShorthandFor): (this: CSSSpatialStyleDeclaration) => string;
  export function shorthandSetter(property: string, shorthandFor: {
      [key: string]: ReturnType<typeof defineSpatialProperty>;
  }): (this: CSSSpatialStyleDeclaration, v: any) => void;
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/index.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/parsers/named-colors' {
  export const namedColors: Record<string, [number, number, number, number?]>;
  export type ColorName = keyof typeof namedColors;
  export const colorNames: string[];

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/albedo-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/albedo-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/ambient-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/ambient-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/animation-duration' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/animation-iteration-count' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/animation-name' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/animation' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/bump-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/diffuse-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/diffuse-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/emissive-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/emissive-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/helper' {
  import type CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  type SpatialPropertyDescriptor = Omit<PropertyDescriptor, 'get' | 'set'> & {
      get?(this: CSSSpatialStyleDeclaration): string;
      set?(this: CSSSpatialStyleDeclaration, value: string): void;
  };
  type Extras = {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export function defineSpatialProperty(descriptor: SpatialPropertyDescriptor, extra?: Partial<Extras>): SpatialPropertyDescriptor & Extras;
  export {};

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/index' {
  import type CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  export interface CSSSpatialStyleProperties {
      position: string;
      rotation: string;
      scaling: string;
      x: string;
      y: string;
      z: string;
      animation: string;
      'animation-name': string;
      animationName: string;
      'animation-duration': string;
      animationDuration: string;
      'animation-iteration-count': string;
      animationIterationCount: string;
      material: string;
      'material-type': string;
      materialType: string;
      'material-alpha-mode': string;
      materialAlphaMode: string;
      'material-orientation': string;
      materialOrientation: string;
      'material-grid-background-color': string;
      materialGridBackgroundColor: string;
      'material-grid-width': string;
      materialGridWidth: string;
      'material-grid-height': string;
      materialGridHeight: string;
      'material-grid-cell-width': string;
      materialGridCellWidth: string;
      'material-grid-cell-height': string;
      materialGridCellHeight: string;
      'material-grid-major-line-color': string;
      materialGridMajorLineColor: string;
      'material-grid-minor-line-color': string;
      materialGridMinorLineColor: string;
      wireframe: string;
      'diffuse-color': string;
      diffuseColor: string;
      'diffuse-texture': string;
      diffuseTexture: string;
      'ambient-color': string;
      ambientColor: string;
      'ambient-texture': string;
      ambientTexture: string;
      'emissive-color': string;
      emissiveColor: string;
      'emissive-texture': string;
      emissiveTexture: string;
      'specular-color': string;
      specularColor: string;
      'specular-texture': string;
      specularTexture: string;
      'specular-power': string;
      specularPower: string;
      'bump-texture': string;
      bumpTexture: string;
      'physical-metallic': string;
      physicalMetallic: string;
      'physical-roughness': string;
      physicalRoughness: string;
      'albedo-color': string;
      albedoColor: string;
      'albedo-texture': string;
      albedoTexture: string;
  }
  export function mixinWithSpatialStyleProperties(spatialStyleDeclaration: CSSSpatialStyleDeclaration): void;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-alpha-mode' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-background-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-cell-height' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-cell-width' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-height' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-major-line-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-minor-line-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-grid-width' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-orientation' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material-type' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/material' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/physical-metallic' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/physical-roughness' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/position-x' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/position-y' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/position-z' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/position' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/rotation' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/scaling' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/specular-color' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/specular-power' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/specular-texture' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/spatial-properties/wireframe' {
  const _default: Omit<PropertyDescriptor, "set" | "get"> & {
      get?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default): string;
      set?(this: import("@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration").default, value: string): void;
  } & {
      isValid: (v: any, ...extra: any[]) => boolean;
  };
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/cssom/utils/color-space' {
  /**
   * @param {number} hue - Hue as degrees 0..360
   * @param {number} sat - Saturation as percentage 0..100
   * @param {number} light - Lightness as percentage 0..100
   * @return {number[]} Array of RGB components 0..255
   */
  export function hslToRgb(hue: number, sat: number, light: number): [number, number, number];

}
declare module '@yodaos-jsar/dom/src/living/custom-elements/CustomElementRegistry' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export type CustomElementDefinition = {
      name: string;
      localName: string;
      constructor: CustomElementConstructor;
      objectReference: any;
      observedAttributes: string[];
      lifecycleCallbacks: {
          connectedCallback: any;
          disconnectedCallback: any;
          adoptedCallback: any;
          attributeChangedCallback: any;
      };
      disableShadow: boolean;
      constructionStack: Element[];
  };
  export class CustomElementRegistryImpl implements CustomElementRegistry {
      private nativeDocument;
      _customElementDefinitions: CustomElementDefinition[];
      _elementDefinitionIsRunning: boolean;
      _whenDefinedPromiseMap: any;
      constructor(nativeDocument: NativeDocument);
      define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void;
      get(name: string): CustomElementConstructor;
      upgrade(root: Node): void;
      whenDefined(name: string): Promise<CustomElementConstructor>;
  }

}
declare module '@yodaos-jsar/dom/src/living/domexception' {
  type DOMExceptionName = 'INDEX_SIZE_ERR' | 'DOMSTRING_SIZE_ERR' | 'HIERARCHY_REQUEST_ERR' | 'WRONG_DOCUMENT_ERR' | 'INVALID_CHARACTER_ERR' | 'NO_DATA_ALLOWED_ERR' | 'NO_MODIFICATION_ALLOWED_ERR' | 'NOT_FOUND_ERR' | 'NOT_SUPPORTED_ERR' | 'INUSE_ATTRIBUTE_ERR' | 'INVALID_STATE_ERR' | 'SYNTAX_ERR' | 'INVALID_MODIFICATION_ERR' | 'NAMESPACE_ERR' | 'INVALID_ACCESS_ERR' | 'VALIDATION_ERR' | 'TYPE_MISMATCH_ERR' | 'SECURITY_ERR' | 'NETWORK_ERR' | 'ABORT_ERR' | 'URL_MISMATCH_ERR' | 'QUOTA_EXCEEDED_ERR' | 'TIMEOUT_ERR' | 'INVALID_NODE_TYPE_ERR' | 'DATA_CLONE_ERR';
  class DOMExceptionImpl extends TypeError implements DOMException {
      /**
       * Error code indicating that an index is out of range or not valid.
       */
      INDEX_SIZE_ERR: 1;
      /**
       * The DOMSTRING_SIZE_ERR constant represents an error code indicating that the resulting string is too long to be stored in a DOMString.
       */
      DOMSTRING_SIZE_ERR: 2;
      /**
       * Error code indicating a hierarchy request error.
       */
      HIERARCHY_REQUEST_ERR: 3;
      /**
       * Error code indicating that a node is used in a different document than the one it was created in.
       */
      WRONG_DOCUMENT_ERR: 4;
      /**
       * Error code indicating an invalid character.
       */
      INVALID_CHARACTER_ERR: 5;
      /**
       * Error code indicating that data is not allowed.
       */
      NO_DATA_ALLOWED_ERR: 6;
      /**
       * Error code indicating that the modification is not allowed.
       */
      NO_MODIFICATION_ALLOWED_ERR: 7;
      /**
       * Error code indicating that the requested item was not found.
       */
      NOT_FOUND_ERR: 8;
      /**
       * Error code indicating that the operation is not supported.
       */
      NOT_SUPPORTED_ERR: 9;
      /**
       * Error code indicating that an attribute is already in use.
       */
      INUSE_ATTRIBUTE_ERR: 10;
      /**
       * Error code indicating an invalid state.
       */
      INVALID_STATE_ERR: 11;
      /**
       * The SYNTAX_ERR constant represents an error code indicating a syntax error.
       */
      SYNTAX_ERR: 12;
      /**
       * Error code indicating an invalid modification error.
       */
      INVALID_MODIFICATION_ERR: 13;
      /**
       * Error code indicating a namespace error.
       */
      NAMESPACE_ERR: 14;
      /**
       * Error code indicating an invalid access error.
       */
      INVALID_ACCESS_ERR: 15;
      /**
       * The validation error code.
       */
      VALIDATION_ERR: 16;
      /**
       * Error code indicating a type mismatch.
       */
      TYPE_MISMATCH_ERR: 17;
      /**
       * Error code indicating a security-related error.
       */
      SECURITY_ERR: 18;
      /**
       * Error code indicating a network error.
       */
      NETWORK_ERR: 19;
      /**
       * The ABORT_ERR constant represents an error code indicating that the operation was aborted.
       */
      ABORT_ERR: 20;
      /**
       * Error code indicating a URL mismatch.
       */
      URL_MISMATCH_ERR: 21;
      /**
       * Error code indicating that the operation failed because the quota was exceeded.
       */
      QUOTA_EXCEEDED_ERR: 22;
      /**
       * The error code for a timeout error.
       */
      TIMEOUT_ERR: 23;
      /**
       * Error code indicating an invalid node type.
       */
      INVALID_NODE_TYPE_ERR: 24;
      /**
       * Error code indicating that the data being cloned has an unsupported type.
       */
      DATA_CLONE_ERR: 25;
      /**
       * The error code associated with the DOM exception.
       */
      code: number;
      constructor(message: string, name: DOMExceptionName);
  }
  export default DOMExceptionImpl;

}
declare module '@yodaos-jsar/dom/src/living/domexception.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/domparsing/InnerHTML' {
  export default class InnerHTMLImpl implements InnerHTML {
      get innerHTML(): string;
      set innerHTML(markup: string);
  }

}
declare module '@yodaos-jsar/dom/src/living/domparsing/serialization' {
  import { NodeImpl } from "@yodaos-jsar/dom/src/living/nodes/Node";
  type SerializationOptions = {
      outer: boolean;
      requireWellFormed: boolean;
      globalObject: any;
  };
  export function fragmentSerialization(node: NodeImpl, options: SerializationOptions): any;
  export {};

}
declare module '@yodaos-jsar/dom/src/living/events/CloseEvent' {
  export class CloseEventImpl extends Event implements CloseEvent {
      code: number;
      reason: string;
      wasClean: boolean;
      constructor(type: string, options?: CloseEventInit);
  }

}
declare module '@yodaos-jsar/dom/src/living/events/CustomEvent' {
  export class CustomEventImpl extends Event implements CustomEvent {
      detail: any;
      constructor(type: string, options?: CustomEventInit);
      initCustomEvent(type: string, bubbles?: boolean, cancelable?: boolean, detail?: any): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/ErrorEvent' {
  export default class ErrorEventImpl extends Event implements ErrorEvent {
      message: string;
      filename: string;
      lineno: number;
      colno: number;
      error: Error;
      constructor(type: string, eventInitDict?: ErrorEventInit);
  }

}
declare module '@yodaos-jsar/dom/src/living/events/FocusEvent' {
  export default class FocusEventImpl extends Event implements FocusEvent {
      relatedTarget: EventTarget;
      detail: number;
      view: Window;
      which: number;
      inputIndex: number;
      constructor(type: string, eventInitDict?: FocusEventInit);
      initUIEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, viewArg?: Window, detailArg?: number): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/HandTrackingEvent' {
  import { HandGesture, HandOrientation, HandtrackingInputDetail } from '@yodaos-jsar/dom/src/input-event';
  enum HandType {
      Left = 0,
      Right = 1
  }
  type InputData = {
      'Type': HandType;
      'Joints': Array<{
          position: DOMPointInit;
          rotation: DOMPointInit;
      }>;
      'ThisPose': any;
      'Gesture': HandGesture;
      'Orientation': HandOrientation;
  };
  export default class HandTrackingEvent extends Event {
      inputData: InputData;
      constructor(inputDetail: HandtrackingInputDetail);
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/events/HashChangeEvent' {
  export default class HashChangeEventImpl extends Event implements HashChangeEvent {
      oldURL: string;
      newURL: string;
      constructor(type: string, eventInitDict?: HashChangeEventInit);
  }

}
declare module '@yodaos-jsar/dom/src/living/events/KeyboardEvent' {
  import { UIEventImpl } from '@yodaos-jsar/dom/src/living/events/UIEvent';
  export default class KeyboardEventImpl extends UIEventImpl implements KeyboardEvent {
      key: string;
      code: string;
      location: number;
      ctrlKey: boolean;
      shiftKey: boolean;
      altKey: boolean;
      metaKey: boolean;
      repeat: boolean;
      isComposing: boolean;
      charCode: number;
      keyCode: number;
      constructor(type: string, eventInitDict?: KeyboardEventInit);
      DOM_KEY_LOCATION_STANDARD: 0;
      DOM_KEY_LOCATION_LEFT: 1;
      DOM_KEY_LOCATION_RIGHT: 2;
      DOM_KEY_LOCATION_NUMPAD: 3;
      getModifierState(keyArg: string): boolean;
      initKeyboardEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, viewArg?: Window, keyArg?: string, locationArg?: number, ctrlKey?: boolean, altKey?: boolean, shiftKey?: boolean, metaKey?: boolean): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/MessageEvent' {
  export default class MessageEventImpl extends Event implements MessageEvent {
      data: any;
      lastEventId: string;
      origin: string;
      ports: readonly MessagePort[];
      source: MessageEventSource;
      constructor(type: string, eventInitDict?: MessageEventInit);
      initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource, ports?: MessagePort[]): void;
      initMessageEvent(type: string, bubbles?: boolean, cancelable?: boolean, data?: any, origin?: string, lastEventId?: string, source?: MessageEventSource, ports?: Iterable<MessagePort>): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/MouseEvent' {
  import { UIEventImpl } from '@yodaos-jsar/dom/src/living/events/UIEvent';
  export class MouseEventImpl extends UIEventImpl implements MouseEvent {
      altKey: boolean;
      button: number;
      buttons: number;
      clientX: number;
      clientY: number;
      ctrlKey: boolean;
      metaKey: boolean;
      movementX: number;
      movementY: number;
      offsetX: number;
      offsetY: number;
      pageX: number;
      pageY: number;
      relatedTarget: EventTarget;
      screenX: number;
      screenY: number;
      shiftKey: boolean;
      constructor(typeArg: string, eventInitDict?: MouseEventInit);
      get x(): number;
      get y(): number;
      get mozMovementX(): number;
      get mozMovementY(): number;
      get webkitMovementX(): number;
      get webkitMovementY(): number;
      get msMovementX(): number;
      get msMovementY(): number;
      getModifierState(_keyArg: string): boolean;
      initMouseEvent(_typeArg: string, _canBubbleArg: boolean, _cancelableArg: boolean, _viewArg: Window, _detailArg: number, _screenXArg: number, _screenYArg: number, _clientXArg: number, _clientYArg: number, _ctrlKeyArg: boolean, _altKeyArg: boolean, _shiftKeyArg: boolean, _metaKeyArg: boolean, _buttonArg: number, _relatedTargetArg: EventTarget): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/PopStateEvent' {
  export default class PopStateEventImpl extends Event implements PopStateEvent {
      state: any;
      constructor(type: string, eventInitDict?: PopStateEventInit);
      initPopStateEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, stateArg?: any): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/ProgressEvent' {
  export default class ProgressEventImpl extends Event implements ProgressEvent {
      lengthComputable: boolean;
      loaded: number;
      total: number;
      constructor(type: string, eventInitDict?: ProgressEventInit);
      initProgressEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, lengthComputableArg?: boolean, loadedArg?: number, totalArg?: number): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/TouchEvent' {
  import { UIEventImpl } from '@yodaos-jsar/dom/src/living/events/UIEvent';
  export default class TouchEventImpl extends UIEventImpl implements TouchEvent {
      touches: TouchList;
      targetTouches: TouchList;
      changedTouches: TouchList;
      altKey: boolean;
      metaKey: boolean;
      ctrlKey: boolean;
      shiftKey: boolean;
      constructor(type: string, eventInitDict?: TouchEventInit);
      initTouchEvent(typeArg: string, bubblesArg?: boolean, cancelableArg?: boolean, viewArg?: Window, detailArg?: number, ctrlKeyArg?: boolean, altKeyArg?: boolean, shiftKeyArg?: boolean, metaKeyArg?: boolean, touchesArg?: TouchList, targetTouchesArg?: TouchList, changedTouchesArg?: TouchList): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/events/UIEvent' {
  export class UIEventImpl extends Event implements UIEvent {
      detail: number;
      view: Window;
      which: number;
      inputIndex: number;
      shdaowRoot: ShadowRoot | null;
      constructor(typeArg: string, eventInitDict?: UIEventInit & {
          shadowRoot?: ShadowRoot;
      });
      initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window, _detailArg?: number): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMPoint' {
  export const GET_UPDATER_SYMBOL: unique symbol;
  export default class DOMPointImpl implements DOMPoint {
      private _w;
      private _x;
      private _y;
      private _z;
      /**
       * @internal
       */
      [GET_UPDATER_SYMBOL]: (name: string, value: number) => void;
      static fromPoint(sourcePoint: DOMPointInit): DOMPoint;
      constructor(x?: number, y?: number, z?: number, w?: number);
      get x(): number;
      set x(value: number);
      get y(): number;
      set y(value: number);
      get z(): number;
      set z(value: number);
      get w(): number;
      set w(value: number);
      matrixTransform(matrix?: DOMMatrixInit): DOMPoint;
      toJSON(): {
          x: number;
          y: number;
          z: number;
          w: number;
      };
  }

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMPoint.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMPointReadOnly' {
  export default class DOMPointReadOnlyImpl implements DOMPointReadOnly {
      private _w;
      private _x;
      private _y;
      private _z;
      get x(): number;
      get y(): number;
      get z(): number;
      get w(): number;
      static fromPoint(sourcePoint: DOMPointInit): DOMPointReadOnly;
      constructor(x?: number, y?: number, z?: number, w?: number);
      matrixTransform(matrix?: DOMMatrixInit): DOMPoint;
      toJSON(): {
          x: number;
          y: number;
          z: number;
          w: number;
      };
  }

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMPointReadOnly.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMRect' {
  import DOMRectReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRectReadOnly';
  export default class DOMRectImpl extends DOMRectReadOnlyImpl implements DOMRect {
      static fromRect(other?: DOMRectInit): DOMRect;
      get x(): number;
      set x(value: number);
      get y(): number;
      set y(value: number);
      get width(): number;
      set width(value: number);
      get height(): number;
      set height(value: number);
  }

}
declare module '@yodaos-jsar/dom/src/living/geometry/DOMRectReadOnly' {
  export default class DOMRectReadOnlyImpl implements DOMRectReadOnly {
      protected _x: number;
      protected _y: number;
      protected _width: number;
      protected _height: number;
      static fromRect(other?: DOMRectInit): DOMRectReadOnly;
      constructor(x?: number, y?: number, width?: number, height?: number);
      get x(): number;
      get y(): number;
      get width(): number;
      get height(): number;
      get top(): number;
      get right(): number;
      get bottom(): number;
      get left(): number;
      get [Symbol.toStringTag](): string;
      toJSON(): {
          x: number;
          y: number;
          width: number;
          height: number;
          top: number;
          right: number;
          bottom: number;
          left: number;
      };
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/InteractiveDynamicTexture' {
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  import { ShadowRootImpl } from '@yodaos-jsar/dom/src/living/nodes/ShadowRoot';
  import { Control2D } from '@yodaos-jsar/dom/src/living/helpers/gui2d/control';
  /**
   * The `InteractiveDynamicTexture` is copied from BabylonJS `InteractiveDynamicTexture` and modified to support the texture to interact in JSAR runtime.
   */
  export class InteractiveDynamicTexture extends BABYLON.DynamicTexture {
      /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */
      static AllowGPUOptimizations: boolean;
      /** Snippet ID if the content was created from the snippet server */
      snippetId: string;
      /** Observable that fires when the GUI is ready */
      onGuiReadyObservable: BABYLON.Observable<InteractiveDynamicTexture>;
      /** if the texture is started */
      private _started;
      /** if the texture is dirty */
      private _isDirty;
      /** if the texture is rendering */
      private _isRendering;
      private _ownerNativeDocument;
      private _pointerObserver;
      private _renderObserver;
      /**
       * This is updated at picking event and used in other hand events.
       */
      private _lastPositionInPicking;
      /** @internal */
      /** @internal */
      _rootLayoutContainer: Control2D;
      /** @internal */
      _shadowRoot: ShadowRootImpl;
      /** @internal */
      _lastPickedControl: HTMLElementImpl;
      /** @internal */
      /** @internal */
      private _idealWidth;
      private _idealHeight;
      private _renderAtIdealSize;
      private _renderScale;
      /**
       * Define type to string to ensure compatibility across browsers
       * Safari doesn't support DataTransfer constructor
       */
      private _clipboardData;
      /**
       * Observable event triggered each time an clipboard event is received from the rendering canvas
       */
      onClipboardObservable: BABYLON.Observable<BABYLON.ClipboardInfo>;
      /**
       * Observable event triggered each time a pointer down is intercepted by a control
       */
      onControlPickedObservable: BABYLON.Observable<HTMLElement>;
      /**
       * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture
       */
      applyYInversionOnUpdate: boolean;
      /**
       * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).
       * Useful when you want more antialiasing
       */
      get renderScale(): number;
      set renderScale(value: number);
      /**
       * Returns an array containing the root container.
       * This is mostly used to let the Inspector introspects the ADT
       * @returns an array containing the rootContainer
       */
      getChildren(): any[];
      /**
       * Gets or sets the current focused control
       */
      /**
       * Gets or set information about clipboardData
       */
      get clipboardData(): string;
      set clipboardData(value: string);
      /**
       * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.
       * Options from values are PointerEventTypes
       * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP
       */
      skipBlockEvents: number;
      /**
       * If set to true, every scene render will trigger a pointer event for the GUI
       * if it is linked to a mesh or has controls linked to a mesh. This will allow
       * you to catch the pointer moving around the GUI due to camera or mesh movements,
       * but it has a performance cost.
       */
      checkPointerEveryFrame: boolean;
      /**
       * Creates a new InteractiveDynamicTexture.
       */
      constructor(name: string, width: number, height: number, shadowRoot: ShadowRootImpl, scene?: BABYLON.Nullable<BABYLON.Scene>, generateMipMaps?: boolean, samplingMode?: number, invertY?: boolean);
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "InteractiveDynamicTexture"
       */
      getClassName(): string;
      /**
       * Release all resources
       */
      dispose(): void;
      private _onResize;
      start(): void;
      pause(): void;
      markAsDirty(value?: boolean): void;
      renderToTexture(): void;
      private _iterateLayoutResult;
      /**
       * This iterate the controls from the given node, and it receives a callback that returns a boolean value. If the boolean is
       * false it stops the iteration of the remaining controls.
       */
      private _iterateControls;
      /**
       * @internal
       * @param x
       * @param y
       * @param type
       */
      _processPicking(x: number, y: number, type: number): void;
      /**
       * @internal
       */
      _processPointerEvent(type: number): boolean;
      /**
       * @internal
       */
      private _onClipboardCopy;
      /**
       * @internal
       */
      private _onClipboardCut;
      /**
       * @internal
       */
      private _onClipboardPaste;
      /**
       * Register the clipboard Events onto the canvas
       */
      registerClipboardEvents(): void;
      /**
       * Unregister the clipboard Events from the canvas
       */
      unRegisterClipboardEvents(): void;
      /**
       * Serializes the entire GUI system
       * @returns an object with the JSON serialized data
       */
      serializeContent(): any;
      /**
       * Clones the ADT
       * @param newName defines the name of the new ADT
       * @returns the clone of the ADT
       */
      clone(newName?: string): InteractiveDynamicTexture;
      /**
       * Creates a new InteractiveDynamicTexture in projected mode (ie. attached to a mesh)
       * @param mesh defines the mesh which will receive the texture
       * @param width defines the texture width (1024 by default)
       * @param height defines the texture height (1024 by default)
       * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)
       * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)
       * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)
       * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh
       * @returns a new InteractiveDynamicTexture
       */
      static CreateForMesh(shadowRoot: ShadowRootImpl, mesh: BABYLON.AbstractMesh, width?: number, height?: number, supportPointerMove?: boolean, onlyAlphaTesting?: boolean, enableLighting?: boolean, invertY?: boolean): InteractiveDynamicTexture;
      private static _CreateMaterial;
      /**
       * Scales the texture
       * @param ratio the scale factor to apply to both width and height
       */
      scale(ratio: number): void;
      /**
       * Resizes the texture
       * @param width the new width
       * @param height the new height
       */
      scaleTo(width: number, height: number): void;
      /**
       * Returns true if all the GUI components are ready to render
       */
      guiIsReady(): boolean;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/mtlFileLoader';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objLoadingOptions';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/solidParser';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objFileLoader';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/mtlFileLoader' {
  type Nullable<T> = BABYLON.Nullable<T>;
  type Scene = BABYLON.Scene;
  type AssetContainer = BABYLON.AssetContainer;
  /**
   * Class reading and parsing the MTL file bundled with the obj file.
   */
  export class MTLFileLoader {
      /**
       * Invert Y-Axis of referenced textures on load
       */
      static INVERT_TEXTURE_Y: boolean;
      /**
       * All material loaded from the mtl will be set here
       */
      materials: BABYLON.StandardMaterial[];
      /**
       * This function will read the mtl file and create each material described inside
       * This function could be improve by adding :
       * -some component missing (Ni, Tf...)
       * -including the specific options available
       *
       * @param scene defines the scene the material will be created in
       * @param data defines the mtl data to parse
       * @param rootUrl defines the rooturl to use in order to load relative dependencies
       * @param assetContainer defines the asset container to store the material in (can be null)
       */
      parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void;
      /**
       * Gets the texture for the material.
       *
       * If the material is imported from input file,
       * We sanitize the url to ensure it takes the texture from aside the material.
       *
       * @param rootUrl The root url to load from
       * @param value The value stored in the mtl
       * @param scene
       * @returns The Texture
       */
      private static _GetTexture;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objFileLoader' {
  import type { OBJLoadingOptions } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objLoadingOptions';
  type Scene = BABYLON.Scene;
  type AssetContainer = BABYLON.AssetContainer;
  /**
   * OBJ file type loader.
   * This is a babylon scene loader plugin.
   */
  export class OBJFileLoader implements BABYLON.ISceneLoaderPluginAsync, BABYLON.ISceneLoaderPluginFactory {
      /**
       * Defines if UVs are optimized by default during load.
       */
      static OPTIMIZE_WITH_UV: boolean;
      /**
       * Invert model on y-axis (does a model scaling inversion)
       */
      static INVERT_Y: boolean;
      /**
       * Invert Y-Axis of referenced textures on load
       */
      static get INVERT_TEXTURE_Y(): boolean;
      static set INVERT_TEXTURE_Y(value: boolean);
      /**
       * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.
       */
      static IMPORT_VERTEX_COLORS: boolean;
      /**
       * Compute the normals for the model, even if normals are present in the file.
       */
      static COMPUTE_NORMALS: boolean;
      /**
       * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.
       * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.
       */
      static OPTIMIZE_NORMALS: boolean;
      /**
       * Defines custom scaling of UV coordinates of loaded meshes.
       */
      static UV_SCALING: BABYLON.Vector2;
      /**
       * Skip loading the materials even if defined in the OBJ file (materials are ignored).
       */
      static SKIP_MATERIALS: boolean;
      /**
       * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.
       *
       * Defaults to true for backwards compatibility.
       */
      static MATERIAL_LOADING_FAILS_SILENTLY: boolean;
      /**
       * Defines the name of the plugin.
       */
      name: string;
      /**
       * Defines the extension the plugin is able to load.
       */
      extensions: string;
      private _assetContainer;
      private _loadingOptions;
      /**
       * Creates loader for .OBJ files
       *
       * @param loadingOptions options for loading and parsing OBJ/MTL files.
       */
      constructor(loadingOptions?: OBJLoadingOptions);
      private static get _DefaultLoadingOptions();
      /**
       * Calls synchronously the MTL file attached to this obj.
       * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.
       * Without this function materials are not displayed in the first frame (but displayed after).
       * In consequence it is impossible to get material information in your HTML file
       *
       * @param url The URL of the MTL file
       * @param rootUrl defines where to load data from
       * @param onSuccess Callback function to be called when the MTL file is loaded
       * @param onFailure
       */
      private _loadMTL;
      /**
       * Instantiates a OBJ file loader plugin.
       * @returns the created plugin
       */
      createPlugin(): BABYLON.ISceneLoaderPluginAsync | BABYLON.ISceneLoaderPlugin;
      /**
       * If the data string can be loaded directly.
       * @returns if the data can be loaded directly
       */
      canDirectLoad(): boolean;
      /**
       * Imports one or more meshes from the loaded OBJ data and adds them to the scene
       * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
       * @param scene the scene the meshes should be added to
       * @param data the OBJ data to load
       * @param rootUrl root url to load from
       * @returns a promise containing the loaded meshes, particles, skeletons and animations
       */
      importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<BABYLON.ISceneLoaderAsyncResult>;
      /**
       * Imports all objects from the loaded OBJ data and adds them to the scene
       * @param scene the scene the objects should be added to
       * @param data the OBJ data to load
       * @param rootUrl root url to load from
       * @returns a promise which completes when objects have been loaded to the scene
       */
      loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void>;
      /**
       * Load into an asset container.
       * @param scene The scene to load into
       * @param data The data to import
       * @param rootUrl The root url for scene and resources
       * @returns The loaded asset container
       */
      loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer>;
      /**
       * Read the OBJ file and create an Array of meshes.
       * Each mesh contains all information given by the OBJ and the MTL file.
       * i.e. vertices positions and indices, optional normals values, optional UV values, optional material
       * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file
       * @param scene defines the scene where are displayed the data
       * @param data defines the content of the obj file
       * @param rootUrl defines the path to the folder
       * @returns the list of loaded meshes
       */
      private _parseSolid;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objLoadingOptions' {
  type Vector2 = BABYLON.Vector2;
  /**
   * Options for loading OBJ/MTL files
   */
  export type OBJLoadingOptions = {
      /**
       * Defines if UVs are optimized by default during load.
       */
      optimizeWithUV: boolean;
      /**
       * Defines custom scaling of UV coordinates of loaded meshes.
       */
      UVScaling: Vector2;
      /**
       * Invert model on y-axis (does a model scaling inversion)
       */
      invertY: boolean;
      /**
       * Invert Y-Axis of referenced textures on load
       */
      invertTextureY: boolean;
      /**
       * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.
       */
      importVertexColors: boolean;
      /**
       * Compute the normals for the model, even if normals are present in the file.
       */
      computeNormals: boolean;
      /**
       * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.
       * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.
       */
      optimizeNormals: boolean;
      /**
       * Skip loading the materials even if defined in the OBJ file (materials are ignored).
       */
      skipMaterials: boolean;
      /**
       * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.
       */
      materialLoadingFailsSilently: boolean;
  };
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/solidParser' {
  import type { OBJLoadingOptions } from "@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/objLoadingOptions";
  type Nullable<T> = BABYLON.Nullable<T>;
  type AssetContainer = BABYLON.AssetContainer;
  type Scene = BABYLON.Scene;
  /**
   * Class used to load mesh data from OBJ content
   */
  export class SolidParser {
      /** Object descriptor */
      static ObjectDescriptor: RegExp;
      /** Group descriptor */
      static GroupDescriptor: RegExp;
      /** Material lib descriptor */
      static MtlLibGroupDescriptor: RegExp;
      /** Use a material descriptor */
      static UseMtlDescriptor: RegExp;
      /** Smooth descriptor */
      static SmoothDescriptor: RegExp;
      /** Pattern used to detect a vertex */
      static VertexPattern: RegExp;
      /** Pattern used to detect a normal */
      static NormalPattern: RegExp;
      /** Pattern used to detect a UV set */
      static UVPattern: RegExp;
      /** Pattern used to detect a first kind of face (f vertex vertex vertex) */
      static FacePattern1: RegExp;
      /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */
      static FacePattern2: RegExp;
      /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */
      static FacePattern3: RegExp;
      /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/
      static FacePattern4: RegExp;
      /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */
      static FacePattern5: RegExp;
      /** Pattern used to detect a line(l vertex vertex) */
      static LinePattern1: RegExp;
      /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */
      static LinePattern2: RegExp;
      /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */
      static LinePattern3: RegExp;
      private _loadingOptions;
      private _positions;
      private _normals;
      private _uvs;
      private _colors;
      private _meshesFromObj;
      private _handledMesh;
      private _indicesForBabylon;
      private _wrappedPositionForBabylon;
      private _wrappedUvsForBabylon;
      private _wrappedColorsForBabylon;
      private _wrappedNormalsForBabylon;
      private _tuplePosNorm;
      private _curPositionInIndices;
      private _hasMeshes;
      private _unwrappedPositionsForBabylon;
      private _unwrappedColorsForBabylon;
      private _unwrappedNormalsForBabylon;
      private _unwrappedUVForBabylon;
      private _triangles;
      private _materialNameFromObj;
      private _objMeshName;
      private _increment;
      private _isFirstMaterial;
      private _grayColor;
      private _materialToUse;
      private _babylonMeshesArray;
      /**
       * Creates a new SolidParser
       * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)
       * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)
       * @param loadingOptions defines the loading options to use
       */
      constructor(materialToUse: string[], babylonMeshesArray: Array<BABYLON.Mesh>, loadingOptions: OBJLoadingOptions);
      /**
       * Search for obj in the given array.
       * This function is called to check if a couple of data already exists in an array.
       *
       * If found, returns the index of the founded tuple index. Returns -1 if not found
       * @param arr Array<{ normals: Array<number>, idx: Array<number> }>
       * @param obj Array<number>
       * @returns {boolean}
       */
      private _isInArray;
      private _isInArrayUV;
      /**
       * This function set the data for each triangle.
       * Data are position, normals and uvs
       * If a tuple of (position, normal) is not set, add the data into the corresponding array
       * If the tuple already exist, add only their indice
       *
       * @param indicePositionFromObj Integer The index in positions array
       * @param indiceUvsFromObj Integer The index in uvs array
       * @param indiceNormalFromObj Integer The index in normals array
       * @param positionVectorFromOBJ Vector3 The value of position at index objIndice
       * @param textureVectorFromOBJ Vector3 The value of uvs
       * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale
       * @param positionColorsFromOBJ
       */
      private _setData;
      /**
       * Transform Vector() and BABYLON.Color() objects into numbers in an array
       */
      private _unwrapData;
      /**
       * Create triangles from polygons
       * It is important to notice that a triangle is a polygon
       * We get 5 patterns of face defined in OBJ File :
       * facePattern1 = ["1","2","3","4","5","6"]
       * facePattern2 = ["1/1","2/2","3/3","4/4","5/5","6/6"]
       * facePattern3 = ["1/1/1","2/2/2","3/3/3","4/4/4","5/5/5","6/6/6"]
       * facePattern4 = ["1//1","2//2","3//3","4//4","5//5","6//6"]
       * facePattern5 = ["-1/-1/-1","-2/-2/-2","-3/-3/-3","-4/-4/-4","-5/-5/-5","-6/-6/-6"]
       * Each pattern is divided by the same method
       * @param faces Array[String] The indices of elements
       * @param v Integer The variable to increment
       */
      private _getTriangles;
      /**
       * Create triangles and push the data for each polygon for the pattern 1
       * In this pattern we get vertice positions
       * @param face
       * @param v
       */
      private _setDataForCurrentFaceWithPattern1;
      /**
       * Create triangles and push the data for each polygon for the pattern 2
       * In this pattern we get vertice positions and uvs
       * @param face
       * @param v
       */
      private _setDataForCurrentFaceWithPattern2;
      /**
       * Create triangles and push the data for each polygon for the pattern 3
       * In this pattern we get vertice positions, uvs and normals
       * @param face
       * @param v
       */
      private _setDataForCurrentFaceWithPattern3;
      /**
       * Create triangles and push the data for each polygon for the pattern 4
       * In this pattern we get vertice positions and normals
       * @param face
       * @param v
       */
      private _setDataForCurrentFaceWithPattern4;
      private _setDataForCurrentFaceWithPattern5;
      private _addPreviousObjMesh;
      private _optimizeNormals;
      /**
       * Function used to parse an OBJ string
       * @param meshesNames defines the list of meshes to load (all if not defined)
       * @param data defines the OBJ string
       * @param scene defines the hosting scene
       * @param assetContainer defines the asset container to load data in
       * @param onFileToLoadFound defines a callback that will be called if a MTL file is found
       */
      parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/STL/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/STL/stlFileLoader';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/STL/stlFileLoader' {
  type Nullable<T> = BABYLON.Nullable<T>;
  type Scene = BABYLON.Scene;
  type AbstractMesh = BABYLON.AbstractMesh;
  /**
   * STL file type loader.
   * This is a babylon scene loader plugin.
   */
  export class STLFileLoader implements BABYLON.ISceneLoaderPlugin {
      /** @internal */
      solidPattern: RegExp;
      /** @internal */
      facetsPattern: RegExp;
      /** @internal */
      normalPattern: RegExp;
      /** @internal */
      vertexPattern: RegExp;
      /**
       * Defines the name of the plugin.
       */
      name: string;
      /**
       * Defines the extensions the stl loader is able to load.
       * force data to come in as an ArrayBuffer
       * we'll convert to string if it looks like it's an ASCII .stl
       */
      extensions: BABYLON.ISceneLoaderPluginExtensions;
      /**
       * Defines if Y and Z axes are swapped or not when loading an STL file.
       * The default is false to maintain backward compatibility. When set to
       * true, coordinates from the STL file are used without change.
       */
      static DO_NOT_ALTER_FILE_COORDINATES: boolean;
      /**
       * Import meshes into a scene.
       * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
       * @param scene The scene to import into
       * @param data The data to import
       * @param rootUrl The root url for scene and resources
       * @param meshes The meshes array to import into
       * @returns True if successful or false otherwise
       */
      importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>): boolean;
      /**
       * Load into a scene.
       * @param scene The scene to load into
       * @param data The data to import
       * @param rootUrl The root url for scene and resources
       * @returns true if successful or false otherwise
       */
      load(scene: Scene, data: any, rootUrl: string): boolean;
      /**
       * Load into an asset container.
       * @param scene The scene to load into
       * @param data The data to import
       * @param rootUrl The root url for scene and resources
       * @returns The loaded asset container
       */
      loadAssetContainer(scene: Scene, data: string, rootUrl: string): BABYLON.AssetContainer;
      private _isBinary;
      private _parseBinary;
      private _parseASCII;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFBinaryExtension' {
  import { GLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoader';
  import type { IGLTFLoaderData } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  import type { IGLTFRuntime } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  /**
   * @internal
   * @deprecated
   */
  export class GLTFBinaryExtension extends GLTFLoaderExtension {
      private _bin;
      constructor();
      loadRuntimeAsync(scene: BABYLON.Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean;
      loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean;
      loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean;
      loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoader' {
  import type { IGLTFRuntime } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Scene = BABYLON.Scene;
  type Texture = BABYLON.Texture;
  const Texture: typeof BABYLON.Texture;
  import type { IGLTFLoader, IGLTFLoaderData } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  /**
   * Implementation of the base glTF spec
   * @internal
   */
  export class GLTFLoaderBase {
      static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime;
      static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void;
      static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void;
      static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void;
      static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void;
      static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: BABYLON.Material) => void, onError: (message: string) => void): void;
  }
  /**
   * glTF V1 Loader
   * @internal
   * @deprecated
   */
  export class GLTFLoader implements IGLTFLoader {
      static Extensions: {
          [name: string]: GLTFLoaderExtension;
      };
      static RegisterExtension(extension: GLTFLoaderExtension): void;
      dispose(): void;
      private _importMeshAsync;
      /**
       * Imports one or more meshes from a loaded gltf file and adds them to the scene
       * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
       * @param scene the scene the meshes should be added to
       * @param assetContainer defines the asset container to use (can be null)
       * @param data gltf data containing information of the meshes in a loaded file
       * @param rootUrl root url to load from
       * @param onProgress event that fires when loading progress has occured
       * @returns a promise containg the loaded meshes, particles, skeletons and animations
       */
      importMeshAsync(meshesNames: any, scene: Scene, assetContainer: Nullable<BABYLON.AssetContainer>, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void): Promise<BABYLON.ISceneLoaderAsyncResult>;
      private _loadAsync;
      /**
       * Imports all objects from a loaded gltf file and adds them to the scene
       * @param scene the scene the objects should be added to
       * @param data gltf data containing information of the meshes in a loaded file
       * @param rootUrl root url to load from
       * @param onProgress event that fires when loading progress has occured
       * @returns a promise which completes when objects have been loaded to the scene
       */
      loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void): Promise<void>;
      private _loadShadersAsync;
      private _loadBuffersAsync;
      private _createNodes;
  }
  /** @internal */
  export abstract class GLTFLoaderExtension {
      private _name;
      constructor(name: string);
      get name(): string;
      /**
       * Defines an override for loading the runtime
       * Return true to stop further extensions from loading the runtime
       * @param scene
       * @param data
       * @param rootUrl
       * @param onSuccess
       * @param onError
       */
      loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean;
      /**
       * Defines an onverride for creating gltf runtime
       * Return true to stop further extensions from creating the runtime
       * @param gltfRuntime
       * @param onSuccess
       * @param onError
       */
      loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean;
      /**
       * Defines an override for loading buffers
       * Return true to stop further extensions from loading this buffer
       * @param gltfRuntime
       * @param id
       * @param onSuccess
       * @param onError
       * @param onProgress
       */
      loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): boolean;
      /**
       * Defines an override for loading texture buffers
       * Return true to stop further extensions from loading this texture data
       * @param gltfRuntime
       * @param id
       * @param onSuccess
       * @param onError
       */
      loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean;
      /**
       * Defines an override for creating textures
       * Return true to stop further extensions from loading this texture
       * @param gltfRuntime
       * @param id
       * @param buffer
       * @param onSuccess
       * @param onError
       */
      createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean;
      /**
       * Defines an override for loading shader strings
       * Return true to stop further extensions from loading this shader data
       * @param gltfRuntime
       * @param id
       * @param onSuccess
       * @param onError
       */
      loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean;
      /**
       * Defines an override for loading materials
       * Return true to stop further extensions from loading this material
       * @param gltfRuntime
       * @param id
       * @param onSuccess
       * @param onError
       */
      loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: BABYLON.Material) => void, onError: (message: string) => void): boolean;
      static LoadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): void;
      static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void;
      static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (bufferView: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void;
      static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void;
      static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void;
      static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: BABYLON.Material) => void, onError: (message: string) => void): void;
      private static _LoadTextureBufferAsync;
      private static _CreateTextureAsync;
      private static _ApplyExtensions;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces' {
  /**
   * Enums
   * @internal
   */
  export enum EComponentType {
      BYTE = 5120,
      UNSIGNED_BYTE = 5121,
      SHORT = 5122,
      UNSIGNED_SHORT = 5123,
      FLOAT = 5126
  }
  /** @internal */
  export enum EShaderType {
      FRAGMENT = 35632,
      VERTEX = 35633
  }
  /** @internal */
  export enum EParameterType {
      BYTE = 5120,
      UNSIGNED_BYTE = 5121,
      SHORT = 5122,
      UNSIGNED_SHORT = 5123,
      INT = 5124,
      UNSIGNED_INT = 5125,
      FLOAT = 5126,
      FLOAT_VEC2 = 35664,
      FLOAT_VEC3 = 35665,
      FLOAT_VEC4 = 35666,
      INT_VEC2 = 35667,
      INT_VEC3 = 35668,
      INT_VEC4 = 35669,
      BOOL = 35670,
      BOOL_VEC2 = 35671,
      BOOL_VEC3 = 35672,
      BOOL_VEC4 = 35673,
      FLOAT_MAT2 = 35674,
      FLOAT_MAT3 = 35675,
      FLOAT_MAT4 = 35676,
      SAMPLER_2D = 35678
  }
  /** @internal */
  export enum ETextureWrapMode {
      CLAMP_TO_EDGE = 33071,
      MIRRORED_REPEAT = 33648,
      REPEAT = 10497
  }
  /** @internal */
  export enum ETextureFilterType {
      NEAREST = 9728,
      LINEAR = 9728,
      NEAREST_MIPMAP_NEAREST = 9984,
      LINEAR_MIPMAP_NEAREST = 9985,
      NEAREST_MIPMAP_LINEAR = 9986,
      LINEAR_MIPMAP_LINEAR = 9987
  }
  /** @internal */
  export enum ETextureFormat {
      ALPHA = 6406,
      RGB = 6407,
      RGBA = 6408,
      LUMINANCE = 6409,
      LUMINANCE_ALPHA = 6410
  }
  /** @internal */
  export enum ECullingType {
      FRONT = 1028,
      BACK = 1029,
      FRONT_AND_BACK = 1032
  }
  /** @internal */
  export enum EBlendingFunction {
      ZERO = 0,
      ONE = 1,
      SRC_COLOR = 768,
      ONE_MINUS_SRC_COLOR = 769,
      DST_COLOR = 774,
      ONE_MINUS_DST_COLOR = 775,
      SRC_ALPHA = 770,
      ONE_MINUS_SRC_ALPHA = 771,
      DST_ALPHA = 772,
      ONE_MINUS_DST_ALPHA = 773,
      CONSTANT_COLOR = 32769,
      ONE_MINUS_CONSTANT_COLOR = 32770,
      CONSTANT_ALPHA = 32771,
      ONE_MINUS_CONSTANT_ALPHA = 32772,
      SRC_ALPHA_SATURATE = 776
  }
  /** @internal */
  export interface IGLTFProperty {
      extensions?: {
          [key: string]: any;
      };
      extras?: Object;
  }
  /** @internal */
  export interface IGLTFChildRootProperty extends IGLTFProperty {
      name?: string;
  }
  /** @internal */
  export interface IGLTFAccessor extends IGLTFChildRootProperty {
      bufferView: string;
      byteOffset: number;
      byteStride: number;
      count: number;
      type: string;
      componentType: EComponentType;
      max?: number[];
      min?: number[];
      name?: string;
  }
  /** @internal */
  export interface IGLTFBufferView extends IGLTFChildRootProperty {
      buffer: string;
      byteOffset: number;
      byteLength: number;
      byteStride: number;
      target?: number;
  }
  /** @internal */
  export interface IGLTFBuffer extends IGLTFChildRootProperty {
      uri: string;
      byteLength?: number;
      type?: string;
  }
  /** @internal */
  export interface IGLTFShader extends IGLTFChildRootProperty {
      uri: string;
      type: EShaderType;
  }
  /** @internal */
  export interface IGLTFProgram extends IGLTFChildRootProperty {
      attributes: string[];
      fragmentShader: string;
      vertexShader: string;
  }
  /** @internal */
  export interface IGLTFTechniqueParameter {
      type: number;
      count?: number;
      semantic?: string;
      node?: string;
      value?: number | boolean | string | Array<any>;
      source?: string;
      babylonValue?: any;
  }
  /** @internal */
  export interface IGLTFTechniqueCommonProfile {
      lightingModel: string;
      texcoordBindings: Object;
      parameters?: Array<any>;
  }
  /** @internal */
  export interface IGLTFTechniqueStatesFunctions {
      blendColor?: number[];
      blendEquationSeparate?: number[];
      blendFuncSeparate?: number[];
      colorMask: boolean[];
      cullFace: number[];
  }
  /** @internal */
  export interface IGLTFTechniqueStates {
      enable: number[];
      functions: IGLTFTechniqueStatesFunctions;
  }
  /** @internal */
  export interface IGLTFTechnique extends IGLTFChildRootProperty {
      parameters: {
          [key: string]: IGLTFTechniqueParameter;
      };
      program: string;
      attributes: {
          [key: string]: string;
      };
      uniforms: {
          [key: string]: string;
      };
      states: IGLTFTechniqueStates;
  }
  /** @internal */
  export interface IGLTFMaterial extends IGLTFChildRootProperty {
      technique?: string;
      values: string[];
  }
  /** @internal */
  export interface IGLTFMeshPrimitive extends IGLTFProperty {
      attributes: {
          [key: string]: string;
      };
      indices: string;
      material: string;
      mode?: number;
  }
  /** @internal */
  export interface IGLTFMesh extends IGLTFChildRootProperty {
      primitives: IGLTFMeshPrimitive[];
  }
  /** @internal */
  export interface IGLTFImage extends IGLTFChildRootProperty {
      uri: string;
  }
  /** @internal */
  export interface IGLTFSampler extends IGLTFChildRootProperty {
      magFilter?: number;
      minFilter?: number;
      wrapS?: number;
      wrapT?: number;
  }
  /** @internal */
  export interface IGLTFTexture extends IGLTFChildRootProperty {
      sampler: string;
      source: string;
      format?: ETextureFormat;
      internalFormat?: ETextureFormat;
      target?: number;
      type?: number;
      babylonTexture?: BABYLON.Texture;
  }
  /** @internal */
  export interface IGLTFAmbienLight {
      color?: number[];
  }
  /** @internal */
  export interface IGLTFDirectionalLight {
      color?: number[];
  }
  /** @internal */
  export interface IGLTFPointLight {
      color?: number[];
      constantAttenuation?: number;
      linearAttenuation?: number;
      quadraticAttenuation?: number;
  }
  /** @internal */
  export interface IGLTFSpotLight {
      color?: number[];
      constantAttenuation?: number;
      fallOfAngle?: number;
      fallOffExponent?: number;
      linearAttenuation?: number;
      quadraticAttenuation?: number;
  }
  /** @internal */
  export interface IGLTFLight extends IGLTFChildRootProperty {
      type: string;
  }
  /** @internal */
  export interface IGLTFCameraOrthographic {
      xmag: number;
      ymag: number;
      zfar: number;
      znear: number;
  }
  /** @internal */
  export interface IGLTFCameraPerspective {
      aspectRatio: number;
      yfov: number;
      zfar: number;
      znear: number;
  }
  /** @internal */
  export interface IGLTFCamera extends IGLTFChildRootProperty {
      type: string;
  }
  /** @internal */
  export interface IGLTFAnimationChannelTarget {
      id: string;
      path: string;
  }
  /** @internal */
  export interface IGLTFAnimationChannel {
      sampler: string;
      target: IGLTFAnimationChannelTarget;
  }
  /** @internal */
  export interface IGLTFAnimationSampler {
      input: string;
      output: string;
      interpolation?: string;
  }
  /** @internal */
  export interface IGLTFAnimation extends IGLTFChildRootProperty {
      channels?: IGLTFAnimationChannel[];
      parameters?: {
          [key: string]: string;
      };
      samplers?: {
          [key: string]: IGLTFAnimationSampler;
      };
  }
  /** @internal */
  export interface IGLTFNodeInstanceSkin {
      skeletons: string[];
      skin: string;
      meshes: string[];
  }
  /** @internal */
  export interface IGLTFSkins extends IGLTFChildRootProperty {
      bindShapeMatrix: number[];
      inverseBindMatrices: string;
      jointNames: string[];
      babylonSkeleton?: BABYLON.Skeleton;
  }
  /** @internal */
  export interface IGLTFNode extends IGLTFChildRootProperty {
      camera?: string;
      children: string[];
      skin?: string;
      jointName?: string;
      light?: string;
      matrix: number[];
      mesh?: string;
      meshes?: string[];
      rotation?: number[];
      scale?: number[];
      translation?: number[];
      babylonNode?: BABYLON.Node;
  }
  /** @internal */
  export interface IGLTFScene extends IGLTFChildRootProperty {
      nodes: string[];
  }
  /** @internal */
  export interface IGLTFRuntime {
      extensions: {
          [key: string]: any;
      };
      accessors: {
          [key: string]: IGLTFAccessor;
      };
      buffers: {
          [key: string]: IGLTFBuffer;
      };
      bufferViews: {
          [key: string]: IGLTFBufferView;
      };
      meshes: {
          [key: string]: IGLTFMesh;
      };
      lights: {
          [key: string]: IGLTFLight;
      };
      cameras: {
          [key: string]: IGLTFCamera;
      };
      nodes: {
          [key: string]: IGLTFNode;
      };
      images: {
          [key: string]: IGLTFImage;
      };
      textures: {
          [key: string]: IGLTFTexture;
      };
      shaders: {
          [key: string]: IGLTFShader;
      };
      programs: {
          [key: string]: IGLTFProgram;
      };
      samplers: {
          [key: string]: IGLTFSampler;
      };
      techniques: {
          [key: string]: IGLTFTechnique;
      };
      materials: {
          [key: string]: IGLTFMaterial;
      };
      animations: {
          [key: string]: IGLTFAnimation;
      };
      skins: {
          [key: string]: IGLTFSkins;
      };
      currentScene?: Object;
      scenes: {
          [key: string]: IGLTFScene;
      };
      extensionsUsed: string[];
      extensionsRequired?: string[];
      buffersCount: number;
      shaderscount: number;
      scene: BABYLON.Scene;
      rootUrl: string;
      loadedBufferCount: number;
      loadedBufferViews: {
          [name: string]: ArrayBufferView;
      };
      loadedShaderCount: number;
      importOnlyMeshes: boolean;
      importMeshesNames?: string[];
      dummyNodes: BABYLON.Node[];
      assetContainer: BABYLON.Nullable<BABYLON.AssetContainer>;
  }
  /** @internal */
  export interface INodeToRoot {
      bone: BABYLON.Bone;
      node: IGLTFNode;
      id: string;
  }
  /** @internal */
  export interface IJointNode {
      node: IGLTFNode;
      id: string;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderUtils' {
  import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  import { EComponentType } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  /**
   * Utils functions for GLTF
   * @internal
   * @deprecated
   */
  export class GLTFUtils {
      /**
       * Sets the given "parameter" matrix
       * @param scene the Scene object
       * @param source the source node where to pick the matrix
       * @param parameter the GLTF technique parameter
       * @param uniformName the name of the shader's uniform
       * @param shaderMaterial the shader material
       */
      static SetMatrix(scene: BABYLON.Scene, source: BABYLON.Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: BABYLON.ShaderMaterial | BABYLON.Effect): void;
      /**
       * Sets the given "parameter" matrix
       * @param shaderMaterial the shader material
       * @param uniform the name of the shader's uniform
       * @param value the value of the uniform
       * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)
       */
      static SetUniform(shaderMaterial: BABYLON.ShaderMaterial | BABYLON.Effect, uniform: string, value: any, type: number): boolean;
      /**
       * Returns the wrap mode of the texture
       * @param mode the mode value
       */
      static GetWrapMode(mode: number): number;
      /**
       * Returns the byte stride giving an accessor
       * @param accessor the GLTF accessor objet
       */
      static GetByteStrideFromType(accessor: IGLTFAccessor): number;
      /**
       * Returns the texture filter mode giving a mode value
       * @param mode the filter mode value
       * @returns the filter mode (TODO - needs to be a type?)
       */
      static GetTextureFilterMode(mode: number): number;
      static GetBufferFromBufferView(gltfRuntime: IGLTFRuntime, bufferView: IGLTFBufferView, byteOffset: number, byteLength: number, componentType: EComponentType): ArrayBufferView;
      /**
       * Returns a buffer from its accessor
       * @param gltfRuntime the GLTF runtime
       * @param accessor the GLTF accessor
       */
      static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any;
      /**
       * Decodes a buffer view into a string
       * @param view the buffer view
       */
      static DecodeBufferToText(view: ArrayBufferView): string;
      /**
       * Returns the default material of gltf. Related to
       * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material
       * @param scene the Babylon.js scene
       */
      static GetDefaultMaterial(scene: BABYLON.Scene): BABYLON.ShaderMaterial;
      private static _DefaultMaterial;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFMaterialsCommonExtension' {
  import { GLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoader';
  import type { IGLTFRuntime } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  /**
   * @internal
   * @deprecated
   */
  export class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {
      constructor();
      loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean;
      loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: BABYLON.Material) => void, onError: (message: string) => void): boolean;
      private _loadTexture;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFBinaryExtension';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoader';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderInterfaces';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFLoaderUtils';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/glTFMaterialsCommonExtension';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_lights_image_based' {
  import type { IScene } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  module 'babylonjs-gltf2interface' {
      /** @internal */
      interface IEXTLightsImageBased_LightImageBased {
          _babylonTexture?: BABYLON.BaseTexture;
          _loaded?: Promise<void>;
      }
  }
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)
   */
  export class EXT_lights_image_based implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "EXT_lights_image_based";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      private _lights?;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      onLoading(): void;
      /**
       * @internal
       */
      loadSceneAsync(context: string, scene: IScene): BABYLON.Nullable<Promise<void>>;
      private _loadLightAsync;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_mesh_gpu_instancing' {
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import type { INode } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)
   * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)
   */
  export class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "EXT_mesh_gpu_instancing";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: BABYLON.TransformNode) => void): BABYLON.Nullable<Promise<BABYLON.TransformNode>>;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_meshopt_compression' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { IBufferView } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)
   *
   * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js
   * @since 5.0.0
   */
  export class EXT_meshopt_compression implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "EXT_meshopt_compression";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_texture_webp' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { ITexture } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)
   */
  export class EXT_texture_webp implements IGLTFLoaderExtension {
      /** The name of this extension. */
      readonly name = "EXT_texture_webp";
      /** Defines whether this extension is enabled. */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BABYLON.BaseTexture) => void): Nullable<Promise<BABYLON.BaseTexture>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/ExtrasAsMetadata' {
  import type { INode, ICamera, IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Camera = BABYLON.Camera;
  type TransformNode = BABYLON.TransformNode;
  /**
   * Store glTF extras (if present) in BJS objects' metadata
   */
  export class ExtrasAsMetadata implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "ExtrasAsMetadata";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      private _assignExtras;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>>;
      /**
       * @internal
       */
      loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>>;
      /**
       * @internal
       */
      createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<BABYLON.Material>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_animation_pointer' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { IAnimation, IAnimationChannel } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Animation = BABYLON.Animation;
  const Animation: typeof BABYLON.Animation;
  /**
   * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)
   * !!! Experimental Extension Subject to Changes !!!
   */
  export class KHR_animation_pointer implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_animation_pointer";
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /**
       * Defines whether this extension is enabled.
       */
      get enabled(): boolean;
      /** @internal */
      dispose(): void;
      /**
       * Loads a glTF animation channel.
       * @param context The context when loading the asset
       * @param animationContext The context of the animation when loading the asset
       * @param animation The glTF animation property
       * @param channel The glTF animation channel property
       * @param onLoad Called for each animation loaded
       * @returns A void promise that resolves when the load is complete or null if not handled
       */
      _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, onLoad: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: Animation) => void): Nullable<Promise<void>>;
      /**
       * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).
       * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>
       * <rootNode> := 'nodes' | 'materials' | 'meshes' | 'cameras' | 'extensions'
       * <assetIndex> := <digit> | <name>
       * <propertyPath> := <extensionPath> | <standardPath>
       * <extensionPath> := 'extensions'/<name>/<standardPath>
       * <standardPath> := <name> | <name>/<standardPath>
       * <name> := W+
       * <digit> := D+
       *
       * Examples:
       *  - '/nodes/0/rotation'
       *  - '/materials/2/emissiveFactor'
       *  - '/materials/2/pbrMetallicRoughness/baseColorFactor'
       *  - '/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength'
       */
      private _parseAnimationPointer;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_animation_pointer.data' {
  import type { ICamera, IKHRLightsPunctual_Light, IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import { AnimationPropertyInfo } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation';
  type Animation = BABYLON.Animation;
  const Animation: typeof BABYLON.Animation;
  class CameraAnimationPropertyInfo extends AnimationPropertyInfo {
      /** @internal */
      buildAnimations(target: ICamera, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: Animation) => void): void;
  }
  class MaterialAnimationPropertyInfo extends AnimationPropertyInfo {
      /** @internal */
      buildAnimations(target: IMaterial, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: Animation) => void): void;
  }
  class LightAnimationPropertyInfo extends AnimationPropertyInfo {
      /** @internal */
      buildAnimations(target: IKHRLightsPunctual_Light, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: Animation) => void): void;
  }
  /** @internal */
  export const animationPointerTree: {
      nodes: {
          __array__: {
              translation: import("@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation").TransformNodeAnimationPropertyInfo[];
              rotation: import("@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation").TransformNodeAnimationPropertyInfo[];
              scale: import("@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation").TransformNodeAnimationPropertyInfo[];
              weights: import("@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation").WeightAnimationPropertyInfo[];
              __target__: boolean;
          };
      };
      materials: {
          __array__: {
              __target__: boolean;
              pbrMetallicRoughness: {
                  baseColorFactor: MaterialAnimationPropertyInfo[];
                  metallicFactor: MaterialAnimationPropertyInfo[];
                  roughnessFactor: MaterialAnimationPropertyInfo[];
                  baseColorTexture: {
                      extensions: {
                          KHR_texture_transform: {
                              scale: MaterialAnimationPropertyInfo[];
                              offset: MaterialAnimationPropertyInfo[];
                              rotation: MaterialAnimationPropertyInfo[];
                          };
                      };
                  };
              };
              emissiveFactor: MaterialAnimationPropertyInfo[];
              normalTexture: {
                  scale: MaterialAnimationPropertyInfo[];
              };
              occlusionTexture: {
                  strength: MaterialAnimationPropertyInfo[];
                  extensions: {
                      KHR_texture_transform: {
                          scale: MaterialAnimationPropertyInfo[];
                          offset: MaterialAnimationPropertyInfo[];
                          rotation: MaterialAnimationPropertyInfo[];
                      };
                  };
              };
              emissiveTexture: {
                  extensions: {
                      KHR_texture_transform: {
                          scale: MaterialAnimationPropertyInfo[];
                          offset: MaterialAnimationPropertyInfo[];
                          rotation: MaterialAnimationPropertyInfo[];
                      };
                  };
              };
              extensions: {
                  KHR_materials_ior: {
                      ior: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_clearcoat: {
                      clearcoatFactor: MaterialAnimationPropertyInfo[];
                      clearcoatRoughnessFactor: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_sheen: {
                      sheenColorFactor: MaterialAnimationPropertyInfo[];
                      sheenRoughnessFactor: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_specular: {
                      specularFactor: MaterialAnimationPropertyInfo[];
                      specularColorFactor: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_emissive_strength: {
                      emissiveStrength: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_transmission: {
                      transmissionFactor: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_volume: {
                      attenuationColor: MaterialAnimationPropertyInfo[];
                      attenuationDistance: MaterialAnimationPropertyInfo[];
                      thicknessFactor: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_iridescence: {
                      iridescenceFactor: MaterialAnimationPropertyInfo[];
                      iridescenceIor: MaterialAnimationPropertyInfo[];
                      iridescenceThicknessMinimum: MaterialAnimationPropertyInfo[];
                      iridescenceThicknessMaximum: MaterialAnimationPropertyInfo[];
                  };
                  KHR_materials_anisotropy: {
                      anisotropyStrength: MaterialAnimationPropertyInfo[];
                      anisotropyRotation: MaterialAnimationPropertyInfo[];
                  };
              };
          };
      };
      cameras: {
          __array__: {
              __target__: boolean;
              orthographic: {
                  xmag: CameraAnimationPropertyInfo[];
                  ymag: CameraAnimationPropertyInfo[];
                  zfar: CameraAnimationPropertyInfo[];
                  znear: CameraAnimationPropertyInfo[];
              };
              perspective: {
                  yfov: CameraAnimationPropertyInfo[];
                  zfar: CameraAnimationPropertyInfo[];
                  znear: CameraAnimationPropertyInfo[];
              };
          };
      };
      extensions: {
          KHR_lights_punctual: {
              lights: {
                  __array__: {
                      __target__: boolean;
                      color: LightAnimationPropertyInfo[];
                      intensity: LightAnimationPropertyInfo[];
                      range: LightAnimationPropertyInfo[];
                      spot: {
                          innerConeAngle: LightAnimationPropertyInfo[];
                          outerConeAngle: LightAnimationPropertyInfo[];
                      };
                  };
              };
          };
      };
  };
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_draco_mesh_compression' {
  import type { IMeshPrimitive } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Mesh = BABYLON.Mesh;
  type Geometry = BABYLON.Geometry;
  const Geometry: typeof BABYLON.Geometry;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)
   */
  export class KHR_draco_mesh_compression implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_draco_mesh_compression";
      /**
       * The draco compression used to decode vertex data or DracoCompression.Default if not defined
       */
      dracoCompression?: BABYLON.DracoCompression;
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_lights_punctual' {
  import type { INode } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type TransformNode = BABYLON.TransformNode;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)
   */
  export class KHR_lights implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_lights_punctual";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /** hidden */
      private _loader;
      private _lights?;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      onLoading(): void;
      /**
       * @internal
       */
      loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_anisotropy' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy)
   */
  export class KHR_materials_anisotropy implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_anisotropy";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadIridescencePropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_clearcoat' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)
   * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)
   */
  export class KHR_materials_clearcoat implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_clearcoat";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadClearCoatPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_emissive_strength' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)
   */
  export class KHR_materials_emissive_strength implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_emissive_strength";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadEmissiveProperties;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_ior' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)
   */
  export class KHR_materials_ior implements IGLTFLoaderExtension {
      /**
       * Default ior Value from the spec.
       */
      private static readonly _DEFAULT_IOR;
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_ior";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadIorPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_iridescence' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)
   */
  export class KHR_materials_iridescence implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_iridescence";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadIridescencePropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)
   */
  export class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_pbrSpecularGlossiness";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadSpecularGlossinessPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_sheen' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)
   * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)
   */
  export class KHR_materials_sheen implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_sheen";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadSheenPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_specular' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)
   */
  export class KHR_materials_specular implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_specular";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadSpecularPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_translucency' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)
   * !!! Experimental Extension Subject to Changes !!!
   */
  export class KHR_materials_translucency implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_translucency";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadTranslucentPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_transmission' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)
   */
  export class KHR_materials_transmission implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_transmission";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadTransparentPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_unlit' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)
   */
  export class KHR_materials_unlit implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_unlit";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadUnlitPropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_variants' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { INode, IMeshPrimitive, IMesh } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Mesh = BABYLON.Mesh;
  type AbstractMesh = BABYLON.AbstractMesh;
  const Mesh: typeof BABYLON.Mesh;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)
   */
  export class KHR_materials_variants implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_variants";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      private _variants?;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * Gets the list of available variant names for this asset.
       * @param rootMesh The glTF root mesh
       * @returns the list of all the variant names for this model
       */
      static GetAvailableVariants(rootMesh: Mesh): string[];
      /**
       * Gets the list of available variant names for this asset.
       * @param rootMesh The glTF root mesh
       * @returns the list of all the variant names for this model
       */
      getAvailableVariants(rootMesh: Mesh): string[];
      /**
       * Select a variant given a variant name or a list of variant names.
       * @param rootMesh The glTF root mesh
       * @param variantName The variant name(s) to select.
       */
      static SelectVariant(rootMesh: Mesh, variantName: string | string[]): void;
      /**
       * Select a variant given a variant name or a list of variant names.
       * @param rootMesh The glTF root mesh
       * @param variantName The variant name(s) to select.
       */
      selectVariant(rootMesh: Mesh, variantName: string | string[]): void;
      /**
       * Reset back to the original before selecting a variant.
       * @param rootMesh The glTF root mesh
       */
      static Reset(rootMesh: Mesh): void;
      /**
       * Reset back to the original before selecting a variant.
       * @param rootMesh The glTF root mesh
       */
      reset(rootMesh: Mesh): void;
      /**
       * Gets the last selected variant name(s) or null if original.
       * @param rootMesh The glTF root mesh
       * @returns The selected variant name(s).
       */
      static GetLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]>;
      /**
       * Gets the last selected variant name(s) or null if original.
       * @param rootMesh The glTF root mesh
       * @returns The selected variant name(s).
       */
      getLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]>;
      private static _GetExtensionMetadata;
      /** @internal */
      onLoading(): void;
      /**
       * @internal
       */
      _loadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: AbstractMesh) => void): Nullable<Promise<AbstractMesh>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_volume' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)
   * @since 5.0.0
   */
  export class KHR_materials_volume implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_materials_volume";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
      private _loadVolumePropertiesAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_mesh_quantization' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   */
  export class KHR_mesh_quantization implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_mesh_quantization";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_texture_basisu' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { ITexture } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  type Nullable<T> = BABYLON.Nullable<T>;
  type BaseTexture = BABYLON.BaseTexture;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)
   */
  export class KHR_texture_basisu implements IGLTFLoaderExtension {
      /** The name of this extension. */
      readonly name = "KHR_texture_basisu";
      /** Defines whether this extension is enabled. */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_texture_transform' {
  import type { ITextureInfo } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type BaseTexture = BABYLON.BaseTexture;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)
   */
  export class KHR_texture_transform implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_texture_transform";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_xmp_json_ld' {
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)
   * @since 5.0.0
   */
  export class KHR_xmp_json_ld implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "KHR_xmp_json_ld";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      private _loader;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /**
       * Called after the loader state changes to LOADING.
       */
      onLoading(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_audio_emitter' {
  import type { IScene, INode, IAnimation } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type AnimationGroup = BABYLON.AnimationGroup;
  type TransformNode = BABYLON.TransformNode;
  /**
   * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)
   * !!! Experimental Extension Subject to Changes !!!
   */
  export class MSFT_audio_emitter implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "MSFT_audio_emitter";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      private _loader;
      private _clips;
      private _emitters;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      onLoading(): void;
      /**
       * @internal
       */
      loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>>;
      /**
       * @internal
       */
      loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>>;
      /**
       * @internal
       */
      loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>>;
      private _loadClipAsync;
      private _loadEmitterAsync;
      private _getEventAction;
      private _loadAnimationEventAsync;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_lod' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import type { INode, IMaterial, IBuffer, IScene } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  import type { IProperty } from 'babylonjs-gltf2interface';
  type Nullable<T> = BABYLON.Nullable<T>;
  type TransformNode = BABYLON.TransformNode;
  type Mesh = BABYLON.Mesh;
  type Material = BABYLON.Material;
  /**
   * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)
   */
  export class MSFT_lod implements IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name = "MSFT_lod";
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines a number that determines the order the extensions are applied.
       */
      order: number;
      /**
       * Maximum number of LODs to load, starting from the lowest LOD.
       */
      maxLODsToLoad: number;
      /**
       * Observable raised when all node LODs of one level are loaded.
       * The event data is the index of the loaded LOD starting from zero.
       * Dispose the loader to cancel the loading of the next level of LODs.
       */
      onNodeLODsLoadedObservable: BABYLON.Observable<number>;
      /**
       * Observable raised when all material LODs of one level are loaded.
       * The event data is the index of the loaded LOD starting from zero.
       * Dispose the loader to cancel the loading of the next level of LODs.
       */
      onMaterialLODsLoadedObservable: BABYLON.Observable<number>;
      private _loader;
      private _bufferLODs;
      private _nodeIndexLOD;
      private _nodeSignalLODs;
      private _nodePromiseLODs;
      private _nodeBufferLODs;
      private _materialIndexLOD;
      private _materialSignalLODs;
      private _materialPromiseLODs;
      private _materialBufferLODs;
      /**
       * @internal
       */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      onReady(): void;
      /**
       * @internal
       */
      loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>>;
      /**
       * @internal
       */
      loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>>;
      /**
       * @internal
       */
      _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: Nullable<Mesh>, babylonDrawMode: number, assign: (babylonMaterial: Material) => void): Nullable<Promise<Material>>;
      /**
       * @internal
       */
      _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>>;
      /**
       * @internal
       */
      loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>>;
      private _loadBufferLOD;
      /**
       * Gets an array of LOD properties from lowest to highest.
       * @param context
       * @param property
       * @param array
       * @param ids
       */
      private _getLODs;
      private _disposeTransformNode;
      private _disposeMaterials;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_minecraftMesh' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /** @internal */
  export class MSFT_minecraftMesh implements IGLTFLoaderExtension {
      /** @internal */
      readonly name = "MSFT_minecraftMesh";
      /** @internal */
      enabled: boolean;
      private _loader;
      /** @internal */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_sRGBFactors' {
  import type { IMaterial } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import { GLTFLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  type Nullable<T> = BABYLON.Nullable<T>;
  type Material = BABYLON.Material;
  /** @internal */
  export class MSFT_sRGBFactors implements IGLTFLoaderExtension {
      /** @internal */
      readonly name = "MSFT_sRGBFactors";
      /** @internal */
      enabled: boolean;
      private _loader;
      /** @internal */
      constructor(loader: GLTFLoader);
      /** @internal */
      dispose(): void;
      /** @internal */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>>;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_lights_image_based';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_mesh_gpu_instancing';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_meshopt_compression';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/EXT_texture_webp';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_draco_mesh_compression';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_lights_punctual';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_unlit';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_clearcoat';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_iridescence';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_anisotropy';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_emissive_strength';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_sheen';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_specular';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_ior';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_variants';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_transmission';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_translucency';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_materials_volume';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_mesh_quantization';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_texture_basisu';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_texture_transform';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_xmp_json_ld';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/KHR_animation_pointer';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_audio_emitter';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_lod';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_minecraftMesh';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/MSFT_sRGBFactors';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/ExtrasAsMetadata';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import { type IProperty } from 'babylonjs-gltf2interface';
  import type { IGLTF, ISampler, INode, IScene, IMesh, IAccessor, ICamera, IAnimation, IBuffer, IBufferView, IMaterial, ITextureInfo, ITexture, IImage, IMeshPrimitive, IArrayItem, IAnimationChannel } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  import type { IGLTFLoader, IGLTFLoaderData } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  import { GLTFFileLoader } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  import type { AnimationPropertyInfo } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation';
  interface IWithMetadata {
      metadata: any;
      _internalMetadata: any;
  }
  /**
   * Helper class for working with arrays when loading the glTF asset
   */
  export class ArrayItem {
      /**
       * Gets an item from the given array.
       * @param context The context when loading the asset
       * @param array The array to get the item from
       * @param index The index to the array
       * @returns The array item
       */
      static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T;
      /**
       * Assign an `index` field to each item of the given array.
       * @param array The array of items
       */
      static Assign(array?: IArrayItem[]): void;
  }
  /** @internal */
  export interface IAnimationTargetInfo {
      /** @internal */
      target: any;
      /** @internal */
      properties: Array<AnimationPropertyInfo>;
  }
  /**
   * The glTF 2.0 loader
   */
  export class GLTFLoader implements IGLTFLoader {
      /** @internal */
      readonly _completePromises: Promise<any>[];
      /** @internal */
      _assetContainer: BABYLON.Nullable<BABYLON.AssetContainer>;
      /** Storage */
      _babylonLights: BABYLON.Light[];
      /** @internal */
      _disableInstancedMesh: number;
      private readonly _parent;
      private readonly _extensions;
      private _disposed;
      private _rootUrl;
      private _fileName;
      private _uniqueRootUrl;
      private _gltf;
      private _bin;
      private _babylonScene;
      private _rootBabylonMesh;
      private _defaultBabylonMaterialData;
      private readonly _postSceneLoadActions;
      private static _RegisteredExtensions;
      /**
       * The default glTF sampler.
       */
      static readonly DefaultSampler: ISampler;
      /**
       * Registers a loader extension.
       * @param name The name of the loader extension.
       * @param factory The factory function that creates the loader extension.
       */
      static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void;
      /**
       * Unregisters a loader extension.
       * @param name The name of the loader extension.
       * @returns A boolean indicating whether the extension has been unregistered
       */
      static UnregisterExtension(name: string): boolean;
      /**
       * The object that represents the glTF JSON.
       */
      get gltf(): IGLTF;
      /**
       * The BIN chunk of a binary glTF.
       */
      get bin(): BABYLON.Nullable<BABYLON.IDataBuffer>;
      /**
       * The parent file loader.
       */
      get parent(): GLTFFileLoader;
      /**
       * The Babylon scene when loading the asset.
       */
      get babylonScene(): BABYLON.Scene;
      /**
       * The root Babylon mesh when loading the asset.
       */
      get rootBabylonMesh(): BABYLON.Nullable<BABYLON.Mesh>;
      /**
       * @internal
       */
      constructor(parent: GLTFFileLoader);
      /** @internal */
      dispose(): void;
      /**
       * @internal
       */
      importMeshAsync(meshesNames: any, scene: BABYLON.Scene, container: BABYLON.Nullable<BABYLON.AssetContainer>, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string): Promise<BABYLON.ISceneLoaderAsyncResult>;
      /**
       * @internal
       */
      loadAsync(scene: BABYLON.Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;
      private _loadAsync;
      private _loadData;
      private _setupData;
      private _loadExtensions;
      private _checkExtensions;
      private _createRootNode;
      /**
       * Loads a glTF scene.
       * @param context The context when loading the asset
       * @param scene The glTF scene property
       * @returns A promise that resolves when the load is complete
       */
      loadSceneAsync(context: string, scene: IScene): Promise<void>;
      private _forEachPrimitive;
      private _getGeometries;
      private _getMeshes;
      private _getTransformNodes;
      private _getSkeletons;
      private _getAnimationGroups;
      private _startAnimations;
      /**
       * Loads a glTF node.
       * @param context The context when loading the asset
       * @param node The glTF node property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon mesh when the load is complete
       */
      loadNodeAsync(context: string, node: INode, assign?: (babylonTransformNode: BABYLON.TransformNode) => void): Promise<BABYLON.TransformNode>;
      private _loadMeshAsync;
      /**
       * @internal Define this method to modify the default behavior when loading data for mesh primitives.
       * @param context The context when loading the asset
       * @param name The mesh name when loading the asset
       * @param node The glTF node when loading the asset
       * @param mesh The glTF mesh when loading the asset
       * @param primitive The glTF mesh primitive property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled
       */
      _loadMeshPrimitiveAsync(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: BABYLON.AbstractMesh) => void): Promise<BABYLON.AbstractMesh>;
      private _loadVertexDataAsync;
      private _createMorphTargets;
      private _loadMorphTargetsAsync;
      private _loadMorphTargetVertexDataAsync;
      private static _LoadTransform;
      private _loadSkinAsync;
      private _loadBones;
      private _findSkeletonRootNode;
      private _loadBone;
      private _loadSkinInverseBindMatricesDataAsync;
      private _updateBoneMatrices;
      private _getNodeMatrix;
      /**
       * Loads a glTF camera.
       * @param context The context when loading the asset
       * @param camera The glTF camera property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon camera when the load is complete
       */
      loadCameraAsync(context: string, camera: ICamera, assign?: (babylonCamera: BABYLON.Camera) => void): Promise<BABYLON.Camera>;
      private _loadAnimationsAsync;
      /**
       * Loads a glTF animation.
       * @param context The context when loading the asset
       * @param animation The glTF animation property
       * @returns A promise that resolves with the loaded Babylon animation group when the load is complete
       */
      loadAnimationAsync(context: string, animation: IAnimation): Promise<BABYLON.AnimationGroup>;
      /**
       * @hidden
       * Loads a glTF animation channel.
       * @param context The context when loading the asset
       * @param animationContext The context of the animation when loading the asset
       * @param animation The glTF animation property
       * @param channel The glTF animation channel property
       * @param onLoad Called for each animation loaded
       * @returns A void promise that resolves when the load is complete
       */
      _loadAnimationChannelAsync(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, onLoad: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): Promise<void>;
      /**
       * @hidden
       * Loads a glTF animation channel.
       * @param context The context when loading the asset
       * @param animationContext The context of the animation when loading the asset
       * @param animation The glTF animation property
       * @param channel The glTF animation channel property
       * @param targetInfo The glTF target and properties
       * @param onLoad Called for each animation loaded
       * @returns A void promise that resolves when the load is complete
       */
      _loadAnimationChannelFromTargetInfoAsync(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, targetInfo: IAnimationTargetInfo, onLoad: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): Promise<void>;
      private _loadAnimationSamplerAsync;
      /**
       * Loads a glTF buffer.
       * @param context The context when loading the asset
       * @param buffer The glTF buffer property
       * @param byteOffset The byte offset to use
       * @param byteLength The byte length to use
       * @returns A promise that resolves with the loaded data when the load is complete
       */
      loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView>;
      /**
       * Loads a glTF buffer view.
       * @param context The context when loading the asset
       * @param bufferView The glTF buffer view property
       * @returns A promise that resolves with the loaded data when the load is complete
       */
      loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView>;
      private _loadAccessorAsync;
      /**
       * @internal
       */
      _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array>;
      /**
       * @internal
       */
      _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<BABYLON.IndicesArray>;
      /**
       * @internal
       */
      _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<BABYLON.Buffer>;
      /**
       * @internal
       */
      _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<BABYLON.VertexBuffer>;
      private _loadMaterialMetallicRoughnessPropertiesAsync;
      /**
       * @internal
       */
      _loadMaterialAsync(context: string, material: IMaterial, babylonMesh: BABYLON.Nullable<BABYLON.Mesh>, babylonDrawMode: number, assign?: (babylonMaterial: BABYLON.Material) => void): Promise<BABYLON.Material>;
      private _createDefaultMaterial;
      /**
       * Creates a Babylon material from a glTF material.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonDrawMode The draw mode for the Babylon material
       * @returns The Babylon material
       */
      createMaterial(context: string, material: IMaterial, babylonDrawMode: number): BABYLON.Material;
      /**
       * Loads properties from a glTF material into a Babylon material.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonMaterial The Babylon material
       * @returns A promise that resolves when the load is complete
       */
      loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: BABYLON.Material): Promise<void>;
      /**
       * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonMaterial The Babylon material
       * @returns A promise that resolves when the load is complete
       */
      loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: BABYLON.Material): Promise<void>;
      /**
       * Loads the alpha properties from a glTF material into a Babylon material.
       * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonMaterial The Babylon material
       */
      loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: BABYLON.Material): void;
      /**
       * Loads a glTF texture info.
       * @param context The context when loading the asset
       * @param textureInfo The glTF texture info property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon texture when the load is complete
       */
      loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign?: (babylonTexture: BABYLON.BaseTexture) => void): Promise<BABYLON.BaseTexture>;
      /**
       * @internal
       */
      _loadTextureAsync(context: string, texture: ITexture, assign?: (babylonTexture: BABYLON.BaseTexture) => void): Promise<BABYLON.BaseTexture>;
      /**
       * @internal
       */
      _createTextureAsync(context: string, sampler: ISampler, image: IImage, assign?: (babylonTexture: BABYLON.BaseTexture) => void, textureLoaderOptions?: any, useSRGBBuffer?: boolean): Promise<BABYLON.BaseTexture>;
      private _loadSampler;
      /**
       * Loads a glTF image.
       * @param context The context when loading the asset
       * @param image The glTF image property
       * @returns A promise that resolves with the loaded data when the load is complete
       */
      loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView>;
      /**
       * Loads a glTF uri.
       * @param context The context when loading the asset
       * @param property The glTF property associated with the uri
       * @param uri The base64 or relative uri
       * @returns A promise that resolves with the loaded data when the load is complete
       */
      loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView>;
      /**
       * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.
       * @param babylonObject the Babylon object with _internalMetadata
       * @param pointer the JSON pointer
       */
      static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void;
      private static _GetTextureWrapMode;
      private static _GetTextureSamplingMode;
      private static _GetTypedArrayConstructor;
      private static _GetTypedArray;
      private static _GetNumComponents;
      private static _ValidateUri;
      /**
       * @internal
       */
      static _GetDrawMode(context: string, mode: number | undefined): number;
      private _compileMaterialsAsync;
      private _compileShadowGeneratorsAsync;
      private _forEachExtensions;
      private _applyExtensions;
      private _extensionsOnLoading;
      private _extensionsOnReady;
      private _extensionsLoadSceneAsync;
      private _extensionsLoadNodeAsync;
      private _extensionsLoadCameraAsync;
      private _extensionsLoadVertexDataAsync;
      private _extensionsLoadMeshPrimitiveAsync;
      private _extensionsLoadMaterialAsync;
      private _extensionsCreateMaterial;
      private _extensionsLoadMaterialPropertiesAsync;
      private _extensionsLoadTextureInfoAsync;
      private _extensionsLoadTextureAsync;
      private _extensionsLoadAnimationAsync;
      private _extensionsLoadAnimationChannelAsync;
      private _extensionsLoadSkinAsync;
      private _extensionsLoadUriAsync;
      private _extensionsLoadBufferViewAsync;
      private _extensionsLoadBufferAsync;
      /**
       * Helper method called by a loader extension to load an glTF extension.
       * @param context The context when loading the asset
       * @param property The glTF property to load the extension from
       * @param extensionName The name of the extension to load
       * @param actionAsync The action to run
       * @returns The promise returned by actionAsync or null if the extension does not exist
       */
      static LoadExtensionAsync<TExtension = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extensionContext: string, extension: TExtension) => BABYLON.Nullable<Promise<TResult>>): BABYLON.Nullable<Promise<TResult>>;
      /**
       * Helper method called by a loader extension to load a glTF extra.
       * @param context The context when loading the asset
       * @param property The glTF property to load the extra from
       * @param extensionName The name of the extension to load
       * @param actionAsync The action to run
       * @returns The promise returned by actionAsync or null if the extra does not exist
       */
      static LoadExtraAsync<TExtra = any, TResult = void>(context: string, property: IProperty, extensionName: string, actionAsync: (extraContext: string, extra: TExtra) => BABYLON.Nullable<Promise<TResult>>): BABYLON.Nullable<Promise<TResult>>;
      /**
       * Checks for presence of an extension.
       * @param name The name of the extension to check
       * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`
       */
      isExtensionUsed(name: string): boolean;
      /**
       * Increments the indentation level and logs a message.
       * @param message The message to log
       */
      logOpen(message: string): void;
      /**
       * Decrements the indentation level.
       */
      logClose(): void;
      /**
       * Logs a message
       * @param message The message to log
       */
      log(message: string): void;
      /**
       * Starts a performance counter.
       * @param counterName The name of the performance counter
       */
      startPerformanceCounter(counterName: string): void;
      /**
       * Ends a performance counter.
       * @param counterName The name of the performance counter
       */
      endPerformanceCounter(counterName: string): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderAnimation' {
  import type { INode } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  /** @internal */
  export type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;
  /** @internal */
  export function getVector3(_target: any, source: Float32Array, offset: number, scale: number): BABYLON.Vector3;
  /** @internal */
  export function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): BABYLON.Quaternion;
  /** @internal */
  export function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number>;
  /** @internal */
  export abstract class AnimationPropertyInfo {
      readonly type: number;
      readonly name: string;
      readonly getValue: GetValueFn;
      readonly getStride: (target: any) => number;
      /** @internal */
      constructor(type: number, name: string, getValue: GetValueFn, getStride: (target: any) => number);
      protected _buildAnimation(name: string, fps: number, keys: any[]): BABYLON.Animation;
      /** @internal */
      abstract buildAnimations(target: any, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): void;
  }
  /** @internal */
  export class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {
      /** @internal */
      buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): void;
  }
  /** @internal */
  export class WeightAnimationPropertyInfo extends AnimationPropertyInfo {
      buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): void;
  }
  /** @internal */
  export const nodeAnimationData: {
      translation: TransformNodeAnimationPropertyInfo[];
      rotation: TransformNodeAnimationPropertyInfo[];
      scale: TransformNodeAnimationPropertyInfo[];
      weights: WeightAnimationPropertyInfo[];
  };

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import type { IScene, INode, IMesh, ISkin, ICamera, IMeshPrimitive, IMaterial, ITextureInfo, IAnimation, ITexture, IBufferView, IBuffer, IAnimationChannel } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  import type { IGLTFLoaderExtension as IGLTFBaseLoaderExtension } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  import type { IProperty } from 'babylonjs-gltf2interface';
  /**
   * Interface for a glTF loader extension.
   */
  export interface IGLTFLoaderExtension extends IGLTFBaseLoaderExtension, BABYLON.IDisposable {
      /**
       * Called after the loader state changes to LOADING.
       */
      onLoading?(): void;
      /**
       * Called after the loader state changes to READY.
       */
      onReady?(): void;
      /**
       * Define this method to modify the default behavior when loading scenes.
       * @param context The context when loading the asset
       * @param scene The glTF scene property
       * @returns A promise that resolves when the load is complete or null if not handled
       */
      loadSceneAsync?(context: string, scene: IScene): BABYLON.Nullable<Promise<void>>;
      /**
       * Define this method to modify the default behavior when loading nodes.
       * @param context The context when loading the asset
       * @param node The glTF node property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon transform node when the load is complete or null if not handled
       */
      loadNodeAsync?(context: string, node: INode, assign: (babylonMesh: BABYLON.TransformNode) => void): BABYLON.Nullable<Promise<BABYLON.TransformNode>>;
      /**
       * Define this method to modify the default behavior when loading cameras.
       * @param context The context when loading the asset
       * @param camera The glTF camera property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon camera when the load is complete or null if not handled
       */
      loadCameraAsync?(context: string, camera: ICamera, assign: (babylonCamera: BABYLON.Camera) => void): BABYLON.Nullable<Promise<BABYLON.Camera>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading vertex data for mesh primitives.
       * @param context The context when loading the asset
       * @param primitive The glTF mesh primitive property
       * @returns A promise that resolves with the loaded geometry when the load is complete or null if not handled
       */
      _loadVertexDataAsync?(context: string, primitive: IMeshPrimitive, babylonMesh: BABYLON.Mesh): BABYLON.Nullable<Promise<BABYLON.Geometry>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading data for mesh primitives.
       * @param context The context when loading the asset
       * @param name The mesh name when loading the asset
       * @param node The glTF node when loading the asset
       * @param mesh The glTF mesh when loading the asset
       * @param primitive The glTF mesh primitive property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled
       */
      _loadMeshPrimitiveAsync?(context: string, name: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, assign: (babylonMesh: BABYLON.AbstractMesh) => void): BABYLON.Nullable<Promise<BABYLON.AbstractMesh>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading materials. Load material creates the material and then loads material properties.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon material when the load is complete or null if not handled
       */
      _loadMaterialAsync?(context: string, material: IMaterial, babylonMesh: BABYLON.Nullable<BABYLON.Mesh>, babylonDrawMode: number, assign: (babylonMaterial: BABYLON.Material) => void): BABYLON.Nullable<Promise<BABYLON.Material>>;
      /**
       * Define this method to modify the default behavior when creating materials.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonDrawMode The draw mode for the Babylon material
       * @returns The Babylon material or null if not handled
       */
      createMaterial?(context: string, material: IMaterial, babylonDrawMode: number): BABYLON.Nullable<BABYLON.Material>;
      /**
       * Define this method to modify the default behavior when loading material properties.
       * @param context The context when loading the asset
       * @param material The glTF material property
       * @param babylonMaterial The Babylon material
       * @returns A promise that resolves when the load is complete or null if not handled
       */
      loadMaterialPropertiesAsync?(context: string, material: IMaterial, babylonMaterial: BABYLON.Material): BABYLON.Nullable<Promise<void>>;
      /**
       * Define this method to modify the default behavior when loading texture infos.
       * @param context The context when loading the asset
       * @param textureInfo The glTF texture info property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon texture when the load is complete or null if not handled
       */
      loadTextureInfoAsync?(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BABYLON.BaseTexture) => void): BABYLON.Nullable<Promise<BABYLON.BaseTexture>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading textures.
       * @param context The context when loading the asset
       * @param texture The glTF texture property
       * @param assign A function called synchronously after parsing the glTF properties
       * @returns A promise that resolves with the loaded Babylon texture when the load is complete or null if not handled
       */
      _loadTextureAsync?(context: string, texture: ITexture, assign: (babylonTexture: BABYLON.BaseTexture) => void): BABYLON.Nullable<Promise<BABYLON.BaseTexture>>;
      /**
       * Define this method to modify the default behavior when loading animations.
       * @param context The context when loading the asset
       * @param animation The glTF animation property
       * @returns A promise that resolves with the loaded Babylon animation group when the load is complete or null if not handled
       */
      loadAnimationAsync?(context: string, animation: IAnimation): BABYLON.Nullable<Promise<BABYLON.AnimationGroup>>;
      /**
       * @internal
       * Define this method to modify the default behvaior when loading animation channels.
       * @param context The context when loading the asset
       * @param animationContext The context of the animation when loading the asset
       * @param animation The glTF animation property
       * @param channel The glTF animation channel property
       * @param onLoad Called for each animation loaded
       * @returns A void promise that resolves when the load is complete or null if not handled
       */
      _loadAnimationChannelAsync?(context: string, animationContext: string, animation: IAnimation, channel: IAnimationChannel, onLoad: (babylonAnimatable: BABYLON.IAnimatable, babylonAnimation: BABYLON.Animation) => void): BABYLON.Nullable<Promise<void>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading skins.
       * @param context The context when loading the asset
       * @param node The glTF node property
       * @param skin The glTF skin property
       * @returns A promise that resolves when the load is complete or null if not handled
       */
      _loadSkinAsync?(context: string, node: INode, skin: ISkin): BABYLON.Nullable<Promise<void>>;
      /**
       * @internal
       * Define this method to modify the default behavior when loading uris.
       * @param context The context when loading the asset
       * @param property The glTF property associated with the uri
       * @param uri The uri to load
       * @returns A promise that resolves with the loaded data when the load is complete or null if not handled
       */
      _loadUriAsync?(context: string, property: IProperty, uri: string): BABYLON.Nullable<Promise<ArrayBufferView>>;
      /**
       * Define this method to modify the default behavior when loading buffer views.
       * @param context The context when loading the asset
       * @param bufferView The glTF buffer view property
       * @returns A promise that resolves with the loaded data when the load is complete or null if not handled
       */
      loadBufferViewAsync?(context: string, bufferView: IBufferView): BABYLON.Nullable<Promise<ArrayBufferView>>;
      /**
       * Define this method to modify the default behavior when loading buffers.
       * @param context The context when loading the asset
       * @param buffer The glTF buffer property
       * @param byteOffset The byte offset to load
       * @param byteLength The byte length to load
       * @returns A promise that resolves with the loaded data when the load is complete or null if not handled
       */
      loadBufferAsync?(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): BABYLON.Nullable<Promise<ArrayBufferView>>;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import type * as GLTF2 from 'babylonjs-gltf2interface';
  /**
   * Loader interface with an index field.
   */
  export interface IArrayItem {
      /**
       * The index of this item in the array.
       */
      index: number;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IAccessor extends GLTF2.IAccessor, IArrayItem {
      /** @internal */
      _data?: Promise<ArrayBufferView>;
      /** @internal */
      _babylonVertexBuffer?: {
          [kind: string]: Promise<BABYLON.VertexBuffer>;
      };
  }
  /**
   * Loader interface with additional members.
   */
  export interface IAnimationChannel extends GLTF2.IAnimationChannel, IArrayItem {
  }
  /** @internal */
  export interface _IAnimationSamplerData {
      /** @internal */
      input: Float32Array;
      /** @internal */
      interpolation: GLTF2.AnimationSamplerInterpolation;
      /** @internal */
      output: Float32Array;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IAnimationSampler extends GLTF2.IAnimationSampler, IArrayItem {
      /** @internal */
      _data?: Promise<_IAnimationSamplerData>;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IAnimation extends GLTF2.IAnimation, IArrayItem {
      /** @internal */
      channels: IAnimationChannel[];
      /** @internal */
      samplers: IAnimationSampler[];
      /** @internal */
      _babylonAnimationGroup?: BABYLON.AnimationGroup;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IBuffer extends GLTF2.IBuffer, IArrayItem {
      /** @internal */
      _data?: Promise<ArrayBufferView>;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IBufferView extends GLTF2.IBufferView, IArrayItem {
      /** @internal */
      _data?: Promise<ArrayBufferView>;
      /** @internal */
      _babylonBuffer?: Promise<BABYLON.Buffer>;
  }
  /**
   * Loader interface with additional members.
   */
  export interface ICamera extends GLTF2.ICamera, IArrayItem {
      /** @internal */
      _babylonCamera?: BABYLON.Camera;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IImage extends GLTF2.IImage, IArrayItem {
      /** @internal */
      _data?: Promise<ArrayBufferView>;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMaterialNormalTextureInfo extends GLTF2.IMaterialNormalTextureInfo, ITextureInfo {
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMaterialOcclusionTextureInfo extends GLTF2.IMaterialOcclusionTextureInfo, ITextureInfo {
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMaterialPbrMetallicRoughness extends GLTF2.IMaterialPbrMetallicRoughness {
      /** @internal */
      baseColorTexture?: ITextureInfo;
      /** @internal */
      metallicRoughnessTexture?: ITextureInfo;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMaterial extends GLTF2.IMaterial, IArrayItem {
      /** @internal */
      pbrMetallicRoughness?: IMaterialPbrMetallicRoughness;
      /** @internal */
      normalTexture?: IMaterialNormalTextureInfo;
      /** @internal */
      occlusionTexture?: IMaterialOcclusionTextureInfo;
      /** @internal */
      emissiveTexture?: ITextureInfo;
      /** @internal */
      _data?: {
          [babylonDrawMode: number]: {
              babylonMaterial: BABYLON.Material;
              babylonMeshes: BABYLON.AbstractMesh[];
              promise: Promise<void>;
          };
      };
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMesh extends GLTF2.IMesh, IArrayItem {
      /** @internal */
      primitives: IMeshPrimitive[];
  }
  /**
   * Loader interface with additional members.
   */
  export interface IMeshPrimitive extends GLTF2.IMeshPrimitive, IArrayItem {
      /** @internal */
      _instanceData?: {
          babylonSourceMesh: BABYLON.Mesh;
          promise: Promise<any>;
      };
  }
  /**
   * Loader interface with additional members.
   */
  export interface INode extends GLTF2.INode, IArrayItem {
      /** @internal */
      parent?: INode;
      /** @internal */
      _babylonTransformNode?: BABYLON.TransformNode;
      /** @internal */
      _babylonTransformNodeForSkin?: BABYLON.TransformNode;
      /** @internal */
      _primitiveBabylonMeshes?: BABYLON.AbstractMesh[];
      /** @internal */
      _numMorphTargets?: number;
  }
  /** @internal */
  export interface _ISamplerData {
      /** @internal */
      noMipMaps: boolean;
      /** @internal */
      samplingMode: number;
      /** @internal */
      wrapU: number;
      /** @internal */
      wrapV: number;
  }
  /**
   * Loader interface with additional members.
   */
  export interface ISampler extends GLTF2.ISampler, IArrayItem {
      /** @internal */
      _data?: _ISamplerData;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IScene extends GLTF2.IScene, IArrayItem {
  }
  /**
   * Loader interface with additional members.
   */
  export interface ISkin extends GLTF2.ISkin, IArrayItem {
      /** @internal */
      _data?: {
          babylonSkeleton: BABYLON.Skeleton;
          promise: Promise<void>;
      };
  }
  /**
   * Loader interface with additional members.
   */
  export interface ITexture extends GLTF2.ITexture, IArrayItem {
      /** @internal */
      _textureInfo: ITextureInfo;
  }
  /**
   * Loader interface with additional members.
   */
  export interface ITextureInfo extends GLTF2.ITextureInfo {
      /** false or undefined if the texture holds color data (true if data are roughness, normal, ...) */
      nonColorData?: boolean;
  }
  /**
   * Loader interface with additional members.
   */
  export interface IGLTF extends GLTF2.IGLTF {
      /** @internal */
      accessors?: IAccessor[];
      /** @internal */
      animations?: IAnimation[];
      /** @internal */
      buffers?: IBuffer[];
      /** @internal */
      bufferViews?: IBufferView[];
      /** @internal */
      cameras?: ICamera[];
      /** @internal */
      images?: IImage[];
      /** @internal */
      materials?: IMaterial[];
      /** @internal */
      meshes?: IMesh[];
      /** @internal */
      nodes?: INode[];
      /** @internal */
      samplers?: ISampler[];
      /** @internal */
      scenes?: IScene[];
      /** @internal */
      skins?: ISkin[];
      /** @internal */
      textures?: ITexture[];
  }
  /**
   * Loader interface with additional members.
   */
  export interface IKHRLightsPunctual_Light extends GLTF2.IKHRLightsPunctual_Light, IArrayItem {
      /** @hidden */
      _babylonLight?: BABYLON.Light;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoader';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderExtension';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/glTFLoaderInterfaces';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/Extensions/index';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import type * as GLTF2 from 'babylonjs-gltf2interface';
  export interface IFileRequest {
      /**
       * Raised when the request is complete (success or error).
       */
      onCompleteObservable: BABYLON.Observable<IFileRequest>;
      /**
       * Aborts the request for a file.
       */
      abort: () => void;
  }
  /**
   * Mode that determines the coordinate system to use.
   */
  export enum GLTFLoaderCoordinateSystemMode {
      /**
       * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.
       */
      AUTO = 0,
      /**
       * Sets the useRightHandedSystem flag on the scene.
       */
      FORCE_RIGHT_HANDED = 1
  }
  /**
   * Mode that determines what animations will start.
   */
  export enum GLTFLoaderAnimationStartMode {
      /**
       * No animation will start.
       */
      NONE = 0,
      /**
       * The first animation will start.
       */
      FIRST = 1,
      /**
       * All animations will start.
       */
      ALL = 2
  }
  /**
   * Interface that contains the data for the glTF asset.
   */
  export interface IGLTFLoaderData {
      /**
       * The object that represents the glTF JSON.
       */
      json: Object;
      /**
       * The BIN chunk of a binary glTF.
       */
      bin: BABYLON.Nullable<BABYLON.IDataBuffer>;
  }
  /**
   * Interface for extending the loader.
   */
  export interface IGLTFLoaderExtension {
      /**
       * The name of this extension.
       */
      readonly name: string;
      /**
       * Defines whether this extension is enabled.
       */
      enabled: boolean;
      /**
       * Defines the order of this extension.
       * The loader sorts the extensions using these values when loading.
       */
      order?: number;
  }
  /**
   * Loader state.
   */
  export enum GLTFLoaderState {
      /**
       * The asset is loading.
       */
      LOADING = 0,
      /**
       * The asset is ready for rendering.
       */
      READY = 1,
      /**
       * The asset is completely loaded.
       */
      COMPLETE = 2
  }
  /** @internal */
  export interface IGLTFLoader extends BABYLON.IDisposable {
      importMeshAsync: (meshesNames: any, scene: BABYLON.Scene, container: BABYLON.Nullable<BABYLON.AssetContainer>, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<BABYLON.ISceneLoaderAsyncResult>;
      loadAsync: (scene: BABYLON.Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;
  }
  /**
   * File loader for loading glTF files into a scene.
   */
  export class GLTFFileLoader implements BABYLON.IDisposable, BABYLON.ISceneLoaderPluginAsync, BABYLON.ISceneLoaderPluginFactory {
      /** @internal */
      static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;
      /** @internal */
      static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;
      /**
       * Raised when the asset has been parsed
       */
      onParsedObservable: BABYLON.Observable<IGLTFLoaderData>;
      private _onParsedObserver;
      /**
       * Raised when the asset has been parsed
       */
      set onParsed(callback: (loaderData: IGLTFLoaderData) => void);
      /**
       * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.
       * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.
       * Defaults to true.
       * @internal
       */
      static IncrementalLoading: boolean;
      /**
       * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.
       * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.
       * @internal
       */
      static HomogeneousCoordinates: boolean;
      /**
       * The coordinate system mode. Defaults to AUTO.
       */
      coordinateSystemMode: GLTFLoaderCoordinateSystemMode;
      /**
       * The animation start mode. Defaults to FIRST.
       */
      animationStartMode: GLTFLoaderAnimationStartMode;
      /**
       * Defines if the loader should compile materials before raising the success callback. Defaults to false.
       */
      compileMaterials: boolean;
      /**
       * Defines if the loader should also compile materials with clip planes. Defaults to false.
       */
      useClipPlane: boolean;
      /**
       * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.
       */
      compileShadowGenerators: boolean;
      /**
       * Defines if the Alpha blended materials are only applied as coverage.
       * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.
       * If true, no extra effects are applied to transparent pixels.
       */
      transparencyAsCoverage: boolean;
      /**
       * Defines if the loader should use range requests when load binary glTF files from HTTP.
       * Enabling will disable offline support and glTF validator.
       * Defaults to false.
       */
      useRangeRequests: boolean;
      /**
       * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.
       */
      createInstances: boolean;
      /**
       * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.
       */
      alwaysComputeBoundingBox: boolean;
      /**
       * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.
       */
      loadAllMaterials: boolean;
      /**
       * If true, load only the materials defined in the file. Defaults to false.
       */
      loadOnlyMaterials: boolean;
      /**
       * If true, do not load any materials defined in the file. Defaults to false.
       */
      skipMaterials: boolean;
      /**
       * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.
       */
      useSRGBBuffers: boolean;
      /**
       * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.
       */
      targetFps: number;
      /**
       * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.
       * Set this to true if loading assets with invalid `skin.skeleton` values.
       */
      alwaysComputeSkeletonRootNode: boolean;
      /**
       * Function called before loading a url referenced by the asset.
       * @param url
       */
      preprocessUrlAsync: (url: string) => Promise<string>;
      /**
       * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.
       * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
       */
      readonly onMeshLoadedObservable: BABYLON.Observable<BABYLON.AbstractMesh>;
      private _onMeshLoadedObserver;
      /**
       * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
       * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
       */
      set onMeshLoaded(callback: (mesh: BABYLON.AbstractMesh) => void);
      /**
       * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh
       * @param node - the transform node that corresponds to the original glTF skin node used for animations
       * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes
       */
      readonly onSkinLoadedObservable: BABYLON.Observable<{
          node: BABYLON.TransformNode;
          skinnedNode: BABYLON.TransformNode;
      }>;
      /**
       * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.
       */
      readonly onTextureLoadedObservable: BABYLON.Observable<BABYLON.BaseTexture>;
      private _onTextureLoadedObserver;
      /**
       * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
       */
      set onTextureLoaded(callback: (texture: BABYLON.BaseTexture) => void);
      /**
       * Observable raised when the loader creates a material after parsing the glTF properties of the material.
       */
      readonly onMaterialLoadedObservable: BABYLON.Observable<BABYLON.Material>;
      private _onMaterialLoadedObserver;
      /**
       * Callback raised when the loader creates a material after parsing the glTF properties of the material.
       */
      set onMaterialLoaded(callback: (material: BABYLON.Material) => void);
      /**
       * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.
       */
      readonly onCameraLoadedObservable: BABYLON.Observable<BABYLON.Camera>;
      private _onCameraLoadedObserver;
      /**
       * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
       */
      set onCameraLoaded(callback: (camera: BABYLON.Camera) => void);
      /**
       * Observable raised when the asset is completely loaded, immediately before the loader is disposed.
       * For assets with LODs, raised when all of the LODs are complete.
       * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
       */
      readonly onCompleteObservable: BABYLON.Observable<void>;
      private _onCompleteObserver;
      /**
       * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
       * For assets with LODs, raised when all of the LODs are complete.
       * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
       */
      set onComplete(callback: () => void);
      /**
       * Observable raised when an error occurs.
       */
      readonly onErrorObservable: BABYLON.Observable<any>;
      private _onErrorObserver;
      /**
       * Callback raised when an error occurs.
       */
      set onError(callback: (reason: any) => void);
      /**
       * Observable raised after the loader is disposed.
       */
      readonly onDisposeObservable: BABYLON.Observable<void>;
      private _onDisposeObserver;
      /**
       * Callback raised after the loader is disposed.
       */
      set onDispose(callback: () => void);
      /**
       * Observable raised after a loader extension is created.
       * Set additional options for a loader extension in this event.
       */
      readonly onExtensionLoadedObservable: BABYLON.Observable<IGLTFLoaderExtension>;
      private _onExtensionLoadedObserver;
      /**
       * Callback raised after a loader extension is created.
       */
      set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void);
      /**
       * Defines if the loader logging is enabled.
       */
      get loggingEnabled(): boolean;
      set loggingEnabled(value: boolean);
      /**
       * Defines if the loader should capture performance counters.
       */
      get capturePerformanceCounters(): boolean;
      set capturePerformanceCounters(value: boolean);
      /**
       * Defines if the loader should validate the asset.
       */
      validate: boolean;
      /**
       * Observable raised after validation when validate is set to true. The event data is the result of the validation.
       */
      readonly onValidatedObservable: BABYLON.Observable<GLTF2.IGLTFValidationResults>;
      private _onValidatedObserver;
      /**
       * Callback raised after a loader extension is created.
       */
      set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void);
      private _loader;
      private _state;
      private _progressCallback?;
      private _requests;
      private static _MagicBase64Encoded;
      /**
       * Name of the loader ("gltf")
       */
      name: string;
      /** @internal */
      extensions: BABYLON.ISceneLoaderPluginExtensions;
      /**
       * Disposes the loader, releases resources during load, and cancels any outstanding requests.
       */
      dispose(): void;
      /**
       * @internal
       */
      loadFile(scene: BABYLON.Scene, fileOrUrl: File | string | ArrayBufferView, rootUrl: string, onSuccess: (data: any, responseURL?: string) => void, onProgress?: (ev: BABYLON.ISceneLoaderProgressEvent) => void, useArrayBuffer?: boolean, onError?: (request?: BABYLON.WebRequest, exception?: BABYLON.LoadFileError) => void, name?: string): BABYLON.Nullable<IFileRequest>;
      /**
       * @internal
       */
      _loadBinary(scene: BABYLON.Scene, data: ArrayBufferView, rootUrl: string, onSuccess: (data: any, responseURL?: string) => void, onError?: (request?: BABYLON.WebRequest, exception?: BABYLON.LoadFileError) => void, fileName?: string): void;
      /**
       * @internal
       */
      importMeshAsync(meshesNames: any, scene: BABYLON.Scene, data: any, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string): Promise<BABYLON.ISceneLoaderAsyncResult>;
      /**
       * @internal
       */
      loadAsync(scene: BABYLON.Scene, data: any, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;
      /**
       * @internal
       */
      loadAssetContainerAsync(scene: BABYLON.Scene, data: any, rootUrl: string, onProgress?: (event: BABYLON.ISceneLoaderProgressEvent) => void, fileName?: string): Promise<BABYLON.AssetContainer>;
      /**
       * @internal
       */
      canDirectLoad(data: string): boolean;
      /**
       * @internal
       */
      directLoad(scene: BABYLON.Scene, data: string): Promise<any>;
      /**
       * The callback that allows custom handling of the root url based on the response url.
       * @param rootUrl the original root url
       * @param responseURL the response url if available
       * @returns the new root url
       */
      rewriteRootURL?(rootUrl: string, responseURL?: string): string;
      /** @internal */
      createPlugin(): BABYLON.ISceneLoaderPlugin | BABYLON.ISceneLoaderPluginAsync;
      /**
       * The loader state or null if the loader is not active.
       */
      get loaderState(): BABYLON.Nullable<GLTFLoaderState>;
      /**
       * Observable raised when the loader state changes.
       */
      onLoaderStateChangedObservable: BABYLON.Observable<GLTFLoaderState>;
      /**
       * Returns a promise that resolves when the asset is completely loaded.
       * @returns a promise that resolves when the asset is completely loaded.
       */
      whenCompleteAsync(): Promise<void>;
      /**
       * @internal
       */
      _setState(state: GLTFLoaderState): void;
      /**
       * @internal
       */
      _loadFile(scene: BABYLON.Scene, fileOrUrl: File | string, onSuccess: (data: string | ArrayBuffer) => void, useArrayBuffer?: boolean, onError?: (request?: BABYLON.WebRequest) => void, onOpened?: (request: BABYLON.WebRequest) => void): IFileRequest;
      private _onProgress;
      private _validate;
      private _getLoader;
      private _parseJson;
      private _unpackBinaryAsync;
      private _unpackBinaryV1Async;
      private _unpackBinaryV2Async;
      private static _parseVersion;
      private static _compareVersion;
      private static readonly _logSpaces;
      private _logIndentLevel;
      private _loggingEnabled;
      /** @internal */
      _log: (message: string) => void;
      /**
       * @internal
       */
      _logOpen(message: string): void;
      /** @internal */
      _logClose(): void;
      private _logEnabled;
      private _logDisabled;
      private _capturePerformanceCounters;
      /** @internal */
      _startPerformanceCounter: (counterName: string) => void;
      /** @internal */
      _endPerformanceCounter: (counterName: string) => void;
      private _startPerformanceCounterEnabled;
      private _startPerformanceCounterDisabled;
      private _endPerformanceCounterEnabled;
      private _endPerformanceCounterDisabled;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFValidation' {
  /// <reference types="node_modules/babylonjs-gltf2interface/babylon.glTF2Interface" />
  import type * as GLTF2 from 'babylonjs-gltf2interface';
  /**
   * Configuration for glTF validation
   */
  export interface IGLTFValidationConfiguration {
      /**
       * The url of the glTF validator.
       */
      url: string;
  }
  /**
   * glTF validation
   */
  export class GLTFValidation {
      /**
       * The configuration. Defaults to `{ url: 'https://preview.babylonjs.com/gltf_validator.js' }`.
       */
      static Configuration: IGLTFValidationConfiguration;
      private static _LoadScriptPromise;
      /**
       * Validate a glTF asset using the glTF-Validator.
       * @param data The JSON of a glTF or the array buffer of a binary glTF
       * @param rootUrl The root url for the glTF
       * @param fileName The file name for the glTF
       * @param getExternalResource The callback to get external resources for the glTF validator
       * @returns A promise that resolves with the glTF validation results once complete
       */
      static ValidateAsync(data: string | ArrayBufferView, rootUrl: string, fileName: string, getExternalResource: (uri: string) => Promise<ArrayBuffer>): Promise<GLTF2.IGLTFValidationResults>;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFFileLoader';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/glTFValidation';
  import * as GLTF1 from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/1.0/index';
  import * as GLTF2 from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/2.0/index';
  export { GLTF1, GLTF2 };

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/index' {
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/gLTF/index';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/OBJ/index';
  export * from '@yodaos-jsar/dom/src/living/helpers/babylonjs/loaders/STL/index';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/patches/draco_decoder_gltf' {
  export = DracoDecoderModule;
  function DracoDecoderModule(DracoDecoderModule?: {}): any;
  namespace DracoDecoderModule {
      export { DracoDecoderModule };
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/patches/draco_decoder_gltf.wasm' {
  const _exports: {
      readonly byteLength: number;
      slice(begin: number, end?: number): ArrayBuffer;
      readonly [Symbol.toStringTag]: string;
  };
  export = _exports;

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/patches/index' {
  import './rewrite-meshopt-compression';
  import './rewrite-draco-compression';

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/patches/rewrite-draco-compression' {
  function decodeMesh(decoderModule: any, dataView: any, attributes: any, onIndicesData: any, onAttributeData: any, dividers: any): void;
  const decoderModulePending: Promise<any>;

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/patches/rewrite-meshopt-compression' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/babylonjs/tags' {
  /**
   * This tag is used to identify the material that is created by the scss.
   */
  export const MATERIAL_BY_SCSS = "material-scss";

}
declare module '@yodaos-jsar/dom/src/living/helpers/create-element' {
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function getHTMLElementInterface(name: string): any;
  export function getSVGInterface(name: string): any;
  export function getValidTagNames(namespace: string, name: string): any;
  export function createElement(document: SpatialDocumentImpl, localName: string, namespace: string, prefix?: string, isValue?: boolean, synchronousCE?: boolean): any;
  export function internalCreateElementNSSteps(document: SpatialDocumentImpl, namespace: string, qualifiedName: string, options: any): any;

}
declare module '@yodaos-jsar/dom/src/living/helpers/custom-elements' {
  import { CustomElementDefinition } from '@yodaos-jsar/dom/src/living/custom-elements/CustomElementRegistry';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  class CEReactionsStack {
      private _stack;
      backupElementQueue: Array<any>;
      processingBackupElementQueue: boolean;
      push(elementQueue: any): void;
      pop(): any;
      isEmpty(): boolean;
      get currentElementQueue(): any;
  }
  const customElementReactionsStack: CEReactionsStack;
  function ceReactionsPreSteps(): void;
  function ceReactionsPostSteps(): void;
  function isValidCustomElementName(name: string): boolean;
  function upgradeElement(definition: CustomElementDefinition, element: ElementImpl): void;
  function tryUpgradeElement(element: any): void;
  function lookupCEDefinition(document: SpatialDocumentImpl, namespace: string, localName: string, isValue: any): CustomElementDefinition;
  function invokeCEReactions(elementQueue: ElementImpl[]): void;
  function enqueueCECallbackReaction(element: ElementImpl, callbackName: string, args: any): void;
  function enqueueCEUpgradeReaction(element: any, definition: any): void;
  export { customElementReactionsStack, ceReactionsPreSteps, ceReactionsPostSteps, isValidCustomElementName, upgradeElement, tryUpgradeElement, lookupCEDefinition, enqueueCEUpgradeReaction, enqueueCECallbackReaction, invokeCEReactions, };

}
declare module '@yodaos-jsar/dom/src/living/helpers/document-base-url' {
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function documentBaseURL(document: SpatialDocumentImpl): URL;
  export function documentBaseURLSerialized(document: SpatialDocumentImpl): string;
  export function fallbackBaseURL(document: SpatialDocumentImpl): URL;
  export function parseURLToResultingURLRecord(url: string, document: SpatialDocumentImpl): URL;

}
declare module '@yodaos-jsar/dom/src/living/helpers/gui2d/control' {
  import * as taffy from '@bindings/taffy';
  import { CSSStyleDeclaration } from 'cssstyle';
  import DOMRectReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRectReadOnly';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  import { ShadowRootImpl } from '@yodaos-jsar/dom/src/living/nodes/ShadowRoot';
  import type ImageDataImpl from '@yodaos-jsar/dom/src/living/image/ImageData';
  type LengthPercentageDimension = string | number;
  type LayoutStyle = Partial<{
      display: taffy.Display;
      position: taffy.Position;
      aspectRatio: number;
      width: LengthPercentageDimension | 'auto';
      height: LengthPercentageDimension | 'auto';
      minWidth: LengthPercentageDimension | 'auto';
      maxWidth: LengthPercentageDimension | 'auto';
      minHeight: LengthPercentageDimension | 'auto';
      maxHeight: LengthPercentageDimension | 'auto';
      insetLeft: LengthPercentageDimension | 'auto';
      insetRight: LengthPercentageDimension | 'auto';
      insetTop: LengthPercentageDimension | 'auto';
      insetBottom: LengthPercentageDimension | 'auto';
      marginLeft: LengthPercentageDimension | 'auto';
      marginRight: LengthPercentageDimension | 'auto';
      marginTop: LengthPercentageDimension | 'auto';
      marginBottom: LengthPercentageDimension | 'auto';
      paddingLeft: LengthPercentageDimension;
      paddingRight: LengthPercentageDimension;
      paddingTop: LengthPercentageDimension;
      paddingBottom: LengthPercentageDimension;
      borderLeft: LengthPercentageDimension;
      borderRight: LengthPercentageDimension;
      borderTop: LengthPercentageDimension;
      borderBottom: LengthPercentageDimension;
      flexDirection: taffy.FlexDirection;
      flexWrap: taffy.FlexWrap;
      flexGrow: number;
      flexShrink: number;
      flexBasis: LengthPercentageDimension | 'auto';
      alignItems: taffy.AlignItems;
      alignSelf: taffy.AlignSelf;
      alignContent: taffy.AlignContent;
      justifyItems: taffy.JustifyItems;
      justifySelf: taffy.JustifySelf;
      justifyContent: taffy.JustifyContent;
      gapWidth: LengthPercentageDimension;
      gapHeight: LengthPercentageDimension;
      gridAutoFlow: taffy.GridAutoFlow;
  }>;
  export class Control2D {
      private _allocator;
      private _element;
      /**
       * The layout node to be used for the HTML layout.
       */
      layoutNode: taffy.Node;
      /**
       * The layout style will be passed to layout node.
       */
      layoutStyle: LayoutStyle;
      /**
       * The rectangle descriptor of the last rendering.
       */
      private _lastRect;
      private _lastCursor;
      private _isCursorInside;
      private _renderingContext;
      private _overwriteHeight;
      private _overwriteWidth;
      private _imageData;
      private _isDirty;
      constructor(_allocator: taffy.Allocator, _element: HTMLContentElement | ShadowRootImpl);
      init(defaultStyle?: LayoutStyle): void;
      setRenderingContext(renderingContext: CanvasRenderingContext2D): void;
      setImageData(data: ImageDataImpl): void;
      addChild(child: Control2D): void;
      removeChild(child: Control2D): void;
      isDirty(): boolean;
      dispose(): void;
      get _style(): CSSStyleDeclaration | null;
      private _ownInnerText;
      private _parseLengthStr;
      private _initializeLayoutStyle;
      private _updateRectSize;
      updateLayoutStyle(): boolean;
      /**
       * Render the controller itself.
       *
       * @internal
       * @param rect
       * @param base
       * @returns if the rendering is successful.
       */
      render(rect: DOMRect, base: DOMRectReadOnly): void;
      /**
       * Fix the rect size by text.
       */
      private _fixSizeByText;
      private _getBorderRenderingContext;
      private get _fontSize();
      private _getTextConfig;
      /**
       * This measures a given text in single-line mode and returns the width and height of the text block.
       */
      private _measureText;
      /**
       * If this node owns an inner text.
       */
      private _isElementOwnsInnerText;
      /**
       * Render the inner text in this control.
       */
      _renderInnerText(context: CanvasRenderingContext2D, rect: DOMRectReadOnlyImpl): void;
      /**
       * Render the rectangle with background color in this control.
       */
      private _renderRect;
      private _renderBorders;
      private _updateBorderStyle;
      private _renderImageIfExists;
      containsPoint(x: number, y: number): boolean;
      /**
       * Process the element picking.
       *
       * @internal
       * @param x
       * @param y
       * @param _type
       */
      processPicking(x: number, y: number, _type?: number): void;
      /**
       * Process the pointer events.
       *
       * @internal
       * @param x
       * @param y
       * @param type
       * @returns
       */
      processPointerEvent(x: number, y: number, type: number): boolean;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/internal-constants' {
  import SymbolTree from 'symbol-tree';
  export const cloningSteps: unique symbol;
  export const domSymbolTree: SymbolTree<any>;

}
declare module '@yodaos-jsar/dom/src/living/helpers/iterable-weak-set' {
  export default class IterableWeakSet<T extends WeakKey> {
      _refSet: Set<WeakRef<T>>;
      _refMap: Map<T, WeakRef<T>>;
      _finalizationRegistry: FinalizationRegistry<unknown>;
      add(value: T): this;
      delete(value: T): boolean;
      has(value: T): boolean;
      [Symbol.iterator](): Generator<T, void, unknown>;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/mutation-observers' {
  export const MUTATION_TYPE: {
      ATTRIBUTES: string;
      CHARACTER_DATA: string;
      CHILD_LIST: string;
  };
  export const signalSlotList: Array<EventTarget>;
  export function queueMutationRecord(type: any, target: any, name: any, namespace: any, oldValue: any, addedNodes: any, removedNodes: any, previousSibling: any, nextSibling: any): void;
  export function queueTreeMutationRecord(target: any, addedNodes: any, removedNodes: any, previousSibling: any, nextSibling: any): void;
  export function queueAttributeMutationRecord(target: any, name: any, namespace: any, oldValue: any): void;
  export function queueMutationObserverMicrotask(): void;

}
declare module '@yodaos-jsar/dom/src/living/helpers/namespaces' {
  export const HTML_NS = "http://www.w3.org/1999/xhtml";
  export const MATHML_NS = "http://www.w3.org/1998/Math/MathML";
  export const SVG_NS = "http://www.w3.org/2000/svg";
  export const XLINK_NS = "http://www.w3.org/1999/xlink";
  export const XML_NS = "http://www.w3.org/XML/1998/namespace";
  export const XMLNS_NS = "http://www.w3.org/2000/xmlns/";
  export const XSML_NS = "http://jsar.netlify.app/spec/xsml";

}
declare module '@yodaos-jsar/dom/src/living/helpers/node' {
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function nodeLength(node: Node): number;
  export function nodeRoot(node: Node): Node;
  export function isInclusiveAncestor(ancestorNode: Node, node: Node): boolean;
  export function isFollowing(nodeA: Node, nodeB: Node): boolean;
  export function clone(node: NodeImpl, document?: SpatialDocumentImpl, cloneChildren?: boolean): any;

}
declare module '@yodaos-jsar/dom/src/living/helpers/ordered-set' {
  export default class OrderedSet<T extends string> {
      _items: T[];
      get size(): number;
      isEmpty(): boolean;
      contains(item: T): boolean;
      append(item: T): void;
      prepend(item: T): void;
      replace(item: T, replacement: T): void;
      remove(...items: T[]): void;
      removePredicate(predicate: (item: T) => boolean): void;
      empty(): void;
      [Symbol.iterator](): IterableIterator<T>;
      keys(): IterableIterator<number>;
      get(index: number): T;
      some(predicate: (item: T) => boolean): boolean;
      serialize(): string;
      static parse(input: string): OrderedSet<string>;
  }

}
declare module '@yodaos-jsar/dom/src/living/helpers/runtime-script-errors' {
  import { NativeDocument } from 'src/impl-interfaces';
  export function reportException(hostObject: NativeDocument, error: Error, filenameHint?: string): void;

}
declare module '@yodaos-jsar/dom/src/living/helpers/scripting-types' {
  export type ResolveContext = {
      conditions: string[];
      importAttributes: object;
      parentURL: string | undefined;
  };
  export type LoadContext = {
      conditions: string[];
      importAttributes: object;
      format: string;
  };
  export type ResolveResult = {
      format?: string | null | undefined;
      importAttributes?: object | undefined;
      shortCircuit?: boolean | undefined;
      url: string;
  };
  export type LoadResult = {
      format: 'json' | 'binary' | 'module';
      shortCircuit?: boolean;
      source: string | object | ArrayBuffer | Uint8Array;
  };
  export type NextResolve = (specifier: string, context: ResolveContext) => ResolveResult;
  export type NextLoad = (url: string, context: LoadContext) => LoadResult;
  export type LoaderOnInitialize = (data: any) => void;
  export type LoaderOnResolve = (specifier: string, context: ResolveContext, nextResolve: NextResolve) => ResolveResult;
  export type LoaderOnLoad = (url: string, context: LoadContext, nextLoad: NextLoad) => LoadResult;
  export type CustomLoaderHooks = {
      initialize?: LoaderOnInitialize;
      resolve?: LoaderOnResolve;
      load?: LoaderOnLoad;
  };
  export function getUrlFromResolveResult(resolved: ResolveResult): string;

}
declare module '@yodaos-jsar/dom/src/living/helpers/selectors' {
  import nwsapi from 'nwsapi';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import ParentNodeImpl from '@yodaos-jsar/dom/src/living/nodes/ParentNode';
  export function matchesDontThrow(elImpl: ElementImpl, selector: string): boolean;
  export function addNwsapi(parentNode: ParentNodeImpl): nwsapi.NWSAPI;

}
declare module '@yodaos-jsar/dom/src/living/helpers/shadow-dom' {
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import { ShadowRootImpl } from '@yodaos-jsar/dom/src/living/nodes/ShadowRoot';
  export function isValidHostElementName(name: string): boolean;
  export function isNode(nodeImpl: NodeImpl): boolean;
  export function isShadowRoot(nodeImpl: NodeImpl): nodeImpl is ShadowRootImpl;
  export function isSlotable(nodeImpl: NodeImpl): boolean;
  export function isSlot(nodeImpl: NodeImpl): boolean;
  export function isShadowInclusiveAncestor(ancestor: any, node: any): boolean;
  export function retarget(a: NodeImpl, b: NodeImpl): NodeImpl;
  export function getEventTargetParent(eventTarget: any, event: any): any;
  export function shadowIncludingRoot(node: NodeImpl): NodeImpl;
  export function assignSlot(slotable: any): void;
  export function assignSlotable(slot: any): void;
  export function assignSlotableForTree(root: any): void;
  export function findSlotable(slot: any): any[];
  export function findFlattenedSlotables(slot: any): any[];
  export function findSlot(slotable: any, openFlag?: any): any;
  export function signalSlotChange(slot: any): void;
  export function shadowIncludingInclusiveDescendantsIterator(node: any): any;
  export function shadowIncludingDescendantsIterator(node: any): Generator<any, void, any>;

}
declare module '@yodaos-jsar/dom/src/living/helpers/spatial-animations' {
  import CSSSpatialKeyframesRule from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialKeyframesRule';
  import type { PropertyValue } from '@yodaos-jsar/dom/src/living/cssom/parsers/index';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export type SpatialAnimationKeyframe = {
      offset?: number;
      values: {
          [property: string]: PropertyValue;
      };
  };
  export type SpatialAnimationKeyframesData = {
      propertyNames: string[];
      keyframes: SpatialAnimationKeyframe[];
  };
  export function createKeyframesData(keyframesRule: CSSSpatialKeyframesRule): SpatialAnimationKeyframesData;
  type AnimationInit = {
      fps: number;
      duration: number;
      iterationCount: number | 'infinite';
  };
  export function createSpatialAnimation(name: string, sourceStyleRule: CSSSpatialKeyframesRule, element: SpatialElement, init?: Partial<AnimationInit>): void;
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/spatial-css-parser' {
  /**
   * This file is an extension to the `css` parser with supporting for Spatial CSS, for example
   *
   * - add supports for these at-rules: @material @texture
   */
  import css, { parse, type Node as CSSNode, type Declaration as CSSDeclaration, type Comment as CSSComment, type StyleRules } from 'css';
  export { css, };
  export function isRule(node: CSSNode): node is css.Rule;
  export function isAtKeyframes(node: CSSNode): node is css.KeyFrames;
  export function isAtImport(node: CSSNode): node is css.Import;
  export function isAtMaterial(node: CSSNode): node is AtMaterial;
  export function isAtTexture(node: CSSNode): node is AtTexture;
  export function isComment(node: CSSNode): node is css.Comment;
  export function noParsingErrors(stylesheet: StyleRules): boolean;
  interface NamedAtRule<T> extends CSSNode {
  }
  class NamedAtRule<T extends NamedAtRule<T>> implements NamedAtRule<T> {
      protected _name: string;
      protected _nameRe: RegExp;
      protected _declarations: Array<CSSDeclaration | CSSComment> | undefined;
      protected static _canParse(node: css.Rule, type: string): boolean;
      protected static _createFromRule<U extends NamedAtRule<U>>(ctor: new () => U, rule: css.Rule): U;
      constructor(type: string);
      get name(): string;
      get declarations(): Array<CSSDeclaration | CSSComment> | undefined;
      protected _parse(rule: css.Rule): {
          name?: string;
      };
  }
  export class AtTexture extends NamedAtRule<AtTexture> {
      private static _type;
      static canParse(node: css.Rule): boolean;
      static createFromRule(rule: css.Rule): AtTexture;
      constructor();
  }
  export class AtMaterial extends NamedAtRule<AtMaterial> {
      private static _type;
      static canParse(node: css.Rule): boolean;
      static createFromRule(rule: css.Rule): AtMaterial;
      constructor();
  }
  type SpatialCSSAtRule = AtTexture | AtMaterial;
  export const parseClassicCss: typeof css.parse;
  export function parseSpatialCss(...args: Parameters<typeof parse>): {
      type: string;
      position: {
          start?: css.Position;
          end?: css.Position;
          source?: string;
          content?: string;
      };
      parent: css.Node;
      stylesheet: {
          parsingErrors: css.ParserError[];
          rules: (css.Rule | css.Comment | css.AtRule | SpatialCSSAtRule)[];
      };
  };
  type ReturnTypeOfParser<T extends (cssText: string, options: Parameters<typeof parse>[1]) => any> = ReturnType<T> & {
      cssText: string;
      getCssText(node: css.Node): string;
  };
  export function parseCss(cssText: string, options: Parameters<typeof parse>[1], type: 'spatial'): ReturnTypeOfParser<typeof parseSpatialCss>;
  export function parseCss(cssText: string, options: Parameters<typeof parse>[1], type: 'classic'): ReturnTypeOfParser<typeof parse>;
  export function parseCss(cssText: string, options: Parameters<typeof parse>[1], type: unknown): ReturnTypeOfParser<typeof parseSpatialCss> | ReturnTypeOfParser<typeof parse>;

}
declare module '@yodaos-jsar/dom/src/living/helpers/strings' {
  export const asciiWhitespaceRe: RegExp;
  export const asciiLowercase: (s: string) => string;
  export const asciiUppercase: (s: string) => string;
  export const stripNewlines: (s: string) => string;
  export const stripLeadingAndTrailingASCIIWhitespace: (s: string) => string;
  export const stripAndCollapseASCIIWhitespace: (s: string) => string;
  export const isValidSimpleColor: (s: string) => boolean;
  export const asciiCaseInsensitiveMatch: (a: string, b: string) => boolean;
  export const parseInteger: (input: string) => number;
  export const parseNonNegativeInteger: (input: string) => number;
  export const isValidFloatingPointNumber: (str: string) => boolean;
  export const parseFloatingPointNumber: (str: string) => number;
  export const splitOnASCIIWhitespace: (str: string) => any[];
  export const splitOnCommas: (str: string) => any[];

}
declare module '@yodaos-jsar/dom/src/living/helpers/style-rules' {
  import type { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import type { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import type { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import type { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  export const propertiesWithResolvedValueImplemented: {
      __proto__: any;
      visibility: {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
      'pointer-events': {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
      'background-color': {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
      'border-block-start-color': {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
      'border-block-end-color': {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
      'outline-color': {
          inherited: boolean;
          initial: string;
          computedValue: string;
      };
  };
  export const invalidateStyleCache: (elementImpl: NodeImpl) => void;
  export function getDeclarationForElement(elementImpl: SpatialElement): CSSSpatialStyleDeclaration;
  export function getDeclarationForElement(elementImpl: HTMLElementImpl): CSSStyleDeclaration;
  export function getDeclarationForElement(elementImpl: ElementImpl): CSSStyleDeclaration;

}
declare module '@yodaos-jsar/dom/src/living/helpers/stylesheets' {
  import HTMLStyleElementImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLStyleElement';
  export function removeStylesheet(sheet: CSSStyleSheet, elementImpl: HTMLStyleElementImpl): void;
  export function createStylesheet(sheetText: string, elementImpl: HTMLStyleElementImpl, baseURL: URL): void;

}
declare module '@yodaos-jsar/dom/src/living/helpers/text' {
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export function childTextContent(node: NodeImpl): string;

}
declare module '@yodaos-jsar/dom/src/living/helpers/traversal' {
  export function closest(e: Element, localName: string, namespace?: string): Element;
  export function childrenByLocalName(parent: Node, localName: string, namespace?: string): any[];
  export function descendantsByLocalName(parent: Node, localName: string, namespace?: string): any[];
  export function childrenByLocalNames(parent: Node, localNamesSet: Set<string>, namespace?: string): any[];
  export function descendantsByLocalNames(parent: Node, localNamesSet: Set<string>, namespace?: string): any[];
  export function firstChildWithLocalName(parent: Node, localName: string, namespace?: string): any;
  export function firstChildWithLocalNames(parent: Node, localNamesSet: Set<string>, namespace?: string): any;
  export function firstDescendantWithLocalName(parent: Node, localName: string, namespace?: string): any;

}
declare module '@yodaos-jsar/dom/src/living/helpers/url' {
  /**
   * Checks if a given string can be parsed as a valid URL.
   * @param url - The string to be checked.
   * @returns True if the string can be parsed as a valid URL, false otherwise.
   */
  export function canParseURL(url: string): boolean;
  /**
   * Joins a subpath with a base path to create a new URL or file path.
   * If the base path is not an HTTP or HTTPS URL, it will be treated as a file path.
   * If the base path is an HTTP or HTTPS URL, the subpath will be appended to the URL's pathname.
   * @param sub - The subpath to join with the base path.
   * @param base - The base path to join with the subpath.
   * @returns The joined URL or file path.
   */
  export function join(sub: string, base: string): string;

}
declare module '@yodaos-jsar/dom/src/living/helpers/url.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/helpers/validate-names' {
  export function name(name: string): void;
  export function qname(qname: string): void;
  export function validateAndExtract(namespace: string | null, qualifiedName: string): {
      namespace: string;
      prefix: string;
      localName: string;
  };

}
declare module '@yodaos-jsar/dom/src/living/hr-time/Performance' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export class PerformanceImpl extends EventTarget implements Performance {
      private _nowAtTimeOrigin;
      timeOrigin: number;
      onresourcetimingbufferfull: (this: Performance, ev: Event) => any;
      constructor(_hostObject: NativeDocument, _args: any, privateData: {
          timeOrigin: number;
          nowAtTimeOrigin: number;
      });
      get eventCounts(): EventCounts;
      get navigation(): PerformanceNavigation;
      get timing(): PerformanceTiming;
      clearMarks(markName?: string): void;
      clearMeasures(measureName?: string): void;
      clearResourceTimings(): void;
      getEntries(): PerformanceEntryList;
      getEntriesByName(name: string, type?: string): PerformanceEntryList;
      getEntriesByType(type: string): PerformanceEntryList;
      mark(markName: string, markOptions?: PerformanceMarkOptions): PerformanceMark;
      measure(measureName: string, startOrMeasureOptions?: string | PerformanceMeasureOptions, endMark?: string): PerformanceMeasure;
      now(): number;
      setResourceTimingBufferSize(maxSize: number): void;
      toJSON(): {
          timeOrigin: number;
      };
  }

}
declare module '@yodaos-jsar/dom/src/living/image/ImageData' {
  /**
   * Represents image data used in the canvas element.
   */
  export default class ImageDataImpl implements ImageData {
      private _data;
      private _height;
      private _width;
      private _colorSpace;
      get data(): Uint8ClampedArray;
      get height(): number;
      get width(): number;
      get colorSpace(): PredefinedColorSpace;
      /**
       * Creates a new instance of ImageDataImpl.
       * @param data - The pixel data of the image.
       * @param sw - The width of the image.
       * @param sh - The height of the image.
       * @param settings - The settings for the image data.
       */
      constructor(data: unknown, sw: unknown, sh?: unknown, settings?: unknown);
  }

}
declare module '@yodaos-jsar/dom/src/living/image/ImageData.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/interfaces' {
  import type NamedNodeMapImpl from '@yodaos-jsar/dom/src/living/attributes/NamedNodeMap';
  import type { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import type { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import type { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  import type { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  import type HTMLStyleElementImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLStyleElement';
  import type HTMLScriptElementImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLScriptElement';
  import type HTMLImageElementImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLImageElement';
  import type { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import type ImageDataImpl from '@yodaos-jsar/dom/src/living/image/ImageData';
  import type NoiseImpl from '@yodaos-jsar/dom/src/living/crypto/Noise';
  import type DOMPointImpl from '@yodaos-jsar/dom/src/living/geometry/DOMPoint';
  import type DOMPointReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMPointReadOnly';
  import type DOMRectImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRect';
  import type DOMRectReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRectReadOnly';
  import type XRPoseImpl from '@yodaos-jsar/dom/src/living/xr/XRPose';
  import type XRRigidTransformImpl from '@yodaos-jsar/dom/src/living/xr/XRRigidTransform';
  import type XRSessionImpl from '@yodaos-jsar/dom/src/living/xr/XRSession';
  /**
   * To load all the implementations of the interfaces.
   *
   * __Why?__
   * In TypeScript, avoiding circular dependencies is a challenging task, requiring constant
   * attention to the order of dependencies and sometimes necessitating the splitting of modules
   * to ensure no circular dependencies. This is due to the fact that the TypeScript compiler (tsc)
   * resolves dependencies based on file order, leading to compromises in project directory design.
   *
   * To address this issue, we introduce the following method: leveraging dynamic `imports()` for
   * asynchronous loading of type instances. Subsequently, we use a synchronous function,
   * `getInterfaceWrapper`, to ensure the smooth functioning of the type system. This approach
   * ensures that, during both build time and runtime, the necessary precautions are taken to
   * guarantee correct invocation of the function when utilizing related interfaces.
   */
  export function loadImplementations(): Promise<void>;
  export function getInterfaceWrapper(name: 'NamedNodeMap'): typeof NamedNodeMapImpl;
  export function getInterfaceWrapper(name: 'Node'): typeof NodeImpl;
  export function getInterfaceWrapper(name: 'Element'): typeof ElementImpl;
  export function getInterfaceWrapper(name: 'HTMLElement'): typeof HTMLElementImpl;
  export function getInterfaceWrapper(name: 'HTMLContentElement'): typeof HTMLContentElement;
  export function getInterfaceWrapper(name: 'HTMLStyleElement'): typeof HTMLStyleElementImpl;
  export function getInterfaceWrapper(name: 'HTMLScriptElement'): typeof HTMLScriptElementImpl;
  export function getInterfaceWrapper(name: 'HTMLImageElement'): typeof HTMLImageElementImpl;
  export function getInterfaceWrapper(name: 'SpatialElement'): typeof SpatialElement;
  export function getInterfaceWrapper(name: 'Noise'): typeof NoiseImpl;
  export function getInterfaceWrapper(name: 'DOMPoint'): typeof DOMPointImpl;
  export function getInterfaceWrapper(name: 'DOMPointReadOnly'): typeof DOMPointReadOnlyImpl;
  export function getInterfaceWrapper(name: 'DOMRect'): typeof DOMRectImpl;
  export function getInterfaceWrapper(name: 'DOMRectReadOnly'): typeof DOMRectReadOnlyImpl;
  export function getInterfaceWrapper(name: 'ImageData'): typeof ImageDataImpl;
  export function getInterfaceWrapper(name: 'XRPose'): typeof XRPoseImpl;
  export function getInterfaceWrapper(name: 'XRRigidTransform'): typeof XRRigidTransformImpl;
  export function getInterfaceWrapper(name: 'XRSession'): typeof XRSessionImpl;
  export function getInterfaceWrapper(name: string): any;

}
declare module '@yodaos-jsar/dom/src/living/mutation-observer/MutationObserver' {
  export class MutationObserverImpl implements MutationObserver {
      _callback: MutationCallback;
      _nodeList: Node[];
      _recordQueue: any[];
      _id: number;
      constructor(globalObject: any, args: any);
      disconnect(): void;
      takeRecords(): MutationRecord[];
      observe(target: Node, options?: MutationObserverInit): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/mutation-observer/MutationRecord' {
  import { NodeListImpl } from '@yodaos-jsar/dom/src/living/nodes/NodeList';
  export class MutationRecordImpl implements MutationRecord {
      attributeName: string;
      attributeNamespace: string;
      nextSibling: Node;
      oldValue: string;
      previousSibling: Node;
      target: Node;
      type: MutationRecordType;
      _hostObject: any;
      _addedNodes: Node[];
      _removedNodes: Node[];
      constructor(hostObject: any, args: any, privateData: any);
      get addedNodes(): NodeListImpl<Node>;
      get removedNodes(): NodeListImpl<Node>;
  }

}
declare module '@yodaos-jsar/dom/src/living/named-properties-tracker' {
  interface ResolverFunction {
      (object: any, name: string, getValues: () => Set<any>): any;
  }
  export function create(object: any, objectProxy: any, resolverFunc: ResolverFunction): NamedPropertiesTracker;
  export function get(object: any): any;
  class NamedPropertiesTracker {
      private object;
      private objectProxy;
      private resolverFunc;
      private trackedValues;
      constructor(object: any, objectProxy: any, resolverFunc: ResolverFunction);
      private newPropertyDescriptor;
      track(name: string, value: any): void;
      untrack(name: string, value: any): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/named-properties-window' {
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export function initializeWindow(window: Window, windowProxy: Window): void;
  export function elementAttributeModified(element: ElementImpl, name: string, value: string, oldValue: string): void;
  export function nodeAttachedToDocument(node: NodeImpl): void;
  export function nodeDetachedFromDocument(node: NodeImpl): void;

}
declare module '@yodaos-jsar/dom/src/living/node-document-position' {
  const _default: Readonly<{
      DOCUMENT_POSITION_DISCONNECTED: 1;
      DOCUMENT_POSITION_PRECEDING: 2;
      DOCUMENT_POSITION_FOLLOWING: 4;
      DOCUMENT_POSITION_CONTAINS: 8;
      DOCUMENT_POSITION_CONTAINED_BY: 16;
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
  }>;
  export default _default;

}
declare module '@yodaos-jsar/dom/src/living/node-type' {
  import type { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import type { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  const NodeTypes: Readonly<{
      ELEMENT_NODE: 1;
      ATTRIBUTE_NODE: 2;
      TEXT_NODE: 3;
      CDATA_SECTION_NODE: 4;
      ENTITY_REFERENCE_NODE: 5;
      ENTITY_NODE: 6;
      PROCESSING_INSTRUCTION_NODE: 7;
      COMMENT_NODE: 8;
      DOCUMENT_NODE: 9;
      DOCUMENT_TYPE_NODE: 10;
      DOCUMENT_FRAGMENT_NODE: 11;
      NOTATION_NODE: 12;
  }>;
  export function isNode(node: Node): node is Node;
  export function isElementNode(node: Node): node is Element;
  export function isAttributeNode(node: Node): node is Attr;
  export function isTextNode(node: Node): node is Text;
  export function isDocumentNode(node: Node): node is Document;
  export function isHTMLElement(node: Node): node is HTMLElement;
  export function isHTMLContentElement(node: Node): node is HTMLContentElement;
  export function isHTMLStyleElement(node: Node): node is HTMLStyleElement;
  export function isSpatialElement(node: Node): node is SpatialElement;
  export default NodeTypes;

}
declare module '@yodaos-jsar/dom/src/living/node' {
  import type { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import HTMLCollectionImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLCollection';
  import type { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  export function listOfElementsWithClassNames(classNames: string, root: NodeImpl): HTMLCollectionImpl;
  export function listOfElementsWithQualifiedName(qualifiedName: string, root: NodeImpl): HTMLCollectionImpl;
  export function listOfElementsWithNamespaceAndLocalName(namespace: string, localName: string, root: NodeImpl): HTMLCollectionImpl;
  export function convertNodesIntoNode<T = Node>(document: SpatialDocumentImpl, nodes: (string | Node)[]): T;

}
declare module '@yodaos-jsar/dom/src/living/nodes/CharacterData' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export default class CharacterDataImpl extends NodeImpl implements CharacterData {
      _data: string;
      constructor(hostObject: NativeDocument, _args: any, privateData: {
          data: string;
      });
      get data(): string;
      set data(data: string);
      get length(): number;
      appendData(data: string): void;
      deleteData(offset: number, count: number): void;
      insertData(offset: number, data: string): void;
      replaceData(offset: number, count: number, data: string): void;
      substringData(offset: number, count: number): string;
      after(...nodes: (string | Node)[]): void;
      before(...nodes: (string | Node)[]): void;
      remove(): void;
      replaceWith(...nodes: (string | Node)[]): void;
      nextElementSibling: Element;
      previousElementSibling: Element;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/ChildNode' {
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  /**
   * Represents an implementation of the ChildNode interface.
   */
  export default interface ChildNodeImpl extends NodeImpl {
  }
  export default class ChildNodeImpl implements ChildNode {
      /**
       * Inserts nodes or strings after the current node.
       *
       * @param nodes - The nodes or strings to insert.
       */
      after(...nodes: (string | Node)[]): void;
      /**
       * Inserts the specified nodes or strings before the current node.
       *
       * @param nodes - The nodes or strings to insert.
       * @returns void
       */
      before(...nodes: (string | Node)[]): void;
      /**
       * Removes the node from its parent node.
       */
      remove(): void;
      /**
       * Replaces the child nodes of the current node with the specified nodes.
       *
       * @param nodes - The nodes to replace the child nodes with.
       */
      replaceWith(...nodes: (string | Node)[]): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/DOMTokenList' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import OrderedSet from '@yodaos-jsar/dom/src/living/helpers/ordered-set';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  export default class DOMTokenListImpl implements DOMTokenList {
      private nativeDocument;
      [index: number]: string;
      _tokenSet: OrderedSet<string>;
      _element: ElementImpl;
      _attributeLocalName: string;
      _supportedTokens: Set<string>;
      _dirty: boolean;
      constructor(nativeDocument: NativeDocument, args: any, privateData: {
          element: ElementImpl;
          attributeLocalName: string;
          supportedTokens?: Set<string>;
      });
      _validationSteps(token: string): boolean;
      contains(token: string): boolean;
      item(index: number): string;
      add(...tokens: string[]): void;
      remove(...tokens: string[]): void;
      replace(token: string, newToken: string): boolean;
      supports(token: string): boolean;
      toggle(token: string, force?: boolean): boolean;
      forEach(_callbackfn: (value: string, key: number, parent: DOMTokenList) => void, thisArg?: any): void;
      _attrModified(): void;
      _syncWithElement(): void;
      _validationStep(token: string): boolean;
      _updateSteps(): void;
      _serializeSteps(): string;
      get length(): number;
      get value(): string;
      set value(value: string);
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/DocumentFragment' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import ParentNodeImpl from '@yodaos-jsar/dom/src/living/nodes/ParentNode';
  import NonElementParentNodeImpl from '@yodaos-jsar/dom/src/living/nodes/NonElementParentNode';
  export default interface DocumentFragmentImpl extends NodeImpl, NonElementParentNodeImpl, ParentNodeImpl {
  }
  export default class DocumentFragmentImpl extends NodeImpl implements DocumentFragment {
      constructor(hostObject: NativeDocument, args: any, privateData: {
          host: NodeImpl;
      });
      getElementById(id: string): HTMLElement;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/DocumentOrShadowRoot' {
  import nwsapi from 'nwsapi';
  import CSSStyleSheetImpl from '@yodaos-jsar/dom/src/living/cssom/CSSStyleSheet';
  import StyleSheetListImpl from '@yodaos-jsar/dom/src/living/cssom/StyleSheetList';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export default class DocumentOrShadowRootImpl implements DocumentOrShadowRoot {
      _styleSheets: StyleSheetListImpl;
      _adoptedStyleSheets: CSSStyleSheetImpl[];
      _nwsapi: nwsapi.NWSAPI;
      _nwsapiDontThrow: nwsapi.NWSAPI;
      /**
       * It returns the inline stylesheets of this document or shadow root.
       *
       * @readonly
       */
      get styleSheets(): StyleSheetList;
      get adoptedStyleSheets(): CSSStyleSheet[];
      set adoptedStyleSheets(sheets: CSSStyleSheet[]);
      get fullscreenElement(): Element;
      pictureInPictureElement: Element;
      pointerLockElement: Element;
      elementFromPoint(x: number, y: number): Element;
      elementsFromPoint(x: number, y: number): Element[];
      getAnimations(): Animation[];
      get activeElement(): Element | (this & NodeImpl);
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/DocumentType' {
  import type { BaseWindowImpl } from '@yodaos-jsar/dom/src/agent/window';
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export class DocumentTypeImpl extends NodeImpl implements DocumentType {
      name: string;
      publicId: string;
      systemId: string;
      constructor(hostObject: NativeDocument, _args: any, privateData: {
          name: string;
          publicId: string;
          systemId: string;
          defaultView: BaseWindowImpl;
      });
      after(...nodes: (string | Node)[]): void;
      before(...nodes: (string | Node)[]): void;
      remove(): void;
      replaceWith(...nodes: (string | Node)[]): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/Element' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import type { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import type { AttrImpl } from '@yodaos-jsar/dom/src/living/attributes/Attr';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import ParentNodeImpl from '@yodaos-jsar/dom/src/living/nodes/ParentNode';
  import ChildNodeImpl from '@yodaos-jsar/dom/src/living/nodes/ChildNode';
  import NonDocumentTypeChildNodeImpl from '@yodaos-jsar/dom/src/living/nodes/NonDocumentTypeChildNode';
  import type { CustomElementDefinition } from '@yodaos-jsar/dom/src/living/custom-elements/CustomElementRegistry';
  import DOMTokenListImpl from '@yodaos-jsar/dom/src/living/nodes/DOMTokenList';
  import NamedNodeMapImpl from '@yodaos-jsar/dom/src/living/attributes/NamedNodeMap';
  /**
   * Represents an implementation of the Element interface.
   * Inherits from NodeImpl, NonDocumentTypeChildNodeImpl, ParentNodeImpl, and ChildNodeImpl.
   */
  export interface ElementImpl extends NodeImpl, NonDocumentTypeChildNodeImpl, ParentNodeImpl, ChildNodeImpl {
  }
  export class ElementImpl extends NodeImpl implements Element {
      attributes: NamedNodeMap;
      clientHeight: number;
      clientLeft: number;
      clientTop: number;
      clientWidth: number;
      onfullscreenchange: (this: Element, ev: Event) => any;
      onfullscreenerror: (this: Element, ev: Event) => any;
      outerHTML: string;
      part: DOMTokenList;
      scrollHeight: number;
      scrollLeft: number;
      scrollTop: number;
      scrollWidth: number;
      get shadowRoot(): ShadowRoot;
      slot: string;
      ariaAtomic: string;
      ariaAutoComplete: string;
      ariaBusy: string;
      ariaChecked: string;
      ariaColCount: string;
      ariaColIndex: string;
      ariaColSpan: string;
      ariaCurrent: string;
      ariaDisabled: string;
      ariaExpanded: string;
      ariaHasPopup: string;
      ariaHidden: string;
      ariaInvalid: string;
      ariaKeyShortcuts: string;
      ariaLabel: string;
      ariaLevel: string;
      ariaLive: string;
      ariaModal: string;
      ariaMultiLine: string;
      ariaMultiSelectable: string;
      ariaOrientation: string;
      ariaPlaceholder: string;
      ariaPosInSet: string;
      ariaPressed: string;
      ariaReadOnly: string;
      ariaRequired: string;
      ariaRoleDescription: string;
      ariaRowCount: string;
      ariaRowIndex: string;
      ariaRowSpan: string;
      ariaSelected: string;
      ariaSetSize: string;
      ariaSort: string;
      ariaValueMax: string;
      ariaValueMin: string;
      ariaValueNow: string;
      ariaValueText: string;
      role: string;
      innerHTML: string;
      assignedSlot: HTMLSlotElement;
      _version: number;
      _attributes: NamedNodeMapImpl;
      _attributeList: AttrImpl[];
      _namespaceURI: string | null;
      _prefix: string | null;
      _localName: string;
      _ceState: string;
      _ceDefinition: CustomElementDefinition;
      _ceReactionQueue: any[];
      _isValue: boolean;
      _classList: DOMTokenListImpl;
      _ownerDocument: SpatialDocumentImpl;
      _attributesByNameMap: Map<string, AttrImpl[]>;
      _cachedTagName: string | null;
      constructor(hostObject: NativeDocument, args: any, privateData: {
          namespace?: string;
          prefix?: string;
          localName: string;
          ceState?: string;
          ceDefinition?: CustomElementDefinition;
          isValue?: boolean;
      });
      get ownerDocument(): Document;
      get prefix(): string;
      get localName(): string;
      get namespaceURI(): string | null;
      get id(): string;
      get className(): string;
      set className(value: string);
      get classList(): DOMTokenListImpl;
      get _qualifiedName(): string;
      get tagName(): string;
      _attach(): void;
      _detach(): void;
      _attrModified(name: string, value: string, oldValue: string): void;
      attachShadow(_init: ShadowRootInit): ShadowRoot;
      checkVisibility(_options?: CheckVisibilityOptions): boolean;
      closest<K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K];
      closest<K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K];
      closest<K extends keyof MathMLElementTagNameMap>(selector: K): MathMLElementTagNameMap[K];
      closest<E extends Element = Element>(selectors: string): E;
      computedStyleMap(): StylePropertyMapReadOnly;
      getAttribute(qualifiedName: string): string;
      getAttributeNS(namespace: string, localName: string): string;
      getAttributeNames(): string[];
      getAttributeNode(qualifiedName: string): Attr;
      getAttributeNodeNS(namespace: string, localName: string): Attr;
      getBoundingClientRect(): DOMRect;
      getClientRects(): DOMRectList;
      getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
      getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof MathMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<MathMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K]>;
      getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1999/xhtml', localName: string): HTMLCollectionOf<HTMLElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/2000/svg', localName: string): HTMLCollectionOf<SVGElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1998/Math/MathML', localName: string): HTMLCollectionOf<MathMLElement>;
      getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
      hasAttribute(qualifiedName: string): boolean;
      hasAttributeNS(namespace: string, localName: string): boolean;
      hasAttributes(): boolean;
      hasPointerCapture(pointerId: number): boolean;
      insertAdjacentElement(where: InsertPosition, element: Element): Element;
      insertAdjacentHTML(position: InsertPosition, text: string): void;
      insertAdjacentText(where: InsertPosition, data: string): void;
      matches(selectors: string): boolean;
      releasePointerCapture(pointerId: number): void;
      removeAttribute(qualifiedName: string): void;
      removeAttributeNS(namespace: string, localName: string): void;
      removeAttributeNode(attr: Attr): Attr;
      requestFullscreen(options?: FullscreenOptions): Promise<void>;
      requestPointerLock(): void;
      scroll(options?: ScrollToOptions): void;
      scroll(x: number, y: number): void;
      scrollBy(options?: ScrollToOptions): void;
      scrollBy(x: number, y: number): void;
      scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
      scrollTo(options?: ScrollToOptions): void;
      scrollTo(x: number, y: number): void;
      setAttribute(qualifiedName: string, value: string): void;
      setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
      setAttributeNode(attr: Attr): Attr;
      setAttributeNodeNS(attr: Attr): Attr;
      setPointerCapture(pointerId: number): void;
      toggleAttribute(qualifiedName: string, force?: boolean): boolean;
      webkitMatchesSelector(selectors: string): boolean;
      animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
      getAnimations(options?: GetAnimationsOptions): Animation[];
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/GlobalEventHandlers' {
  import type HandTrackingEvent from '@yodaos-jsar/dom/src/living/events/HandTrackingEvent';
  export const events: Set<string>;
  export interface GlobalEventHandlersImpl extends EventTarget {
  }
  export class GlobalEventHandlersImpl implements GlobalEventHandlers {
      onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onbeforeinput: (this: GlobalEventHandlers, ev: InputEvent) => any;
      onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      oncancel: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
      onchange: (this: GlobalEventHandlers, ev: Event) => any;
      onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onclose: (this: GlobalEventHandlers, ev: Event) => any;
      oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      oncopy: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
      oncut: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
      onemptied: (this: GlobalEventHandlers, ev: Event) => any;
      onended: (this: GlobalEventHandlers, ev: Event) => any;
      onerror: OnErrorEventHandlerNonNull;
      onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
      ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      oninput: (this: GlobalEventHandlers, ev: Event) => any;
      oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
      onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onload: (this: GlobalEventHandlers, ev: Event) => any;
      onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
      onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onpaste: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      onpause: (this: GlobalEventHandlers, ev: Event) => any;
      onplay: (this: GlobalEventHandlers, ev: Event) => any;
      onplaying: (this: GlobalEventHandlers, ev: Event) => any;
      onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
      onratechange: (this: GlobalEventHandlers, ev: Event) => any;
      onreset: (this: GlobalEventHandlers, ev: Event) => any;
      onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onscroll: (this: GlobalEventHandlers, ev: Event) => any;
      onscrollend: (this: GlobalEventHandlers, ev: Event) => any;
      onsecuritypolicyviolation: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
      onseeked: (this: GlobalEventHandlers, ev: Event) => any;
      onseeking: (this: GlobalEventHandlers, ev: Event) => any;
      onselect: (this: GlobalEventHandlers, ev: Event) => any;
      onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
      onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
      onslotchange: (this: GlobalEventHandlers, ev: Event) => any;
      onstalled: (this: GlobalEventHandlers, ev: Event) => any;
      onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
      onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
      ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
      ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
      ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
      onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
      onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
      onbeforexrselect: (this: GlobalEventHandlers, ev: XRSessionEvent) => any;
      onhandtracking: (this: GlobalEventHandlers, ev: HandTrackingEvent) => any;
      _registeredHanders: Set<unknown>;
      _eventHandlers: any;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLAudioElement' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import HTMLMediaElementImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLMediaElement';
  export default class HTMLAudioElementImpl extends HTMLMediaElementImpl implements HTMLAudioElement {
      constructor(hostObject: NativeDocument, args: any[], _privateData?: any);
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLBaseElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLBaseElementImpl extends HTMLElementImpl implements HTMLBaseElement {
      constructor(nativeDocument: NativeDocument, args: any, privateData?: {});
      get href(): string;
      set href(value: string);
      get target(): string;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLCollection' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export default class HTMLCollectionImpl implements HTMLCollection {
      _version: number;
      _element: NodeImpl;
      _query: () => HTMLElement[];
      private _list;
      constructor(_nativeDocument: NativeDocument, _args: any, privateData: {
          element: NodeImpl;
          query: () => HTMLElement[];
      });
      item(index: number): Element;
      namedItem(name: string): Element;
      [index: number]: Element;
      get length(): number;
      [Symbol.iterator](): IterableIterator<HTMLElement>;
      entries(): IterableIterator<[number, HTMLElement]>;
      filter<S extends HTMLElement>(predicate: (value: HTMLElement, index: number, array: HTMLElement[]) => value is S, thisArg?: any): S[];
      filter(predicate: (value: HTMLElement, index: number, array: HTMLElement[]) => unknown, thisArg?: any): HTMLElement[];
      map<U>(callbackfn: (value: HTMLElement, index: number, array: HTMLElement[]) => U, thisArg?: any): U[];
      indexOf(searchElement: HTMLElement, fromIndex?: number): number;
      /**
       * @internal
       */
      _update(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement' {
  import cssstyle from 'cssstyle';
  import { InteractiveDynamicTexture } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/InteractiveDynamicTexture';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { Control2D } from '@yodaos-jsar/dom/src/living/helpers/gui2d/control';
  export class HTMLContentElement extends HTMLElementImpl {
      private _targetTexture;
      /** @internal */
      _control: Control2D;
      /** @internal */
      _adoptedStyle: cssstyle.CSSStyleDeclaration;
      constructor(hostObject: NativeDocument, args: any[], privateData: ConstructorParameters<typeof HTMLElementImpl>[2]);
      _attach(): void;
      _detach(): void;
      _adoptStyle(style: CSSStyleDeclaration): void;
      _attrModified(name: string, value: string, oldValue: string): void;
      _childTextContentChangeSteps(): void;
      /**
       * Update the target texture of this HTML element.
       *
       * @internal
       * @param targetTexture
       */
      _updateTargetTexture(targetTexture: InteractiveDynamicTexture): void;
      /**
       * Set the target texture to be dirty, this will trigger a re-rendering of the while target texture(page).
       *
       * TODO: support partial update.
       */
      _tryUpdate(): void;
      /**
       * Render the controller itself.
       *
       * @internal
       * @param rect
       * @param base
       */
      _renderSelf(rect: DOMRect, base: DOMRectReadOnly): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLDivElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  export default class HTMLDivElementImpl extends HTMLContentElement implements HTMLDivElement {
      align: string;
      constructor(nativeDocument: NativeDocument, args: any, privateData?: {});
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLElement' {
  import cssstyle from 'cssstyle';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export class HTMLElementImpl extends ElementImpl implements HTMLElement {
      private _settingCssText;
      _style: cssstyle.CSSStyleDeclaration;
      accessKey: string;
      accessKeyLabel: string;
      autocapitalize: string;
      get dir(): string;
      set dir(value: string);
      draggable: boolean;
      hidden: boolean;
      inert: boolean;
      innerText: string;
      lang: string;
      offsetHeight: number;
      offsetLeft: number;
      offsetParent: Element;
      offsetTop: number;
      offsetWidth: number;
      outerText: string;
      popover: string;
      spellcheck: boolean;
      title: string;
      translate: boolean;
      attachInternals(): ElementInternals;
      click(): void;
      hidePopover(): void;
      showPopover(): void;
      togglePopover(force?: boolean): void;
      attributeStyleMap: StylePropertyMap;
      get style(): CSSStyleDeclaration;
      contentEditable: string;
      enterKeyHint: string;
      inputMode: string;
      isContentEditable: boolean;
      onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onbeforeinput: (this: GlobalEventHandlers, ev: InputEvent) => any;
      onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      oncancel: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
      onchange: (this: GlobalEventHandlers, ev: Event) => any;
      onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onclose: (this: GlobalEventHandlers, ev: Event) => any;
      oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      oncopy: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
      oncut: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
      onemptied: (this: GlobalEventHandlers, ev: Event) => any;
      onended: (this: GlobalEventHandlers, ev: Event) => any;
      onerror: OnErrorEventHandlerNonNull;
      onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
      ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      oninput: (this: GlobalEventHandlers, ev: Event) => any;
      oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
      onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onload: (this: GlobalEventHandlers, ev: Event) => any;
      onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
      onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onpaste: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      onpause: (this: GlobalEventHandlers, ev: Event) => any;
      onplay: (this: GlobalEventHandlers, ev: Event) => any;
      onplaying: (this: GlobalEventHandlers, ev: Event) => any;
      onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
      onratechange: (this: GlobalEventHandlers, ev: Event) => any;
      onreset: (this: GlobalEventHandlers, ev: Event) => any;
      onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onscroll: (this: GlobalEventHandlers, ev: Event) => any;
      onscrollend: (this: GlobalEventHandlers, ev: Event) => any;
      onsecuritypolicyviolation: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
      onseeked: (this: GlobalEventHandlers, ev: Event) => any;
      onseeking: (this: GlobalEventHandlers, ev: Event) => any;
      onselect: (this: GlobalEventHandlers, ev: Event) => any;
      onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
      onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
      onslotchange: (this: GlobalEventHandlers, ev: Event) => any;
      onstalled: (this: GlobalEventHandlers, ev: Event) => any;
      onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
      onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
      ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
      ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
      ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
      onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
      onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
      onbeforexrselect: (this: GlobalEventHandlers, ev: XRSessionEvent) => any;
      autofocus: boolean;
      dataset: DOMStringMap;
      nonce?: string;
      tabIndex: number;
      constructor(hostObject: NativeDocument, args: any[], privateData: ConstructorParameters<typeof ElementImpl>[2]);
      blur(): void;
      focus(options?: FocusOptions): void;
      /**
       * @internal
       */
      _dispose(): void;
      _attrModified(name: string, value: string, oldValue: string): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLHeadElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLHeadElementImpl extends HTMLElementImpl implements HTMLHeadElement {
      constructor(nativeDocument: NativeDocument, args: any, privateData?: {});
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLHeadingElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  export default class HTMLHeadingElementImpl extends HTMLContentElement implements HTMLHeadingElement {
      align: string;
      constructor(nativeDocument: NativeDocument, args: any, privateData: {
          level: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
      });
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLImageElement' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  import DOMRectImpl from '@yodaos-jsar/dom/src/living/geometry/DOMRect';
  export default class HTMLImageElementImpl extends HTMLContentElement implements HTMLImageElement {
      private _imageBitmap;
      private _imageData;
      private _currentSrc;
      private _currentRequestState;
      private _width;
      private _height;
      private _naturalWidth;
      private _naturalHeight;
      private _naturalImageRatio;
      private _enableResizing;
      align: string;
      alt: string;
      border: string;
      crossOrigin: string;
      decoding: 'async' | 'sync' | 'auto';
      get complete(): boolean;
      get currentSrc(): string;
      get height(): number;
      set height(value: number);
      get width(): number;
      set width(value: number);
      hspace: number;
      vspace: number;
      isMap: boolean;
      useMap: string;
      loading: 'eager' | 'lazy';
      longDesc: string;
      lowsrc: string;
      name: string;
      naturalHeight: number;
      naturalWidth: number;
      referrerPolicy: string;
      sizes: string;
      get src(): string;
      set src(value: string);
      get srcset(): string;
      set srcset(value: string);
      x: number;
      y: number;
      constructor(nativeDocument: NativeDocument, args: any, _privateData?: {});
      _dispatchResizeTask(sizeSetter: () => void): Promise<void>;
      _fixSizeByImage(rect: DOMRectImpl): void;
      private _resizeImageData;
      private _loadImageData;
      _attrModified(name: string, value: string, oldValue: string): void;
      _detach(): void;
      private _resetHandles;
      _renderSelf(rect: DOMRect, base: DOMRectReadOnly): void;
      decode(): Promise<void>;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLLinkElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  const relTypesArray: readonly ["alternate", "author", "dns-prefetch", "help", "icon", "license", "next", "pingback", "preconnect", "prefetch", "preload", "prerender", "prev", "search", "stylesheet", "spatial-model", "mesh"];
  type RelType = typeof relTypesArray[number];
  type CrossOriginValue = 'anonymous' | 'use-credentials';
  export default class HTMLLinkElementImpl extends HTMLElementImpl implements HTMLLinkElement {
      disabled: boolean;
      imageSizes: string;
      imageSrcset: string;
      integrity: string;
      media: string;
      referrerPolicy: string;
      relList: DOMTokenList;
      sizes: DOMTokenList;
      target: string;
      sheet: CSSStyleSheet;
      constructor(hostObject: NativeDocument, args: any, _privateData?: any);
      get as(): string;
      set as(value: string);
      get charset(): string;
      get crossOrigin(): CrossOriginValue;
      set crossOrigin(value: CrossOriginValue);
      get href(): string;
      set href(value: string);
      get hreflang(): string;
      set hreflang(value: string);
      get rel(): RelType;
      set rel(value: RelType);
      get rev(): string;
      get type(): string;
      set type(value: string);
      _attach(): void;
      private _loadStylesheet;
      private _loadSpatialModel;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLMediaElement' {
  import type { MediaPlayerBackend, NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLMediaElementImpl extends HTMLElementImpl implements HTMLMediaElement {
      autoplay: boolean;
      buffered: TimeRanges;
      controls: boolean;
      crossOrigin: string;
      currentSrc: string;
      get currentTime(): number;
      set currentTime(value: number);
      defaultMuted: boolean;
      defaultPlaybackRate: number;
      disableRemotePlayback: boolean;
      get duration(): number;
      ended: boolean;
      error: MediaError;
      mediaKeys: MediaKeys;
      muted: boolean;
      networkState: number;
      onencrypted: (this: HTMLMediaElement, ev: MediaEncryptedEvent) => any;
      onwaitingforkey: (this: HTMLMediaElement, ev: Event) => any;
      get paused(): boolean;
      playbackRate: number;
      played: TimeRanges;
      preload: '' | 'none' | 'metadata' | 'auto';
      preservesPitch: boolean;
      readyState: number;
      remote: RemotePlayback;
      seekable: TimeRanges;
      seeking: boolean;
      get src(): string;
      set src(value: string);
      srcObject: MediaProvider;
      textTracks: TextTrackList;
      get volume(): number;
      set volume(value: number);
      get loop(): boolean;
      set loop(value: boolean);
      protected _playerNative: MediaPlayerBackend;
      protected _src: string;
      constructor(hostObject: NativeDocument, _args: any[], privateData: ConstructorParameters<typeof HTMLElementImpl>[2]);
      addTextTrack(_kind: TextTrackKind, _label?: string, _language?: string): TextTrack;
      canPlayType(type: string): CanPlayTypeResult;
      fastSeek(time: number): void;
      load(): void;
      pause(): void;
      play(): Promise<void>;
      setMediaKeys(_mediaKeys: MediaKeys): Promise<void>;
      protected _loadFromBlob(blob: Blob): Promise<void>;
      protected _loadFromURL(url: string): Promise<void>;
      protected _loadFromArrayBuffer(ab: ArrayBuffer): Promise<void>;
      protected _play(when: number): Promise<void>;
      NETWORK_EMPTY: 0;
      NETWORK_IDLE: 1;
      NETWORK_LOADING: 2;
      NETWORK_NO_SOURCE: 3;
      HAVE_NOTHING: 0;
      HAVE_METADATA: 1;
      HAVE_CURRENT_DATA: 2;
      HAVE_FUTURE_DATA: 3;
      HAVE_ENOUGH_DATA: 4;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLMetaElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLMetaElementImpl extends HTMLElementImpl implements HTMLMetaElement {
      content: string;
      httpEquiv: string;
      media: string;
      name: string;
      scheme: string;
      constructor(nativeDocument: NativeDocument, args: any, privateData?: {});
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLParagraphElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  export default class HTMLParagraphElementImpl extends HTMLContentElement implements HTMLParagraphElement {
      align: string;
      constructor(nativeDocument: NativeDocument, args: any, _privateData?: {});
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLScriptElement' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  /**
   * Represents an implementation of the HTMLScriptElement interface.
   */
  export default class HTMLScriptElementImpl extends HTMLElementImpl implements HTMLScriptElement {
      /**
       * Indicates whether the script should be executed asynchronously.
       */
      get async(): boolean;
      set async(value: boolean);
      /**
       * The character encoding of the external script file.
       */
      get charset(): string;
      set charset(value: string);
      /**
       * The CORS (Cross-Origin Resource Sharing) setting for the script element.
       */
      get crossOrigin(): string;
      set crossOrigin(value: string);
      /**
       * Indicates whether the script should be executed after the page has finished parsing.
       */
      get defer(): boolean;
      set defer(value: boolean);
      /**
       * The event associated with the HTMLScriptElement.
       */
      get event(): string;
      /**
       * The value of the `htmlFor` attribute of an HTML `<script>` element.
       */
      get htmlFor(): string;
      /**
       * The integrity attribute of the HTMLScriptElement.
       * It represents a cryptographic hash of the script resource being applied.
       */
      get integrity(): string;
      /**
       * Indicates whether the script should be treated as a module or not.
       */
      get noModule(): boolean;
      /**
       * The referrer policy for the HTMLScriptElement.
       */
      get referrerPolicy(): string;
      set referrerPolicy(value: string);
      /**
       * The source URL of the script.
       */
      get src(): string;
      set src(value: string);
      /**
       * The text content of the HTMLScriptElement.
       */
      get text(): string;
      set text(value: string);
      /**
       * The type of the script.
       */
      get type(): string;
      set type(value: string);
      /**
       * The script url in well-formed absolute format.
       *
       * Initially, base script url is assigned to the XSML document url, then it will be re-assigned
       * when "src" attribute is resolved or changed.
       */
      private _baseScriptUrl;
      private _code;
      private _compiledEntryCode;
      private _compiledModules;
      private _customLoaderHooks;
      private _loaded;
      /**
       * Checks if the given type is supported by the HTMLScriptElement.
       * @param type The type to check.
       * @returns True if the type is supported, false otherwise.
       */
      static supports(type: string): boolean;
      constructor(nativeDocument: NativeDocument, args: any, _privateData?: {});
      private get console();
      private get resourceLoader();
      private get _isUserScriptStarted();
      private _markUserScriptStarted;
      _attach(): void;
      private _addCompiledModule;
      /**
       * A common method to resolve the specifier to a result object which contains the module url.
       * @param specifier
       * @param baseUrl
       * @returns
       */
      private _resolveModule;
      /**
       * The default resolver for resolving the specifier to a result object which contains the module url.
       *
       * Ths resolver supports: relative path on file and http/https protocols.
       *
       * @param specifier
       * @param context
       * @returns
       */
      private _defaultResolveModule;
      /**
       * This method is to load the module content, which is used by the `CompiledModule`.
       * @param url the resolved url string to fetch content.
       * @returns a Promise<LoadResult> which contains the module format and source content.
       */
      private _loadModule;
      /**
       * This is the default loader for loading the module content, it loads JSON, binary and scripts.
       * @param url
       * @param context
       * @returns
       */
      private _defaultLoadModule;
      /**
       * Recursively adds modules to the script element.
       * @param esmImports - The array of ES module imports.
       * @param baseUrl - The base path for resolving relative import paths.
       * @throws {TypeError} If the import path is not a relative path.
       */
      private _addModuleRecursively;
      /**
       * This method tries to fetch the given script with the given extensions in order.
       *
       * @param url The uri of the script.
       * @param extensions The extensions to try such as ['.ts', '.mjs', '.js'].
       * @returns The script source in utf8 encoding.
       */
      _tryFetchScriptWithExtensions(url: string, extensions: string[]): Promise<string>;
      /**
       * Compiles the given source code into a JavaScript code.
       * @param source The source code to compile.
       * @returns A promise that resolves to the compiled script result, which includes the compiled code and any ES module imports.
       */
      private _compile;
      private _load;
      /**
       * Asynchronously evaluates the script content or fetches and evaluates the script from the src attribute.
       * @private
       * @returns {Promise<void>} A promise that resolves when the script evaluation is complete.
       * @throws {SyntaxError} If there is a syntax error in the script content or if both src attribute and script content are present.
       */
      private _eval;
      /**
       * Evaluates the provided code in a sandboxed environment.
       * @param code The code to be evaluated.
       * @private
       */
      private _evalInternal;
      /**
       * This is a convenience method to get the exports of the module.
       * @param module the compiled module.
       * @param baseUrl the uri of the script.
       * @returns the exports of the module.
       */
      private _getModuleExports;
      /**
       * Creates a require function for importing modules.
       * @param options - The options for creating the require function.
       * @param options.baseUrl - The base path for resolving relative module paths.
       * @returns The require function.
       * @throws {TypeError} If the import path is not a relative path.
       * @throws {TypeError} If the module cannot be found.
       */
      private _createRequireFunction;
      /**
       * Creates a importer function for dynamic `import()`.
       * @param options - The options for creating the dynamic importer.
       * @param options.basePath - The base path for resolving relative import paths.
       * @returns The dynamic importer function.
       */
      private _createDynamicImporter;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLScriptElement.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLSpanElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLContentElement } from '@yodaos-jsar/dom/src/living/nodes/HTMLContentElement';
  export default class HTMLSpanElementImpl extends HTMLContentElement implements HTMLSpanElement {
      constructor(nativeDocument: NativeDocument, args: any, _privateData?: {});
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLStyleElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLStyleElementImpl extends HTMLElementImpl implements HTMLStyleElement {
      disabled: boolean;
      media: string;
      sheet: CSSStyleSheet;
      _isOnStackOfOpenElements: boolean;
      constructor(hostObject: NativeDocument, args: any[], privateData?: {});
      get type(): string;
      set type(value: string);
      _attach(): void;
      _updateAStyleBlock(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/HTMLTitleElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { HTMLElementImpl } from '@yodaos-jsar/dom/src/living/nodes/HTMLElement';
  export default class HTMLTitleElementImpl extends HTMLElementImpl implements HTMLTitleElement {
      constructor(nativeDocument: NativeDocument, args: any, privateData?: {});
      get text(): string;
      set text(value: string);
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/Node' {
  import type { BaseWindowImpl } from '@yodaos-jsar/dom/src/agent/window';
  import { ShadowRootImpl } from '@yodaos-jsar/dom/src/living/nodes/ShadowRoot';
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import type { SpatialDocumentImpl } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  type ObserverItem = {
      observer: MutationObserver;
      options?: MutationObserverInit;
      source?: ObserverItem;
  };
  export class NodeImpl extends EventTarget implements Node {
      #private;
      readonly ELEMENT_NODE: 1;
      static readonly ELEMENT_NODE: 1;
      readonly ATTRIBUTE_NODE: 2;
      static readonly ATTRIBUTE_NODE: 2;
      readonly TEXT_NODE: 3;
      static readonly TEXT_NODE: 3;
      readonly CDATA_SECTION_NODE: 4;
      static readonly CDATA_SECTION_NODE: 4;
      readonly ENTITY_REFERENCE_NODE: 5;
      static readonly ENTITY_REFERENCE_NODE: 5;
      readonly ENTITY_NODE: 6;
      static readonly ENTITY_NODE: 6;
      readonly PROCESSING_INSTRUCTION_NODE: 7;
      static readonly PROCESSING_INSTRUCTION_NODE: 7;
      readonly COMMENT_NODE: 8;
      static readonly COMMENT_NODE: 8;
      readonly DOCUMENT_NODE: 9;
      static readonly DOCUMENT_NODE: 9;
      readonly DOCUMENT_TYPE_NODE: 10;
      static readonly DOCUMENT_TYPE_NODE: 10;
      readonly DOCUMENT_FRAGMENT_NODE: 11;
      static readonly DOCUMENT_FRAGMENT_NODE: 11;
      readonly NOTATION_NODE: 12;
      static readonly NOTATION_NODE: 12;
      /**
       * A node that represents a spatial object, which contains: transform, mesh, light, etc.
       */
      readonly SPATIAL_OBJECT_NODE: 13;
      static readonly SPATIAL_OBJECT_NODE: 13;
      readonly DOCUMENT_POSITION_DISCONNECTED: 1;
      static readonly DOCUMENT_POSITION_DISCONNECTED: 1;
      readonly DOCUMENT_POSITION_PRECEDING: 2;
      static readonly DOCUMENT_POSITION_PRECEDING: 2;
      readonly DOCUMENT_POSITION_FOLLOWING: 4;
      static readonly DOCUMENT_POSITION_FOLLOWING: 4;
      readonly DOCUMENT_POSITION_CONTAINS: 8;
      static readonly DOCUMENT_POSITION_CONTAINS: 8;
      readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
      static readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
      readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
      static readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
      nodeType: number;
      _version: number;
      _attached: boolean;
      _hostObject: NativeDocument;
      _host: NodeImpl;
      _ownerDocument: SpatialDocumentImpl;
      _shadowRoot: ShadowRootImpl | null;
      _assignedSlot: HTMLSlotElement | null;
      _assignedNodes: Array<NodeImpl>;
      _referencedRanges: Set<Range>;
      _registeredObserverList: Array<ObserverItem>;
      _memoizedQueries: {};
      _ceState: string;
      /**
       * The followings are used by inspector protocol
       */
      /** @internal */
      _inspectorId: number;
      constructor(hostObject: NativeDocument, _args: any, privateData?: {
          defaultView?: BaseWindowImpl;
      });
      get baseURI(): string;
      get parentNode(): ParentNode;
      get nodeName(): string;
      get firstChild(): ChildNode;
      get lastChild(): ChildNode;
      get childNodes(): NodeListOf<ChildNode>;
      get isConnected(): boolean;
      get ownerDocument(): Document;
      get nextSibling(): ChildNode | null;
      get previousSibling(): ChildNode | null;
      get parentElement(): HTMLElement | null;
      get nodeValue(): string;
      set nodeValue(value: string);
      get textContent(): string;
      set textContent(value: string);
      protected get _cdpImpl(): import("@yodaos-jsar/dom/src/agent/cdp/cdp-implementation").CdpServerImplementation;
      _modified(): void;
      _childTextContentChangeSteps(): void;
      _clearMemoizedQueries(): void;
      _descendantRemoved(parent: Node, child: Node): void;
      _descendantAdded(parent: Node, child: Node): void;
      _attach(): void;
      _detach(): void;
      appendChild<T extends Node>(node: T): T;
      cloneNode(deep?: boolean): Node;
      compareDocumentPosition(other: Node): number;
      contains(other: Node): boolean;
      getRootNode(options?: GetRootNodeOptions): Node;
      hasChildNodes(): boolean;
      insertBefore<T extends Node>(node: T, child: Node): T;
      isDefaultNamespace(_namespace: string): boolean;
      isEqualNode(otherNode: Node): boolean;
      isSameNode(otherNode: Node): boolean;
      lookupNamespaceURI(prefix: string): string;
      lookupPrefix(namespace: string): string;
      normalize(): void;
      removeChild<T extends Node>(child: T): T;
      replaceChild<T extends Node>(node: Node, child: T): T;
      _preInsertValidity(nodeImpl: any, childImpl: any): void;
      _preInsert(nodeImpl: NodeImpl, childImpl: NodeImpl): NodeImpl;
      _insert(nodeImpl: NodeImpl, childImpl: NodeImpl, suppressObservers?: any): void;
      _append(nodeImpl: NodeImpl): NodeImpl;
      _replace(nodeImpl: NodeImpl, childImpl: NodeImpl): NodeImpl;
      _replaceAll(nodeImpl: NodeImpl): void;
      _preRemove(childImpl: NodeImpl): NodeImpl;
      _remove(nodeImpl: NodeImpl, suppressObservers?: any): void;
      get children(): HTMLCollection;
      get firstElementChild(): Element;
      get lastElementChild(): Element;
      get childElementCount(): number;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/NodeList' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export class NodeListImpl<T extends Node> implements NodeList {
      #private;
      _hostObject: NativeDocument;
      constructor(hostObject: NativeDocument, _args: any[], privateData: {
          query?: () => T[];
          element?: NodeImpl;
          nodes?: T[];
      });
      [index: number]: T;
      get length(): number;
      [Symbol.iterator](): IterableIterator<T>;
      item(index: number): T;
      forEach(callbackfn: (value: T, key: number, parent: NodeListImpl<T>) => void, thisArg?: any): void;
      entries(): IterableIterator<[number, T]>;
      keys(): IterableIterator<number>;
      values(): IterableIterator<T>;
      _update(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/NodeList.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/NonDocumentTypeChildNode' {
  export default class NonDocumentTypeChildNodeImpl implements NonDocumentTypeChildNode {
      get nextElementSibling(): Element;
      get previousElementSibling(): any;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/NonElementParentNode' {
  export default interface NonElementParentNodeImpl extends NonElementParentNode {
  }
  export default class NonElementParentNodeImpl implements NonElementParentNode {
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/ParentNode' {
  import type { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import HTMLCollectionImpl from '@yodaos-jsar/dom/src/living/nodes/HTMLCollection';
  export default interface ParentNodeImpl extends NodeImpl {
  }
  export default class ParentNodeImpl implements ParentNode {
      protected _childrenList: HTMLCollectionImpl | null;
      get children(): HTMLCollection;
      get firstElementChild(): Element | null;
      get lastElementChild(): Element | null;
      get childElementCount(): number;
      append(...nodes: (string | Node)[]): void;
      prepend(...nodes: (string | Node)[]): void;
      querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K];
      querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K];
      querySelector<K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K];
      querySelector<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLElementDeprecatedTagNameMap[K];
      querySelector<E extends Element = Element>(selectors: string): E;
      querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
      querySelectorAll<K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<MathMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<HTMLElementDeprecatedTagNameMap[K]>;
      querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
      replaceChildren(...nodes: (string | Node)[]): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/ShadowRoot' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { InteractiveDynamicTexture } from '@yodaos-jsar/dom/src/living/helpers/babylonjs/InteractiveDynamicTexture';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import DocumentFragmentImpl from '@yodaos-jsar/dom/src/living/nodes/DocumentFragment';
  import DocumentOrShadowRootImpl from '@yodaos-jsar/dom/src/living/nodes/DocumentOrShadowRoot';
  import InnerHTMLImpl from '@yodaos-jsar/dom/src/living/domparsing/InnerHTML';
  export interface ShadowRootImpl extends DocumentFragmentImpl, DocumentOrShadowRootImpl, InnerHTMLImpl {
  }
  export class ShadowRootImpl extends DocumentFragmentImpl implements ShadowRoot {
      get mode(): ShadowRootMode;
      get delegatesFocus(): boolean;
      get slotAssignment(): SlotAssignmentMode;
      get host(): Element;
      onslotchange: (this: ShadowRoot, ev: Event) => any;
      /** @internal */
      _lastFocusedElement: Element;
      _hostAsSpatialElement: SpatialElement;
      /** @internal */
      _interactiveDynamicTexture: InteractiveDynamicTexture;
      private _mode;
      private _delegatesFocus;
      private _slotAssignment;
      constructor(hostObject: NativeDocument, args: [ShadowRootInit?], privateData: {
          host: SpatialElement;
      });
      _attach(enableLighting?: boolean): void;
      _detach(): void;
      /**
       * @internal
       * @returns the native texture of this shadow root.
       */
      _getNativeTexture(): InteractiveDynamicTexture;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialBoundElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialBoundElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialButtonElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialButtonElement extends SpatialElement {
      private _meshMaterial;
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get meshMaterial(): BABYLON.Material;
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialCapsuleElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialCapsuleElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get height(): number;
      set height(value: number);
      get radius(): number;
      set radius(value: number);
      get radiusTop(): number;
      set radiusTop(value: number);
      get radiusBottom(): number;
      set radiusBottom(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialCubeElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialCubeElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get size(): number;
      set size(value: number);
      get width(): number;
      set width(value: number);
      get height(): number;
      set height(value: number);
      get depth(): number;
      set depth(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialCylinderElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialCylinderElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get height(): number;
      set height(value: number);
      get diameter(): number;
      set diameter(value: number);
      get diameterTop(): number;
      set diameterTop(value: number);
      get diameterBottom(): number;
      set diameterBottom(value: number);
      get tessellation(): number;
      set tessellation(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialDocument' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import type { BaseWindowImpl } from '@yodaos-jsar/dom/src/agent/window';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import { AttrImpl } from '@yodaos-jsar/dom/src/living/attributes/Attr';
  import DocumentOrShadowRootImpl from '@yodaos-jsar/dom/src/living/nodes/DocumentOrShadowRoot';
  import ParentNodeImpl from '@yodaos-jsar/dom/src/living/nodes/ParentNode';
  import HandTrackingEvent from '@yodaos-jsar/dom/src/living/events/HandTrackingEvent';
  import NodeIteratorImpl from '@yodaos-jsar/dom/src/living/traversal/NodeIterator';
  import { GlobalEventHandlersImpl } from '@yodaos-jsar/dom/src/living/nodes/GlobalEventHandlers';
  import { AsyncResourceQueue, ResourceQueue } from '@yodaos-jsar/dom/src/agent/resources/ResourceQueue';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  import SpatialSpaceElement from '@yodaos-jsar/dom/src/living/nodes/SpatialSpaceElement';
  import SpatialMeshElement from '@yodaos-jsar/dom/src/living/nodes/SpatialMeshElement';
  import SpatialRefElement from '@yodaos-jsar/dom/src/living/nodes/SpatialRefElement';
  import SpatialCubeElement from '@yodaos-jsar/dom/src/living/nodes/SpatialCubeElement';
  import SpatialPlaneElement from '@yodaos-jsar/dom/src/living/nodes/SpatialPlaneElement';
  import SpatialSphereElement from '@yodaos-jsar/dom/src/living/nodes/SpatialSphereElement';
  import SpatialIcosphereElement from '@yodaos-jsar/dom/src/living/nodes/SpatialIcosphereElement';
  import SpatialBoundElement from '@yodaos-jsar/dom/src/living/nodes/SpatialBoundElement';
  import SpatialPanelElement from '@yodaos-jsar/dom/src/living/nodes/SpatialPanelElement';
  import SpatialCylinderElement from '@yodaos-jsar/dom/src/living/nodes/SpatialCylinderElement';
  import SpatialCapsuleElement from '@yodaos-jsar/dom/src/living/nodes/SpatialCapsuleElement';
  import SpatialTorusElement from '@yodaos-jsar/dom/src/living/nodes/SpatialTorusElement';
  import SpatialPolyhedraElement from '@yodaos-jsar/dom/src/living/nodes/SpatialPolyhedraElement';
  import SpatialButtonElement from '@yodaos-jsar/dom/src/living/nodes/SpatialButtonElement';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  import CSSSpatialKeyframesRule from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialKeyframesRule';
  import IterableWeakSet from '@yodaos-jsar/dom/src/living/helpers/iterable-weak-set';
  import { CustomLoaderHooks } from '@yodaos-jsar/dom/src/living/helpers/scripting-types';
  type DocumentInitOptions = {
      screenWidth?: number;
      screenHeight?: number;
  };
  /**
   * The `SpatialDocument` is a new Web API, it represents the document object in space computing.
   * It is the root of the document tree, and provides the primary access to the document's data.
   */
  export interface SpatialDocumentImpl<T extends NativeDocument = NativeDocument> extends NodeImpl, DocumentOrShadowRootImpl, GlobalEventHandlersImpl, ParentNodeImpl {
  }
  export class SpatialDocumentImpl<T extends NativeDocument = NativeDocument> extends NodeImpl implements Document {
      #private;
      doctype: DocumentType;
      domain: string;
      contentType: string;
      get ownerDocument(): any;
      get URL(): string;
      get documentURI(): string;
      alinkColor: string;
      bgColor: string;
      get body(): HTMLElement;
      get space(): SpatialElement;
      get charset(): string;
      get characterSet(): string;
      get inputEncoding(): string;
      get compatMode(): string;
      cookie: string;
      currentScript: HTMLOrSVGScriptElement;
      defaultView: Window & typeof globalThis;
      designMode: string;
      dir: string;
      get documentElement(): HTMLElement;
      get documentSpatialElement(): SpatialElement;
      get fgColor(): string;
      get fullscreen(): boolean;
      get fullscreenEnabled(): boolean;
      get head(): HTMLHeadElement;
      hidden: boolean;
      get images(): HTMLCollectionOf<HTMLImageElement>;
      get embeds(): HTMLCollectionOf<HTMLEmbedElement>;
      get links(): HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>;
      get forms(): HTMLCollectionOf<HTMLFormElement>;
      get scripts(): HTMLCollectionOf<HTMLScriptElement>;
      get anchors(): HTMLCollectionOf<HTMLAnchorElement>;
      get applets(): HTMLCollection;
      get all(): HTMLAllCollection;
      get implementation(): DOMImplementation;
      get lastModified(): string;
      get linkColor(): string;
      get location(): Location;
      set location(href: Location);
      get visibilityState(): DocumentVisibilityState;
      pictureInPictureEnabled: boolean;
      plugins: HTMLCollectionOf<HTMLEmbedElement>;
      readyState: DocumentReadyState;
      referrer: string;
      rootElement: SVGSVGElement;
      scrollingElement: Element;
      timeline: DocumentTimeline;
      vlinkColor: string;
      get title(): string;
      set title(value: string);
      onfullscreenchange: (this: Document, ev: Event) => any;
      onfullscreenerror: (this: Document, ev: Event) => any;
      onpointerlockchange: (this: Document, ev: Event) => any;
      onpointerlockerror: (this: Document, ev: Event) => any;
      onreadystatechange: (this: Document, ev: Event) => any;
      onvisibilitychange: (this: Document, ev: Event) => any;
      _xsmlVersion: string;
      _ids: any;
      _parsingMode: string;
      /**
       * @internal
       *
       * This is used to indicate whether the script or module is started, in HTMLScriptElement, a script with "loader"
       * or "framework" type will be disallowed to execute if a script or module is started.
       */
      _isScriptOrModuleStarted: boolean;
      /**
       * @internal
       *
       * This is used to get the state of the custom loaders.
       */
      _pendingCustomLoaders: Array<Promise<CustomLoaderHooks>>;
      /**
       * @internal
       *
       * This is a state to get the pending script.
       */
      _pendingExecutingScript: Promise<void>;
      _scriptingDisabled: boolean;
      _encoding: string;
      _URL: URL;
      _defaultView: BaseWindowImpl<T>;
      _workingNodeIterators: IterableWeakSet<NodeIteratorImpl>;
      _asyncQueue: AsyncResourceQueue;
      _queue: ResourceQueue;
      _deferQueue: ResourceQueue;
      /**
       * This is used to store the preloading spatial models which contains the mesh, transform nodes,
       * and animation groups.
       */
      _preloadingSpatialModelObservers: Map<string, Promise<boolean>>;
      _executingScriptsObservers: Set<Promise<void>>;
      _isSpaceReady: boolean;
      _lastModified: string;
      _styleCache: WeakMap<ElementImpl, CSSStyleDeclaration | CSSSpatialStyleDeclaration> | null;
      _lastFocusedElement: Element | null;
      _spatialKeyframesMap: Map<string, CSSSpatialKeyframesRule>;
      /** Used for spatial objects */
      _idsOfSpatialObjects: {
          [key: string]: SpatialElement;
      };
      _guidSOfSpatialObjects: Map<number, SpatialElement>;
      constructor(nativeDocument: NativeDocument, options: DocumentInitOptions, privateData: {
          options: {
              url: string;
              contentType: string;
              encoding: string;
              scriptingDisabled?: boolean;
              xsmlVersion: string;
              defaultView: BaseWindowImpl<T>;
          };
      });
      adoptNode<T extends Node>(node: T): T;
      captureEvents(): void;
      caretRangeFromPoint(x: number, y: number): Range;
      clear(): void;
      close(): void;
      createAttribute(localName: string): Attr;
      createAttributeNS(namespace: string, qualifiedName: string): Attr;
      createCDATASection(data: string): CDATASection;
      createComment(data: string): Comment;
      createDocumentFragment(): DocumentFragment;
      createElementNS(namespaceURI: 'http://www.w3.org/1999/xhtml', qualifiedName: string): HTMLElement;
      createElementNS<K extends keyof SVGElementTagNameMap>(namespaceURI: 'http://www.w3.org/2000/svg', qualifiedName: K): SVGElementTagNameMap[K];
      createElementNS(namespaceURI: 'http://www.w3.org/2000/svg', qualifiedName: string): SVGElement;
      createElementNS<K extends keyof MathMLElementTagNameMap>(namespaceURI: 'http://www.w3.org/1998/Math/MathML', qualifiedName: K): MathMLElementTagNameMap[K];
      createElementNS(namespaceURI: 'http://www.w3.org/1998/Math/MathML', qualifiedName: string): MathMLElement;
      createElementNS(namespaceURI: string, qualifiedName: string, options?: ElementCreationOptions): Element;
      createElementNS(namespace: string, qualifiedName: string, options?: string | ElementCreationOptions): Element;
      createEvent(eventInterface: 'AnimationEvent'): AnimationEvent;
      createEvent(eventInterface: 'AnimationPlaybackEvent'): AnimationPlaybackEvent;
      createEvent(eventInterface: 'AudioProcessingEvent'): AudioProcessingEvent;
      createEvent(eventInterface: 'BeforeUnloadEvent'): BeforeUnloadEvent;
      createEvent(eventInterface: 'BlobEvent'): BlobEvent;
      createEvent(eventInterface: 'ClipboardEvent'): ClipboardEvent;
      createEvent(eventInterface: 'CloseEvent'): CloseEvent;
      createEvent(eventInterface: 'CompositionEvent'): CompositionEvent;
      createEvent(eventInterface: 'CustomEvent'): CustomEvent<any>;
      createEvent(eventInterface: 'DeviceMotionEvent'): DeviceMotionEvent;
      createEvent(eventInterface: 'DeviceOrientationEvent'): DeviceOrientationEvent;
      createEvent(eventInterface: 'DragEvent'): DragEvent;
      createEvent(eventInterface: 'ErrorEvent'): ErrorEvent;
      createEvent(eventInterface: 'Event'): Event;
      createEvent(eventInterface: 'Events'): Event;
      createEvent(eventInterface: 'FocusEvent'): FocusEvent;
      createEvent(eventInterface: 'FontFaceSetLoadEvent'): FontFaceSetLoadEvent;
      createEvent(eventInterface: 'FormDataEvent'): FormDataEvent;
      createEvent(eventInterface: 'GamepadEvent'): GamepadEvent;
      createEvent(eventInterface: 'HashChangeEvent'): HashChangeEvent;
      createEvent(eventInterface: 'IDBVersionChangeEvent'): IDBVersionChangeEvent;
      createEvent(eventInterface: 'InputEvent'): InputEvent;
      createEvent(eventInterface: 'KeyboardEvent'): KeyboardEvent;
      createEvent(eventInterface: 'MIDIConnectionEvent'): MIDIConnectionEvent;
      createEvent(eventInterface: 'MIDIMessageEvent'): MIDIMessageEvent;
      createEvent(eventInterface: 'MediaEncryptedEvent'): MediaEncryptedEvent;
      createEvent(eventInterface: 'MediaKeyMessageEvent'): MediaKeyMessageEvent;
      createEvent(eventInterface: 'MediaQueryListEvent'): MediaQueryListEvent;
      createEvent(eventInterface: 'MediaStreamTrackEvent'): MediaStreamTrackEvent;
      createEvent(eventInterface: 'MessageEvent'): MessageEvent<any>;
      createEvent(eventInterface: 'MouseEvent'): MouseEvent;
      createEvent(eventInterface: 'MouseEvents'): MouseEvent;
      createEvent(eventInterface: 'MutationEvent'): MutationEvent;
      createEvent(eventInterface: 'MutationEvents'): MutationEvent;
      createEvent(eventInterface: 'OfflineAudioCompletionEvent'): OfflineAudioCompletionEvent;
      createEvent(eventInterface: 'PageTransitionEvent'): PageTransitionEvent;
      createEvent(eventInterface: 'PaymentMethodChangeEvent'): PaymentMethodChangeEvent;
      createEvent(eventInterface: 'PaymentRequestUpdateEvent'): PaymentRequestUpdateEvent;
      createEvent(eventInterface: 'PictureInPictureEvent'): PictureInPictureEvent;
      createEvent(eventInterface: 'PointerEvent'): PointerEvent;
      createEvent(eventInterface: 'PopStateEvent'): PopStateEvent;
      createEvent(eventInterface: 'ProgressEvent'): ProgressEvent<EventTarget>;
      createEvent(eventInterface: 'PromiseRejectionEvent'): PromiseRejectionEvent;
      createEvent(eventInterface: 'RTCDTMFToneChangeEvent'): RTCDTMFToneChangeEvent;
      createEvent(eventInterface: 'RTCDataChannelEvent'): RTCDataChannelEvent;
      createEvent(eventInterface: 'RTCErrorEvent'): RTCErrorEvent;
      createEvent(eventInterface: 'RTCPeerConnectionIceErrorEvent'): RTCPeerConnectionIceErrorEvent;
      createEvent(eventInterface: 'RTCPeerConnectionIceEvent'): RTCPeerConnectionIceEvent;
      createEvent(eventInterface: 'RTCTrackEvent'): RTCTrackEvent;
      createEvent(eventInterface: 'SecurityPolicyViolationEvent'): SecurityPolicyViolationEvent;
      createEvent(eventInterface: 'SpeechSynthesisErrorEvent'): SpeechSynthesisErrorEvent;
      createEvent(eventInterface: 'SpeechSynthesisEvent'): SpeechSynthesisEvent;
      createEvent(eventInterface: 'StorageEvent'): StorageEvent;
      createEvent(eventInterface: 'SubmitEvent'): SubmitEvent;
      createEvent(eventInterface: 'ToggleEvent'): ToggleEvent;
      createEvent(eventInterface: 'TouchEvent'): TouchEvent;
      createEvent(eventInterface: 'TrackEvent'): TrackEvent;
      createEvent(eventInterface: 'TransitionEvent'): TransitionEvent;
      createEvent(eventInterface: 'UIEvent'): UIEvent;
      createEvent(eventInterface: 'UIEvents'): UIEvent;
      createEvent(eventInterface: 'WebGLContextEvent'): WebGLContextEvent;
      createEvent(eventInterface: 'WheelEvent'): WheelEvent;
      createEvent(eventInterface: string): Event;
      addEventListener(type: 'handtracking', callback: (this: GlobalEventHandlers, ev: HandTrackingEvent) => any): void;
      addEventListener(type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
      createNodeIterator(root: Node, whatToShow?: number, filter?: NodeFilter): NodeIterator;
      createProcessingInstruction(_target: string, _data: string): ProcessingInstruction;
      createRange(): Range;
      createTextNode(data: string): Text;
      createTreeWalker(root: Node, whatToShow?: number, filter?: NodeFilter): TreeWalker;
      execCommand(commandId: string, showUI?: boolean, value?: string): boolean;
      exitFullscreen(): Promise<void>;
      exitPictureInPicture(): Promise<void>;
      exitPointerLock(): void;
      getElementById(elementId: string): HTMLElement;
      getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
      getElementsByName(elementName: string): NodeListOf<HTMLElement>;
      getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof MathMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<MathMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K]>;
      getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1999/xhtml', localName: string): HTMLCollectionOf<HTMLElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/2000/svg', localName: string): HTMLCollectionOf<SVGElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1998/Math/MathML', localName: string): HTMLCollectionOf<MathMLElement>;
      getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
      getSelection(): Selection;
      hasFocus(): boolean;
      hasStorageAccess(): Promise<boolean>;
      importNode<T extends Node>(node: T, deep?: boolean): T;
      open(unused1?: string, unused2?: string): Document;
      open(url: string | URL, name: string, features: string): Window;
      queryCommandEnabled(commandId: string): boolean;
      queryCommandIndeterm(commandId: string): boolean;
      queryCommandState(commandId: string): boolean;
      queryCommandSupported(commandId: string): boolean;
      queryCommandValue(commandId: string): string;
      releaseEvents(): void;
      requestStorageAccess(): Promise<void>;
      write(..._: string[]): void;
      writeln(..._: string[]): void;
      fonts: FontFaceSet;
      createExpression(expression: string, resolver?: XPathNSResolver): XPathExpression;
      createNSResolver(nodeResolver: Node): Node;
      evaluate(expression: string, contextNode: Node, resolver?: XPathNSResolver, type?: number, result?: XPathResult): XPathResult;
      /**
       * Get the current scene from the space.
       */
      get scene(): BABYLON.Scene;
      get screenWidth(): number;
      get screenHeight(): number;
      /**
       * This returns this space pose(position, rotation) in the world.
       */
      get poseInWorld(): XRPose;
      attachShadow(target: SpatialElement, options?: ShadowRootInit): ShadowRoot;
      /**
       * Create an element by tag name which could be append to a `XSMLShadowRoot`.
       * @param tagName the tag name: "div", "span", "b", "a", "button" ...
       */
      createElement(tagName: 'head'): HTMLTitleElement;
      createElement(tagName: 'title'): HTMLTitleElement;
      createElement(tagName: 'meta'): HTMLMetaElement;
      createElement(tagName: 'link'): HTMLLinkElement;
      createElement(tagName: 'style'): HTMLStyleElement;
      createElement(tagName: 'script'): HTMLScriptElement;
      createElement(tagName: 'space'): SpatialSpaceElement;
      createElement(tagName: 'mesh'): SpatialMeshElement;
      createElement(tagName: 'bound'): SpatialBoundElement;
      createElement(tagName: 'panel'): SpatialPanelElement;
      createElement(tagName: 'cube'): SpatialCubeElement;
      createElement(tagName: 'plane'): SpatialPlaneElement;
      createElement(tagName: 'sphere'): SpatialSphereElement;
      createElement(tagName: 'icosphere'): SpatialIcosphereElement;
      createElement(tagName: 'cylinder'): SpatialCylinderElement;
      createElement(tagName: 'capsule'): SpatialCapsuleElement;
      createElement(tagName: 'torus'): SpatialTorusElement;
      createElement(tagName: 'polyhedra'): SpatialPolyhedraElement;
      createElement(tagName: 'ref'): SpatialRefElement;
      createElement(tagName: 'button3d'): SpatialButtonElement;
      createElement(tagName: 'div'): HTMLDivElement;
      createElement(tagName: 'span'): HTMLSpanElement;
      createElement(tagName: 'a'): HTMLAnchorElement;
      createElement(tagName: 'b'): HTMLElement;
      createElement(tagName: 'i'): HTMLElement;
      createElement(tagName: 'p'): HTMLParagraphElement;
      createElement(tagName: 'img'): HTMLImageElement;
      createElement(tagName: 'button'): HTMLButtonElement;
      createElement(tagName: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'): HTMLHeadingElement;
      createElement(tagName: 'section'): HTMLElement;
      createElement(tagName: 'header'): HTMLElement;
      createElement(tagName: 'footer'): HTMLElement;
      createElement(tagName: 'nav'): HTMLElement;
      createElement(tagName: 'aside'): HTMLElement;
      createElement(tagName: 'article'): HTMLElement;
      createElement(tagName: string): Element;
      /**
       * Create a new spatial object by the tag name.
       *
       * @deprecated Please use `createElement()` instead.
       * @param tagName the tag name of the spatial element.
       */
      createSpatialObject(tagName: string, attributes: any): Element;
      /**
       * This method create a new `SpatialElement` by a reference to the native object `BABYLON.Node`, it's useful to create
       * `SpatialElement`s which is created by model or created by Babylon.js.
       *
       * @param nativeObject The native object, namely `BABYLON.Node`.
       * @returns a new `SpatialElement` instance to reference the native object.
       */
      createSpatialElementByNativeReference(nativeObject: BABYLON.Node): SpatialRefElement;
      /**
       * This method create a new `SpatialElement` by a reference to the native object `BABYLON.Node`, it's useful to create `SpatialElement`s
       * which is created by model or created by Babylon.js.
       *
       * @deprecated Please use `createSpatialElementByNativeReference()` instead.
       * @param nativeObject The native object, namely `BABYLON.Node`.
       * @returns a new `SpatialElement` instance to reference the native object.
       */
      createSpatialObjectByNativeReference(nativeObject: BABYLON.Node): SpatialRefElement;
      /**
       * The `getSpatialObjectById()` method of the `SpatialDocument` interface returns an `SpatialObject` object representing the object whose id property matches the specified string.
       * Since element IDs are required to be unique if specified, they're a useful way to get access to a specific element quickly.
       */
      getSpatialObjectById(id: string): SpatialElement;
      /**
       * This is used to get the spatial object by the transmute GUID.
       * @internal
       */
      _getSpatialObjectByGuid(guid: number): SpatialElement;
      /**
       * Wrap and execute a function with time profiling.
       *
       * @internal
       * @param tag the log tag
       * @param fn the function to be executed, it accepts an async function or blocking function.
       */
      _executeWithTimeProfiler<T>(tag: string, fn: (...args: any[]) => Promise<T> | T): Promise<T>;
      /**
       * Start watching the input event such as: pointer, guesture, keyboard, etc.
       */
      watchInputEvent(): void;
      /**
       * Get the node by the id.
       *
       * @deprecated
       */
      getNodeById(id: string): BABYLON.Node;
      /**
       * Get the material by the id.
       */
      getMaterialById(id: string): BABYLON.Material;
      private _handleHandTrackingEventDetail;
      private _createXRHandInputSource;
      private _latestRaycastTimestamp;
      private _lastPickedSpatialObject;
      private _lastPickingTimeout;
      private _handleRaycastEventDetail;
      private _handleRaycastActionEventDetail;
      private _handleInputEvent;
      private _processDomSymbolTree;
      private _onPreRenderLoop;
      /**
       * @internal
       * Start the document, it executes the scripts.
       */
      _start(noQueue?: boolean): void;
      _stop(): void;
      _adoptNode(node: Node): void;
      _runPreRemovingSteps(oldNode: NodeImpl): void;
      _createAttribute(privateData: ConstructorParameters<typeof AttrImpl>[2]): AttrImpl;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { ElementImpl } from '@yodaos-jsar/dom/src/living/nodes/Element';
  import { ShadowRootImpl } from '@yodaos-jsar/dom/src/living/nodes/ShadowRoot';
  import { SPATIAL_OBJECT_GUID_SYMBOL } from '@yodaos-jsar/dom/src/symbols';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  import { RaycastInputDetail } from '@yodaos-jsar/dom/src/input-event';
  export class SpatialElement extends ElementImpl {
      protected _scene: BABYLON.Scene;
      protected _internalObject: BABYLON.Node;
      protected _style: CSSSpatialStyleDeclaration;
      protected _id: string;
      private _isRayOn;
      private _lastRaycastTextCoord;
      /**
       * The GUID.
       */
      [SPATIAL_OBJECT_GUID_SYMBOL]: number;
      /**
       * @deprecated use `NodeTypes.isSpatialElement()` instaed.
       */
      static isSpatialElement(node: Node): node is SpatialElement;
      /**
       * The read-only `style` property of the `SpatialElement` returns the inline style of this element
       * in the form of a live `CSSSpatialStyleDeclaration` object that contains a list of all styles.
       */
      get style(): CSSSpatialStyleDeclaration;
      constructor(hostObject: NativeDocument, _args: any, privateData: ConstructorParameters<typeof ElementImpl>[2]);
      get position(): DOMPoint;
      set position(value: DOMPoint);
      get rotationQuaternion(): DOMPoint;
      set rotationQuaternion(value: DOMPoint);
      get scaling(): DOMPoint;
      set scaling(value: DOMPoint);
      /**
       * Set the value of a spatial attribute, it will throw an error if the spatial element is attached.
       *
       * @throws {DOMException} INVALID_STATE_ERR if the spatial element is attached.
       * @param name the name of the attribute
       * @param value the value of the spatial attribute
       */
      protected _setSpatialAttribute(name: string, value: string | number): void;
      protected _getInternalNodeNameOrId(): string;
      protected _getCommonMeshBuilderOptions(): Partial<{
          sideOrientation: number;
          frontUVs: BABYLON.Vector4;
          backUVs: BABYLON.Vector4;
          updatable: boolean;
      }>;
      _attach(node?: BABYLON.Node): void;
      _detach(): void;
      /**
       * Returns the native Babylon.js object.
       */
      asNativeType<T extends BABYLON.Node>(): T;
      /**
       * Checks if the SpatialElement is a TransformNode.
       * @returns {boolean} True if the SpatialElement is a TransformNode, false otherwise.
       */
      isTransformNode(): boolean;
      /**
       * Checks if the SpatialElement is a mesh node.
       * @returns {boolean} True if the SpatialElement is a mesh node, false otherwise.
       */
      isMeshNode(): boolean;
      /** @internal */
      _adoptStyle(style: CSSSpatialStyleDeclaration): void;
      /** @internal */
      _hasAttachedShadow(): boolean;
      /** @internal */
      _getAttachedShadow(): ShadowRootImpl;
      /** @internal */
      _processPicking(detail: RaycastInputDetail): void;
      /** @internal */
      _processUnpicking(): void;
      /** @internal */
      _dispatchPointerEvent(type: number): void;
      get textureSizeRatio(): number;
      get textureLighting(): boolean;
      set textureLighting(value: boolean);
      /**
       * Returns the `ShadowRoot` of this `SpatialObject` instance, it's used to get the GUI elements from script.
       */
      get shadowRoot(): ShadowRoot;
      /**
       * @internal
       * @returns the created `ShadowRoot` that is to be attached to this `SpatialObject` instance.
       */
      _createShadowRoot(init?: ShadowRootInit): ShadowRoot;
      /**
       * The `SpatialObject.attachShadow()` method attaches a shadow DOM tree to the specified element and returns
       * a reference to its ShadowRoot.
       */
      attachShadow(init?: ShadowRootInit): ShadowRoot;
      /**
       * Attaches a canvas texture to the spatial element.
       *
       * TODO: return a custom type instead of `BABYLON.DynamicTexture`?
       *
       * @param width - The width of the canvas texture. Default is 1024.
       * @param height - The height of the canvas texture. Default is 1024.
       * @returns The created dynamic texture.
       * @throws {DOMException} If the spatial element is not a mesh node, or if the mesh node already has a material.
       */
      attachCanvasTexture(width: number, height: number, useAlpha?: boolean): BABYLON.DynamicTexture;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialIcosphereElement' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialIcosphereElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get radiusX(): number;
      set radiusX(value: number);
      get radiusY(): number;
      set radiusY(value: number);
      get radiusZ(): number;
      set radiusZ(value: number);
      get radius(): number;
      set radius(value: number);
      get subdivisions(): number;
      set subdivisions(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialMeshElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialMeshElement extends SpatialElement {
      private _cachedName;
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get ref(): string;
      set ref(value: string);
      get selector(): string;
      set selector(value: string);
      _attach(): Promise<void>;
      _instantiate(): SpatialElement;
      private _getName;
      private _ensureAssetsBundle;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialPanelElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import CSSSpatialStyleDeclaration from '@yodaos-jsar/dom/src/living/cssom/CSSSpatialStyleDeclaration';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialPanelElement extends SpatialElement {
      private _isArranged;
      /**
       * Volume-based panel members
       */
      private _rowThenColumn;
      private _volumeBasedOrientation;
      private _cellWidth;
      private _cellHeight;
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get type(): 'stack' | 'cylinder' | 'sphere';
      set type(value: 'stack' | 'cylinder' | 'sphere');
      get margin(): number;
      set margin(value: number);
      get orientation(): 'vertical' | 'horizontal';
      set orientation(value: 'vertical' | 'horizontal');
      get rows(): number;
      set rows(value: number);
      get columns(): number;
      set columns(value: number);
      get radius(): number;
      set radius(value: number);
      _attach(): void;
      _adoptStyle(style: CSSSpatialStyleDeclaration): void;
      private _arrangeChildrenInStackLayout;
      private _arrangeChildrenInVolumeLayout;
      private _mapGridNode;
      private _finalProcessing;
      private _cylindricalMapping;
      private _sphericalMapping;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialPlaneElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialPlaneElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get size(): number;
      set size(value: number);
      get width(): number;
      set width(value: number);
      get height(): number;
      set height(value: number);
      get textureSizeRatio(): number;
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialPolyhedraElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  const PolyhedraNameToTypeIdMap: {
      readonly tetrahedron: 0;
      readonly octahedron: 1;
      readonly dodecahedron: 2;
      readonly icosahedron: 3;
      readonly rhombicuboctahedron: 4;
      readonly 'triangular-prism': 5;
      readonly 'pentagonal-prism': 6;
      readonly 'hexagonal-prism': 7;
      readonly 'square-pyramid': 8;
      readonly 'pentagonal-pyramid': 9;
      readonly 'triangular-dipyramid': 10;
      readonly 'pentagonal-dipyramid': 11;
      readonly 'elongated-square-dipyramid': 12;
      readonly 'elongated-pentagonal-dipyramid': 13;
      readonly 'elongated-pentagonal-cupola': 14;
  };
  type PolyhedraType = keyof (typeof PolyhedraNameToTypeIdMap);
  export default class SpatialPolyhedraElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get type(): PolyhedraType;
      set type(value: PolyhedraType);
      get sizeX(): number;
      set sizeX(value: number);
      get sizeY(): number;
      set sizeY(value: number);
      get sizeZ(): number;
      set sizeZ(value: number);
      get size(): number;
      set size(value: number);
      _attach(): void;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialRefElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialRefElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      ref(target: BABYLON.Node): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialSpaceElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialSpaceElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialSphereElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialSphereElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      /**
       * Represents the number of segments of the sphere element, with its value being a number.
       */
      get segments(): number;
      set segments(value: number);
      /**
       * Represents the diameter of the sphere element, with its value being a number.
       */
      get diameter(): number;
      set diameter(value: number);
      /**
       * Represents the X-axis diameter of the sphere element, with its value being a number.
       */
      get diameterX(): number;
      set diameterX(value: number);
      /**
       * Represents the Y-axis diameter of the sphere element, with its value being a number.
       */
      get diameterY(): number;
      set diameterY(value: number);
      /**
       * Represents the Z-axis diameter of the sphere element, with its value being a number.
       */
      get diameterZ(): number;
      set diameterZ(value: number);
      /**
       * Represents the arc of the sphere element, with its value being a number.
       */
      get arc(): number;
      set arc(value: number);
      /**
       * Represents the number of slices of the sphere element, with its value being a number.
       */
      get slice(): number;
      set slice(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/SpatialTorusElement' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { SpatialElement } from '@yodaos-jsar/dom/src/living/nodes/SpatialElement';
  export default class SpatialTorusElement extends SpatialElement {
      constructor(hostObject: NativeDocument, args: any, _privateData?: {});
      get diameter(): number;
      set diameter(value: number);
      get thickness(): number;
      set thickness(value: number);
      get tessellation(): number;
      set tessellation(value: number);
      _attach(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/nodes/Text' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import CharacterDataImpl from '@yodaos-jsar/dom/src/living/nodes/CharacterData';
  export class TextImpl extends CharacterDataImpl implements Text {
      _slotableName: string;
      get assignedSlot(): any;
      constructor(hostObject: NativeDocument, args: any, privateData: ConstructorParameters<typeof CharacterDataImpl>[2]);
      _attrModifiedSlotableMixin(name: any, value: any, oldValue: any): void;
      splitText(offset: number): Text;
      get wholeText(): string;
      _initSlotableMixin(): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/range/AbstractRange' {
  export interface BoundaryPoint {
      node: Node;
      offset: number;
  }
  export class AbstractRangeImpl implements AbstractRange {
      _hostObject: any;
      _start: BoundaryPoint;
      _end: BoundaryPoint;
      constructor(hostObject: any, args: any, privateData: any);
      get startContainer(): Node;
      get startOffset(): number;
      get endContainer(): Node;
      get endOffset(): number;
      get collapsed(): boolean;
  }

}
declare module '@yodaos-jsar/dom/src/living/range/Range' {
  import { AbstractRangeImpl, BoundaryPoint } from '@yodaos-jsar/dom/src/living/range/AbstractRange';
  export function compareBoundaryPointsPosition(bpA: BoundaryPoint, bpB: BoundaryPoint): any;
  export function validateSetBoundaryPoint(node: any, offset: any): void;
  export function setBoundaryPointStart(range: any, node: any, offset: any): void;
  export function setBoundaryPointEnd(range: any, node: any, offset: any): void;
  export class RangeImpl extends AbstractRangeImpl implements Range {
      constructor(hostObject: any, args: any[], privateData: {
          start: {
              node: Node;
              offset: number;
          };
          end: {
              node: Node;
              offset: number;
          };
      });
      getBoundingClientRect(): DOMRect;
      getClientRects(): DOMRectList;
      get commonAncestorContainer(): any;
      setStart(node: any, offset: any): void;
      setEnd(node: any, offset: any): void;
      setStartBefore(node: any): void;
      setStartAfter(node: any): void;
      setEndBefore(node: any): void;
      setEndAfter(node: any): void;
      collapse(toStart: any): void;
      selectNode(node: any): void;
      selectNodeContents(node: any): void;
      compareBoundaryPoints(how: any, sourceRange: any): any;
      deleteContents(): void;
      extractContents(): any;
      cloneContents(): any;
      insertNode(node: any): void;
      surroundContents(newParent: any): void;
      cloneRange(): RangeImpl;
      detach(): void;
      isPointInRange(node: any, offset: any): boolean;
      comparePoint(node: any, offset: any): 0 | 1 | -1;
      intersectsNode(node: any): boolean;
      toString(): string;
      createContextualFragment(fragment: any): any;
      get _root(): Node;
      _setLiveRangeStart(node: any, offset: any): void;
      _setLiveRangeEnd(node: any, offset: any): void;
      START_TO_START: 0;
      START_TO_END: 1;
      END_TO_END: 2;
      END_TO_START: 3;
  }

}
declare module '@yodaos-jsar/dom/src/living/script-context' {
  /// <reference types="node" />
  /// <reference types="node" />
  import type assert from 'assert';
  import type buffer from 'buffer';
  import type { BaseWindowImpl as BaseWindow } from '@yodaos-jsar/dom/src/agent/window';
  import type { SpatialDocumentImpl as SpatialDocument } from '@yodaos-jsar/dom/src/living/nodes/SpatialDocument';
  import type NoiseImpl from '@yodaos-jsar/dom/src/living/crypto/Noise';
  /**
   * Represents the script context interface.
   */
  export interface ScriptContext {
      BABYLON: typeof BABYLON;
      Buffer: typeof buffer.Buffer;
      assert: typeof assert;
      URL: typeof URL;
      Blob: typeof Blob;
      WebSocket: typeof WebSocket;
      Audio: typeof Audio;
      ImageData: typeof ImageData;
      OffscreenCanvas: typeof OffscreenCanvas;
      DOMPoint: typeof DOMPoint;
      DOMPointReadOnly: typeof DOMPointReadOnly;
      DOMRect: typeof DOMRect;
      DOMRectReadOnly: typeof DOMRectReadOnly;
      Noise: typeof NoiseImpl;
      atob: typeof atob;
      btoa: typeof btoa;
      fetch: BaseWindow['fetch'];
      setTimeout: typeof setTimeout;
      clearTimeout: typeof clearTimeout;
      setInterval: typeof setInterval;
      clearInterval: typeof clearInterval;
      getComputedStyle: typeof getComputedStyle;
      getComputedSpatialStyle: BaseWindow['getComputedSpatialStyle'];
      createImageBitmap: typeof createImageBitmap;
      console: Console;
      navigator: Navigator;
      document: SpatialDocument;
      spatialDocument: SpatialDocument;
      /**
       * @deprecated
       */
      spaceDocument: SpatialDocument;
  }

}
declare module '@yodaos-jsar/dom/src/living/traversal/NodeIterator' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  export default class NodeIteratorImpl implements NodeIterator {
      _hostObject: NativeDocument;
      _active: boolean;
      _pointerBeforeReferenceNode: boolean;
      _referenceNode: NodeImpl;
      filter: NodeFilter;
      get referenceNode(): Node;
      get pointerBeforeReferenceNode(): boolean;
      root: Node;
      whatToShow: number;
      constructor(nativeDocument: NativeDocument, args: any, privateData: {
          root: NodeImpl;
          referenceNode?: Node;
          pointerBeforeReferenceNode?: boolean;
          whatToShow?: number;
          filter: NodeFilter;
      });
      detach(): void;
      nextNode(): Node;
      previousNode(): Node;
      _preRemovingSteps(toBeRemovedNode: Node): void;
      _traverse(direction: 'next' | 'previous'): NodeImpl;
  }

}
declare module '@yodaos-jsar/dom/src/living/traversal/helpers' {
  import { NodeImpl } from '@yodaos-jsar/dom/src/living/nodes/Node';
  import NodeIteratorImpl from '@yodaos-jsar/dom/src/living/traversal/NodeIterator';
  export const FILTER_ACCEPT = 1;
  export const FILTER_REJECT = 2;
  export const FILTER_SKIP = 3;
  export function filter(nodeIteratorOrTreeWalkerImpl: NodeIteratorImpl, nodeImpl: NodeImpl): any;

}
declare module '@yodaos-jsar/dom/src/living/xr/XRFrame' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export default class XRFrameImpl implements XRFrame {
      private _hostObject;
      session: XRSession;
      predictedDisplayTime?: number;
      trackedAnchors?: XRAnchorSet;
      worldInformation?: XRWorldInformation;
      detectedPlanes?: XRPlaneSet;
      featurePointCloud?: number[];
      constructor(_hostObject: NativeDocument, _args: any[], privateData: {
          session: XRSession;
      });
      getPose(space: XRSpace, baseSpace: XRSpace): XRPose;
      getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose;
      createAnchor?: (pose: XRRigidTransform, space: XRSpace) => Promise<XRAnchor>;
      getHitTestResults(hitTestSource: XRHitTestSource): XRHitTestResult[];
      getHitTestResultsForTransientInput(hitTestSource: XRTransientInputHitTestSource): XRTransientInputHitTestResult[];
      fillPoses?(spaces: XRSpace[], baseSpace: XRSpace, transforms: Float32Array): boolean;
      getJointPose?(joint: XRJointSpace, baseSpace: XRSpace): XRJointPose;
      fillJointRadii?(jointSpaces: XRJointSpace[], radii: Float32Array): boolean;
      getImageTrackingResults?(): XRImageTrackingResult[];
      getLightEstimate(xrLightProbe: XRLightProbe): XRLightEstimate;
      getDepthInformation(view: XRView): XRCPUDepthInformation;
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRHand' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { kCreateForImpl } from '@yodaos-jsar/dom/src/symbols';
  export default class XRHandImpl extends Map<string, XRJointSpace> implements XRHand {
      private _hostObject;
      WRIST: number;
      THUMB_METACARPAL: number;
      THUMB_PHALANX_PROXIMAL: number;
      THUMB_PHALANX_DISTAL: number;
      THUMB_PHALANX_TIP: number;
      INDEX_METACARPAL: number;
      INDEX_PHALANX_PROXIMAL: number;
      INDEX_PHALANX_INTERMEDIATE: number;
      INDEX_PHALANX_DISTAL: number;
      INDEX_PHALANX_TIP: number;
      MIDDLE_METACARPAL: number;
      MIDDLE_PHALANX_PROXIMAL: number;
      MIDDLE_PHALANX_INTERMEDIATE: number;
      MIDDLE_PHALANX_DISTAL: number;
      MIDDLE_PHALANX_TIP: number;
      RING_METACARPAL: number;
      RING_PHALANX_PROXIMAL: number;
      RING_PHALANX_INTERMEDIATE: number;
      RING_PHALANX_DISTAL: number;
      RING_PHALANX_TIP: number;
      LITTLE_METACARPAL: number;
      LITTLE_PHALANX_PROXIMAL: number;
      LITTLE_PHALANX_INTERMEDIATE: number;
      LITTLE_PHALANX_DISTAL: number;
      LITTLE_PHALANX_TIP: number;
      static [kCreateForImpl](hostObject: NativeDocument, joints: Array<{
          position: DOMPointInit;
          rotation: DOMPointInit;
      }>): XRHandImpl;
      constructor(_hostObject: NativeDocument, _args: any[], _privateData?: any);
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRInputSource' {
  class XRInputSourceImpl implements XRInputSource {
      handedness: XRHandedness;
      targetRayMode: XRTargetRayMode;
      targetRaySpace: XRSpace;
      gripSpace?: XRSpace;
      gamepad?: Gamepad;
      profiles: string[];
      hand?: XRHand;
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRInputSourceArray' {
  export default class XRInputSourceArrayImpl extends Array<XRInputSource> implements XRInputSourceArray {
      static createFromIterator(sourcesIterator: IterableIterator<XRInputSource>): XRInputSourceArrayImpl;
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRJointSpace' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import { kCreateForImpl } from '@yodaos-jsar/dom/src/symbols';
  import XRSpaceImpl from '@yodaos-jsar/dom/src/living/xr/XRSpace';
  type PoseInit = {
      position: DOMPointInit;
      rotation: DOMPointInit;
  };
  export default class XRJointSpaceImpl extends XRSpaceImpl implements XRJointSpace {
      jointName: XRHandJoint;
      static [kCreateForImpl](hostObject: NativeDocument, jointName: XRHandJoint, jointPose: PoseInit): XRJointSpaceImpl;
  }
  export {};

}
declare module '@yodaos-jsar/dom/src/living/xr/XRPose' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export default class XRPoseImpl implements XRPose {
      _hostObject: NativeDocument;
      _transform: XRRigidTransform;
      _emulatedPosition: boolean;
      _linearVelocity?: DOMPointReadOnly;
      _angularVelocity?: DOMPointReadOnly;
      get transform(): XRRigidTransform;
      get emulatedPosition(): boolean;
      get linearVelocity(): DOMPointReadOnly | undefined;
      get angularVelocity(): DOMPointReadOnly | undefined;
      static createForImpl(hostObject: NativeDocument, _args: any[], privateData: {
          transform: XRRigidTransform;
          emulatedPosition: boolean;
          linearVelocity?: DOMPointReadOnly;
          angularVelocity?: DOMPointReadOnly;
      }): XRPoseImpl;
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRRigidTransform' {
  import DOMPointReadOnlyImpl from '@yodaos-jsar/dom/src/living/geometry/DOMPointReadOnly';
  export default class XRRigidTransformImpl implements XRRigidTransform {
      _position: DOMPointReadOnlyImpl;
      _orientation: DOMPointReadOnlyImpl;
      _matrix: Float32Array;
      get position(): DOMPointReadOnly;
      get orientation(): DOMPointReadOnly;
      get matrix(): Float32Array;
      get inverse(): XRRigidTransform;
      constructor(position?: DOMPointInit, orientation?: DOMPointInit);
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRSession' {
  import { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  export const kSessionInputSourcesMap: unique symbol;
  export const kSessionVisibilityState: unique symbol;
  export const kDispatchNextFrame: unique symbol;
  export default class XRSessionImpl extends EventTarget implements XRSession {
      #private;
      [kSessionInputSourcesMap]: Map<number, XRInputSource>;
      [kSessionVisibilityState]: XRVisibilityState;
      get inputSources(): XRInputSourceArray;
      get renderState(): XRRenderState;
      get environmentBlendMode(): XREnvironmentBlendMode;
      set environmentBlendMode(_value: XREnvironmentBlendMode);
      get visibilityState(): XRVisibilityState;
      get frameRate(): number;
      supportedFrameRates?: Float32Array;
      domOverlayState?: XRDOMOverlayState;
      preferredReflectionFormat?: XRReflectionFormat;
      depthUsage: XRDepthUsage;
      depthDataFormat: XRDepthDataFormat;
      get enabledFeatures(): string[];
      onend: XRSessionEventHandler;
      oninputsourceschange: XRInputSourceChangeEventHandler;
      onselect: XRInputSourceEventHandler;
      onselectstart: XRInputSourceEventHandler;
      onselectend: XRInputSourceEventHandler;
      onsqueeze: XRInputSourceEventHandler;
      onsqueezestart: XRInputSourceEventHandler;
      onsqueezeend: XRInputSourceEventHandler;
      onvisibilitychange: XRSessionEventHandler;
      onframeratechange: XRSessionEventHandler;
      requestHitTestSource?: (options: XRHitTestOptionsInit) => Promise<XRHitTestSource>;
      requestHitTestSourceForTransientInput?: (options: XRTransientInputHitTestOptionsInit) => Promise<XRTransientInputHitTestSource>;
      requestHitTest?: (ray: XRRay, referenceSpace: XRReferenceSpace) => Promise<XRHitResult[]>;
      updateWorldTrackingState?: (options: {
          planeDetectionState?: {
              enabled: boolean;
          };
      }) => void;
      static createForImpl(hostObject: NativeDocument, args?: [XRSessionMode, XRSessionInit], _privateData?: any): Promise<XRSessionImpl>;
      private get _nativeScene();
      end(): Promise<void>;
      cancelAnimationFrame(id: number): void;
      requestAnimationFrame(callback: XRFrameRequestCallback): number;
      /**
       * The `requestReferenceSpace()` method of the XRSession interface returns a promise that resolves with
       * an instance of either XRReferenceSpace or XRBoundedReferenceSpace as appropriate given the type of
       * reference space requested.
       *
       * @param type
       */
      requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace | XRBoundedReferenceSpace>;
      /**
       * In XSML, an object is the programable object in a scene, this method `updateRenderState()` is used to update
       * the global-scoped states such as the base layer, camera, and so on, which is not supported to be updated in XSML.
       * @param _renderStateInit
       */
      updateRenderState(_renderStateInit?: XRRenderStateInit): Promise<void>;
      updateTargetFrameRate(_rate: number): Promise<void>;
      requestLightProbe(_init?: XRLightProbeInit): Promise<XRLightProbe>;
      trySetFeaturePointCloudEnabled(_enabled: boolean): boolean;
      trySetPreferredPlaneDetectorOptions(_preferredOptions: XRGeometryDetectorOptions): boolean;
      trySetMeshDetectorEnabled(_enabled: boolean): boolean;
      trySetPreferredMeshDetectorOptions(_preferredOptions: XRGeometryDetectorOptions): boolean;
      [kDispatchNextFrame](): void;
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRSpace' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import XRPoseImpl from '@yodaos-jsar/dom/src/living/xr/XRPose';
  export const kSpacePose: unique symbol;
  export default class XRSpaceImpl extends EventTarget implements XRSpace {
      protected _hostObject: NativeDocument;
      [kSpacePose]: XRPoseImpl;
      constructor(_hostObject: NativeDocument, _args: any[], _privateData?: any);
  }

}
declare module '@yodaos-jsar/dom/src/living/xr/XRSystem' {
  import type { NativeDocument } from '@yodaos-jsar/dom/src/impl-interfaces';
  import XRSessionImpl from '@yodaos-jsar/dom/src/living/xr/XRSession';
  export const kSession: unique symbol;
  export default class XRSystemImpl extends EventTarget implements XRSystem {
      #private;
      [kSession]: XRSessionImpl | null;
      ondevicechange: XRSystemDeviceChangeEventHandler;
      onsessiongranted: XRSystemSessionGrantedEventHandler;
      constructor(hostObject: NativeDocument, _args: any[], _privateData?: any);
      requestSession(mode: XRSessionMode, options?: XRSessionInit): Promise<XRSession>;
      isSessionSupported(mode: XRSessionMode): Promise<boolean>;
  }

}
declare module '@yodaos-jsar/dom/src/mixin' {
  /**
   * Applies mixins to a derived class.
   *
   * @param derivedCtor - The derived class constructor.
   * @param constructors - An array of mixin constructors.
   */
  export function applyMixins(derivedCtor: any, constructors: any[]): void;

}
declare module '@yodaos-jsar/dom/src/mixin.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/symbols' {
  export const DIRTY_SYMBOL: unique symbol;
  export const MIME_TYPE_SYMBOL: unique symbol;
  /**
   * The Symbol used to store the guid in the transmute protocol, which is such important because it's used to
   * identify a game object in the running mode.
   */
  export const SPATIAL_OBJECT_GUID_SYMBOL: unique symbol;
  /**
   * The Symbol used to store the craft3d node, which is used for layout algorithms in space.
   */
  export const SPATIAL_ELEMENT_CRAFT3D_NODE_SYMBOL: unique symbol;
  /**
   * The Symbol used to create an instance of a class in Web APIs.
   */
  export const kCreateForImpl: unique symbol;

}
declare module '@yodaos-jsar/dom/src/utils' {
  /**
   * Returns a version of a method that memoizes specific types of calls on the object
   *
   * - `fn` {Function} the method to be memoized
   */
  export function memoizeQuery(fn: Function): Function;
  /**
   * Applies memoization to a query function on a prototype.
   * @param {object} proto - The prototype object.
   * @param {string} name - The name of the query function.
   */
  export function applyMemoizeQueryOn(proto: any, name: any): void;
  /**
   * Creates an iterator that iterates over two iterators simultaneously.
   *
   * @generator
   * @param {Iterator} first - The first iterator.
   * @param {Iterator} second - The second iterator.
   * @yields {[any, any]} - An array containing the next value from each iterator.
   */
  export const simultaneousIterators: (first: any, second: any) => Generator<any[], void, unknown>;
  /**
   * Sorts two nodes based on their tree order.
   * @param a - The first node.
   * @param b - The second node.
   * @returns 1 if b is preceding a, -1 if a is preceding b, or 0 if they are disconnected or equal.
   */
  export const treeOrderSorter: (a: any, b: any) => 0 | 1 | -1;
  export const isWin32: () => boolean;

}
declare module '@yodaos-jsar/dom/src/utils.test' {
  export {};

}
declare module '@yodaos-jsar/dom/src/virtual-console' {
  export class VirtualConsole extends EventTarget {
      constructor();
      sendTo(anyConsole: any, options: any): void;
  }

}
declare module '@yodaos-jsar/dom' {
  import main = require('@yodaos-jsar/dom/src/living/script-context');
  export = main;
}