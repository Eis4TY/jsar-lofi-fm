declare module '@transmutejs/runtime/babylon-patches/rewrite-draco-compression' {
  export {};

}
declare module '@transmutejs/runtime/babylon-patches/rewrite-meshopt-compression' {
  export {};

}
declare module '@transmutejs/runtime/dom/living/attributes/attr' {
  import { CreateXSMLType } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export class AttrImpl extends NodeImpl implements CreateXSMLType<Attr> {
      #private;
      specified: boolean;
      constructor(hostObject: any, _args: any, privateData: any);
      get namespaceURI(): string;
      get prefix(): string;
      get localName(): string;
      get name(): string;
      get nodeName(): string;
      get value(): string;
      set value(value: string);
      _setValue(value: string): void;
      get ownerElement(): Element;
      get _qualifiedName(): string;
  }

}
declare module '@transmutejs/runtime/dom/living/events/mouse-event' {
  import { UIEventImpl } from '@transmutejs/runtime/dom/living/events/ui-event';
  export class MouseEventImpl extends UIEventImpl implements MouseEvent {
      altKey: boolean;
      button: number;
      buttons: number;
      clientX: number;
      clientY: number;
      ctrlKey: boolean;
      metaKey: boolean;
      movementX: number;
      movementY: number;
      offsetX: number;
      offsetY: number;
      pageX: number;
      pageY: number;
      relatedTarget: EventTarget;
      screenX: number;
      screenY: number;
      shiftKey: boolean;
      constructor(typeArg: string, eventInitDict?: MouseEventInit);
      get x(): number;
      get y(): number;
      get mozMovementX(): number;
      get mozMovementY(): number;
      get webkitMovementX(): number;
      get webkitMovementY(): number;
      get msMovementX(): number;
      get msMovementY(): number;
      getModifierState(_keyArg: string): boolean;
      initMouseEvent(_typeArg: string, _canBubbleArg: boolean, _cancelableArg: boolean, _viewArg: Window, _detailArg: number, _screenXArg: number, _screenYArg: number, _clientXArg: number, _clientYArg: number, _ctrlKeyArg: boolean, _altKeyArg: boolean, _shiftKeyArg: boolean, _metaKeyArg: boolean, _buttonArg: number, _relatedTargetArg: EventTarget): void;
  }

}
declare module '@transmutejs/runtime/dom/living/events/ui-event' {
  import { XSMLShadowRoot } from '@transmutejs/runtime/dom/living/nodes/shadow-root';
  export class UIEventImpl extends Event implements UIEvent {
      detail: number;
      view: Window;
      which: number;
      inputIndex: number;
      shdaowRoot: XSMLShadowRoot | null;
      constructor(typeArg: string, eventInitDict?: UIEventInit & {
          shadowRoot?: XSMLShadowRoot;
      });
      initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window, _detailArg?: number): void;
  }

}
declare module '@transmutejs/runtime/dom/living/helpers/attributes' {
  import { ElementImpl } from '@transmutejs/runtime/dom/living/nodes/element';
  import { AttrImpl } from '@transmutejs/runtime/dom/living/attributes/attr';
  export const hasAttribute: (element: ElementImpl, A: AttrImpl) => boolean;
  export const hasAttributeByName: (element: any, name: any) => any;
  export const hasAttributeByNameNS: (element: any, namespace: any, localName: any) => any;
  export const changeAttribute: (element: any, attribute: any, value: any) => void;
  export const appendAttribute: (element: any, attribute: any) => void;
  export const removeAttribute: (element: any, attribute: any) => void;
  export const replaceAttribute: (element: any, oldAttr: any, newAttr: any) => void;
  export const getAttributeByName: (element: ElementImpl, name: string) => AttrImpl;
  export const getAttributeByNameNS: (element: ElementImpl, namespace: string, localName: string) => AttrImpl;
  export const getAttributeValue: (element: ElementImpl, localName: string) => string;
  export const getAttributeValueNS: (element: ElementImpl, namespace: string, localName: string) => string;
  export const setAttribute: (element: ElementImpl, attr: AttrImpl) => AttrImpl;
  export const setAttributeValue: (element: ElementImpl, localName: string, value: any, prefix: string, namespace: string) => void;
  export const setAnExistingAttributeValue: (attribute: AttrImpl, value: string) => void;
  export const removeAttributeByName: (element: ElementImpl, name: string) => AttrImpl;
  export const removeAttributeByNameNS: (element: ElementImpl, namespace: any, localName: any) => AttrImpl;
  export const attributeNames: (element: ElementImpl) => string[];
  export const hasAttributes: (element: ElementImpl) => boolean;

}
declare module '@transmutejs/runtime/dom/living/helpers/create-element' {
  import { XSMLShadowRoot } from '@transmutejs/runtime/dom/living/nodes/shadow-root';
  export function getValidTagNames(namespace: string, name: string): any;
  export function createElement(document: XSMLShadowRoot, localName: string, namespace: string, prefix?: string, isValue?: boolean, synchronousCE?: boolean): any;
  export function internalCreateElementNSSteps(document: XSMLShadowRoot, namespace: string, qualifiedName: string, options: any): any;

}
declare module '@transmutejs/runtime/dom/living/helpers/internal-constants' {
  import SymbolTree from 'symbol-tree';
  export const cloningSteps: unique symbol;
  export const domSymbolTree: SymbolTree<any>;

}
declare module '@transmutejs/runtime/dom/living/helpers/mutation-observers' {
  export const MUTATION_TYPE: {
      ATTRIBUTES: string;
      CHARACTER_DATA: string;
      CHILD_LIST: string;
  };
  export const signalSlotList: Array<EventTarget>;
  export function queueMutationRecord(type: any, target: any, name: any, namespace: any, oldValue: any, addedNodes: any, removedNodes: any, previousSibling: any, nextSibling: any): void;
  export function queueTreeMutationRecord(target: any, addedNodes: any, removedNodes: any, previousSibling: any, nextSibling: any): void;
  export function queueAttributeMutationRecord(target: any, name: any, namespace: any, oldValue: any): void;
  export function queueMutationObserverMicrotask(): void;

}
declare module '@transmutejs/runtime/dom/living/helpers/namespaces' {
  export const HTML_NS = "http://www.w3.org/1999/xhtml";
  export const MATHML_NS = "http://www.w3.org/1998/Math/MathML";
  export const SVG_NS = "http://www.w3.org/2000/svg";
  export const XLINK_NS = "http://www.w3.org/1999/xlink";
  export const XML_NS = "http://www.w3.org/XML/1998/namespace";
  export const XMLNS_NS = "http://www.w3.org/2000/xmlns/";

}
declare module '@transmutejs/runtime/dom/living/helpers/node' {
  import { XSMLBaseDocument, XSMLNode } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export function nodeLength(node: XSMLNode): number;
  export function nodeRoot(node: XSMLNode): XSMLNode;
  export function isInclusiveAncestor(ancestorNode: XSMLNode, node: XSMLNode): boolean;
  export function isFollowing(nodeA: XSMLNode, nodeB: XSMLNode): boolean;
  export function clone(node: NodeImpl, document?: XSMLBaseDocument, cloneChildren?: boolean): any;

}
declare module '@transmutejs/runtime/dom/living/helpers/runtime-script-errors' {
  export function reportException(hostObject: any, error: Error, filenameHint?: string): void;

}
declare module '@transmutejs/runtime/dom/living/helpers/shadow-dom' {
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export function isValidHostElementName(name: string): boolean;
  export function isNode(nodeImpl: NodeImpl): boolean;
  export function isShadowRoot(nodeImpl: NodeImpl): boolean;
  export function isSlotable(nodeImpl: NodeImpl): boolean;
  export function isSlot(nodeImpl: NodeImpl): boolean;
  export function isShadowInclusiveAncestor(ancestor: any, node: any): boolean;
  export function retarget(a: NodeImpl, b: NodeImpl): NodeImpl;
  export function getEventTargetParent(eventTarget: any, event: any): any;
  export function shadowIncludingRoot(node: NodeImpl): any;
  export function assignSlot(slotable: any): void;
  export function assignSlotable(slot: any): void;
  export function assignSlotableForTree(root: any): void;
  export function findSlotable(slot: any): any[];
  export function findFlattenedSlotables(slot: any): any[];
  export function findSlot(slotable: any, openFlag?: any): any;
  export function signalSlotChange(slot: any): void;
  export function shadowIncludingInclusiveDescendantsIterator(node: any): any;
  export function shadowIncludingDescendantsIterator(node: any): Generator<any, void, any>;

}
declare module '@transmutejs/runtime/dom/living/helpers/strings' {
  export const asciiWhitespaceRe: RegExp;
  export const asciiLowercase: (s: string) => string;
  export const asciiUppercase: (s: string) => string;
  export const stripNewlines: (s: string) => string;
  export const stripLeadingAndTrailingASCIIWhitespace: (s: string) => string;
  export const stripAndCollapseASCIIWhitespace: (s: string) => string;
  export const isValidSimpleColor: (s: string) => boolean;
  export const asciiCaseInsensitiveMatch: (a: string, b: string) => boolean;
  export const parseInteger: (input: string) => number;
  export const parseNonNegativeInteger: (input: string) => number;
  export const isValidFloatingPointNumber: (str: string) => boolean;
  export const parseFloatingPointNumber: (str: string) => number;
  export const splitOnASCIIWhitespace: (str: string) => any[];
  export const splitOnCommas: (str: string) => any[];

}
declare module '@transmutejs/runtime/dom/living/helpers/style-rules' {
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export const invalidateStyleCache: (elementImpl: NodeImpl) => void;

}
declare module '@transmutejs/runtime/dom/living/mutation-observer/mutation-observer' {
  export class MutationObserverImpl implements MutationObserver {
      _callback: MutationCallback;
      _nodeList: Node[];
      _recordQueue: any[];
      _id: number;
      constructor(globalObject: any, args: any);
      disconnect(): void;
      takeRecords(): MutationRecord[];
      observe(target: Node, options?: MutationObserverInit): void;
  }

}
declare module '@transmutejs/runtime/dom/living/mutation-observer/mutation-record' {
  import { NodeListImpl } from '@transmutejs/runtime/dom/living/nodes/node-list';
  export class MutationRecordImpl implements MutationRecord {
      attributeName: string;
      attributeNamespace: string;
      nextSibling: Node;
      oldValue: string;
      previousSibling: Node;
      target: Node;
      type: MutationRecordType;
      _hostObject: any;
      _addedNodes: Node[];
      _removedNodes: Node[];
      constructor(hostObject: any, args: any, privateData: any);
      get addedNodes(): NodeListImpl<Node>;
      get removedNodes(): NodeListImpl<Node>;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/document-type' {
  import { XSMLDocument as XSMLNativeDocument } from '@transmutejs/runtime/xsml/document';
  import { CreateXSMLType } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export class DocumentTypeImpl extends NodeImpl implements CreateXSMLType<DocumentType> {
      name: string;
      publicId: string;
      systemId: string;
      constructor(hostObject: XSMLNativeDocument, _args: any, privateData: {
          name: string;
          publicId: string;
          systemId: string;
      });
      after(...nodes: (string | Node)[]): void;
      before(...nodes: (string | Node)[]): void;
      remove(): void;
      replaceWith(...nodes: (string | Node)[]): void;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/element' {
  import { CreateXSMLType, XSMLBaseDocument } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { AttrImpl } from '@transmutejs/runtime/dom/living/attributes/attr';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export class ElementImpl extends NodeImpl implements CreateXSMLType<Element> {
      attributes: NamedNodeMap;
      clientHeight: number;
      clientLeft: number;
      clientTop: number;
      clientWidth: number;
      id: string;
      localName: string;
      namespaceURI: string;
      onfullscreenchange: (this: Element, ev: Event) => any;
      onfullscreenerror: (this: Element, ev: Event) => any;
      outerHTML: string;
      part: DOMTokenList;
      prefix: string;
      scrollHeight: number;
      scrollLeft: number;
      scrollTop: number;
      scrollWidth: number;
      shadowRoot: ShadowRoot;
      slot: string;
      tagName: string;
      ariaAtomic: string;
      ariaAutoComplete: string;
      ariaBusy: string;
      ariaChecked: string;
      ariaColCount: string;
      ariaColIndex: string;
      ariaColSpan: string;
      ariaCurrent: string;
      ariaDisabled: string;
      ariaExpanded: string;
      ariaHasPopup: string;
      ariaHidden: string;
      ariaInvalid: string;
      ariaKeyShortcuts: string;
      ariaLabel: string;
      ariaLevel: string;
      ariaLive: string;
      ariaModal: string;
      ariaMultiLine: string;
      ariaMultiSelectable: string;
      ariaOrientation: string;
      ariaPlaceholder: string;
      ariaPosInSet: string;
      ariaPressed: string;
      ariaReadOnly: string;
      ariaRequired: string;
      ariaRoleDescription: string;
      ariaRowCount: string;
      ariaRowIndex: string;
      ariaRowSpan: string;
      ariaSelected: string;
      ariaSetSize: string;
      ariaSort: string;
      ariaValueMax: string;
      ariaValueMin: string;
      ariaValueNow: string;
      ariaValueText: string;
      role: string;
      innerHTML: string;
      nextElementSibling: Element;
      previousElementSibling: Element;
      assignedSlot: HTMLSlotElement;
      _version: number;
      _attributeList: AttrImpl[];
      _namespaceURI: string | null;
      _prefix: string | null;
      _localName: string;
      _ceState: string | null;
      _ceDefinition: string | null;
      _isValue: boolean;
      _ownerDocument: XSMLBaseDocument;
      _attributesByNameMap: Map<string, AttrImpl[]>;
      constructor(hostObject: any, _args: any, privateData: {
          namespace?: string;
          prefix?: string;
          localName: string;
          ceState?: string;
          ceDefinition?: string;
          isValue?: boolean;
      });
      get ownerDocument(): XSMLBaseDocument;
      get className(): string;
      set className(value: string);
      get classList(): any;
      attachShadow(init: ShadowRootInit): ShadowRoot;
      checkVisibility(options?: CheckVisibilityOptions): boolean;
      closest<K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K];
      closest<K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K];
      closest<K extends keyof MathMLElementTagNameMap>(selector: K): MathMLElementTagNameMap[K];
      closest<E extends Element = Element>(selectors: string): E;
      computedStyleMap(): StylePropertyMapReadOnly;
      getAttribute(qualifiedName: string): string;
      getAttributeNS(namespace: string, localName: string): string;
      getAttributeNames(): string[];
      getAttributeNode(qualifiedName: string): Attr;
      getAttributeNodeNS(namespace: string, localName: string): Attr;
      getBoundingClientRect(): DOMRect;
      getClientRects(): DOMRectList;
      getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;
      getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof MathMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<MathMLElementTagNameMap[K]>;
      getElementsByTagName<K extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K]>;
      getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1999/xhtml', localName: string): HTMLCollectionOf<HTMLElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/2000/svg', localName: string): HTMLCollectionOf<SVGElement>;
      getElementsByTagNameNS(namespaceURI: 'http://www.w3.org/1998/Math/MathML', localName: string): HTMLCollectionOf<MathMLElement>;
      getElementsByTagNameNS(namespace: string, localName: string): HTMLCollectionOf<Element>;
      hasAttribute(qualifiedName: string): boolean;
      hasAttributeNS(namespace: string, localName: string): boolean;
      hasAttributes(): boolean;
      hasPointerCapture(pointerId: number): boolean;
      insertAdjacentElement(where: InsertPosition, element: Element): Element;
      insertAdjacentHTML(position: InsertPosition, text: string): void;
      insertAdjacentText(where: InsertPosition, data: string): void;
      matches(selectors: string): boolean;
      releasePointerCapture(pointerId: number): void;
      removeAttribute(qualifiedName: string): void;
      removeAttributeNS(namespace: string, localName: string): void;
      removeAttributeNode(attr: Attr): Attr;
      requestFullscreen(options?: FullscreenOptions): Promise<void>;
      requestPointerLock(): void;
      scroll(options?: ScrollToOptions): void;
      scroll(x: number, y: number): void;
      scrollBy(options?: ScrollToOptions): void;
      scrollBy(x: number, y: number): void;
      scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;
      scrollTo(options?: ScrollToOptions): void;
      scrollTo(x: number, y: number): void;
      setAttribute(qualifiedName: string, value: string): void;
      setAttributeNS(namespace: string, qualifiedName: string, value: string): void;
      setAttributeNode(attr: Attr): Attr;
      setAttributeNodeNS(attr: Attr): Attr;
      setPointerCapture(pointerId: number): void;
      toggleAttribute(qualifiedName: string, force?: boolean): boolean;
      webkitMatchesSelector(selectors: string): boolean;
      animate(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions): Animation;
      getAnimations(options?: GetAnimationsOptions): Animation[];
      after(...nodes: (string | Node)[]): void;
      before(...nodes: (string | Node)[]): void;
      remove(): void;
      replaceWith(...nodes: (string | Node)[]): void;
      append(...nodes: (string | Node)[]): void;
      prepend(...nodes: (string | Node)[]): void;
      querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K];
      querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K];
      querySelector<K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K];
      querySelector<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLElementDeprecatedTagNameMap[K];
      querySelector<E extends Element = Element>(selectors: string): E;
      querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
      querySelectorAll<K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<MathMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<HTMLElementDeprecatedTagNameMap[K]>;
      querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
      replaceChildren(...nodes: (string | Node)[]): void;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/html-element' {
  /// <reference types="babylonjs" />
  import { CreateXSMLType } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { ElementImpl } from '@transmutejs/runtime/dom/living/nodes/element';
  export class HTMLElementImpl extends ElementImpl implements CreateXSMLType<HTMLElement> {
      accessKey: string;
      accessKeyLabel: string;
      autocapitalize: string;
      dir: string;
      draggable: boolean;
      hidden: boolean;
      inert: boolean;
      innerText: string;
      lang: string;
      offsetHeight: number;
      offsetLeft: number;
      offsetParent: Element;
      offsetTop: number;
      offsetWidth: number;
      outerText: string;
      popover: string;
      spellcheck: boolean;
      title: string;
      translate: boolean;
      attachInternals(): ElementInternals;
      click(): void;
      hidePopover(): void;
      showPopover(): void;
      togglePopover(force?: boolean): void;
      attributeStyleMap: StylePropertyMap;
      style: CSSStyleDeclaration;
      contentEditable: string;
      enterKeyHint: string;
      inputMode: string;
      isContentEditable: boolean;
      onabort: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onanimationcancel: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationend: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationiteration: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onanimationstart: (this: GlobalEventHandlers, ev: AnimationEvent) => any;
      onauxclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onbeforeinput: (this: GlobalEventHandlers, ev: InputEvent) => any;
      onblur: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      oncancel: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplay: (this: GlobalEventHandlers, ev: Event) => any;
      oncanplaythrough: (this: GlobalEventHandlers, ev: Event) => any;
      onchange: (this: GlobalEventHandlers, ev: Event) => any;
      onclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onclose: (this: GlobalEventHandlers, ev: Event) => any;
      oncontextmenu: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      oncopy: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      oncuechange: (this: GlobalEventHandlers, ev: Event) => any;
      oncut: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      ondblclick: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      ondrag: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragend: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragenter: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragleave: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragover: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondragstart: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondrop: (this: GlobalEventHandlers, ev: DragEvent) => any;
      ondurationchange: (this: GlobalEventHandlers, ev: Event) => any;
      onemptied: (this: GlobalEventHandlers, ev: Event) => any;
      onended: (this: GlobalEventHandlers, ev: Event) => any;
      onerror: OnErrorEventHandlerNonNull;
      onfocus: (this: GlobalEventHandlers, ev: FocusEvent) => any;
      onformdata: (this: GlobalEventHandlers, ev: FormDataEvent) => any;
      ongotpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      oninput: (this: GlobalEventHandlers, ev: Event) => any;
      oninvalid: (this: GlobalEventHandlers, ev: Event) => any;
      onkeydown: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeypress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onkeyup: (this: GlobalEventHandlers, ev: KeyboardEvent) => any;
      onload: (this: GlobalEventHandlers, ev: Event) => any;
      onloadeddata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadedmetadata: (this: GlobalEventHandlers, ev: Event) => any;
      onloadstart: (this: GlobalEventHandlers, ev: Event) => any;
      onlostpointercapture: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onmousedown: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseenter: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseleave: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmousemove: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseout: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseover: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onmouseup: (this: GlobalEventHandlers, ev: MouseEvent) => any;
      onpaste: (this: GlobalEventHandlers, ev: ClipboardEvent) => any;
      onpause: (this: GlobalEventHandlers, ev: Event) => any;
      onplay: (this: GlobalEventHandlers, ev: Event) => any;
      onplaying: (this: GlobalEventHandlers, ev: Event) => any;
      onpointercancel: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerdown: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerenter: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerleave: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointermove: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerout: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerover: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onpointerup: (this: GlobalEventHandlers, ev: PointerEvent) => any;
      onprogress: (this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any;
      onratechange: (this: GlobalEventHandlers, ev: Event) => any;
      onreset: (this: GlobalEventHandlers, ev: Event) => any;
      onresize: (this: GlobalEventHandlers, ev: UIEvent) => any;
      onscroll: (this: GlobalEventHandlers, ev: Event) => any;
      onscrollend: (this: GlobalEventHandlers, ev: Event) => any;
      onsecuritypolicyviolation: (this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any;
      onseeked: (this: GlobalEventHandlers, ev: Event) => any;
      onseeking: (this: GlobalEventHandlers, ev: Event) => any;
      onselect: (this: GlobalEventHandlers, ev: Event) => any;
      onselectionchange: (this: GlobalEventHandlers, ev: Event) => any;
      onselectstart: (this: GlobalEventHandlers, ev: Event) => any;
      onslotchange: (this: GlobalEventHandlers, ev: Event) => any;
      onstalled: (this: GlobalEventHandlers, ev: Event) => any;
      onsubmit: (this: GlobalEventHandlers, ev: SubmitEvent) => any;
      onsuspend: (this: GlobalEventHandlers, ev: Event) => any;
      ontimeupdate: (this: GlobalEventHandlers, ev: Event) => any;
      ontoggle: (this: GlobalEventHandlers, ev: Event) => any;
      ontouchcancel?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchend?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchmove?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontouchstart?: (this: GlobalEventHandlers, ev: TouchEvent) => any;
      ontransitioncancel: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionend: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionrun: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      ontransitionstart: (this: GlobalEventHandlers, ev: TransitionEvent) => any;
      onvolumechange: (this: GlobalEventHandlers, ev: Event) => any;
      onwaiting: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationend: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationiteration: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkitanimationstart: (this: GlobalEventHandlers, ev: Event) => any;
      onwebkittransitionend: (this: GlobalEventHandlers, ev: Event) => any;
      onwheel: (this: GlobalEventHandlers, ev: WheelEvent) => any;
      onbeforexrselect: (this: GlobalEventHandlers, ev: XRSessionEvent) => any;
      autofocus: boolean;
      dataset: DOMStringMap;
      nonce?: string;
      tabIndex: number;
      blur(): void;
      focus(options?: FocusOptions): void;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/node-list' {
  export class NodeListImpl<T extends Node> implements NodeList {
      #private;
      constructor(hostObject: any, args: any, privateData: any);
      [index: number]: T;
      get length(): number;
      [Symbol.iterator](): IterableIterator<T>;
      item(index: number): T;
      forEach(callbackfn: (value: T, key: number, parent: NodeListImpl<T>) => void, thisArg?: any): void;
      entries(): IterableIterator<[number, T]>;
      keys(): IterableIterator<number>;
      values(): IterableIterator<T>;
      _update(): void;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/node' {
  import { XSMLBaseDocument, XSMLNode } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { XSMLShadowRoot } from '@transmutejs/runtime/dom/living/nodes/shadow-root';
  import { XSMLDocument as XSMLNativeDocument } from '@transmutejs/runtime/xsml/document';
  type ObserverItem = {
      observer: MutationObserver;
      options?: MutationObserverInit;
      source?: ObserverItem;
  };
  export class NodeImpl extends EventTarget implements XSMLNode {
      #private;
      readonly ELEMENT_NODE: 1;
      static readonly ELEMENT_NODE: 1;
      readonly ATTRIBUTE_NODE: 2;
      static readonly ATTRIBUTE_NODE: 2;
      readonly TEXT_NODE: 3;
      static readonly TEXT_NODE: 3;
      readonly CDATA_SECTION_NODE: 4;
      static readonly CDATA_SECTION_NODE: 4;
      readonly ENTITY_REFERENCE_NODE: 5;
      static readonly ENTITY_REFERENCE_NODE: 5;
      readonly ENTITY_NODE: 6;
      static readonly ENTITY_NODE: 6;
      readonly PROCESSING_INSTRUCTION_NODE: 7;
      static readonly PROCESSING_INSTRUCTION_NODE: 7;
      readonly COMMENT_NODE: 8;
      static readonly COMMENT_NODE: 8;
      readonly DOCUMENT_NODE: 9;
      static readonly DOCUMENT_NODE: 9;
      readonly DOCUMENT_TYPE_NODE: 10;
      static readonly DOCUMENT_TYPE_NODE: 10;
      readonly DOCUMENT_FRAGMENT_NODE: 11;
      static readonly DOCUMENT_FRAGMENT_NODE: 11;
      readonly NOTATION_NODE: 12;
      static readonly NOTATION_NODE: 12;
      /**
       * A node that represents a spatial object, which contains: transform, mesh, light, etc.
       */
      readonly SPATIAL_OBJECT_NODE: 13;
      static readonly SPATIAL_OBJECT_NODE: 13;
      readonly DOCUMENT_POSITION_DISCONNECTED: 1;
      static readonly DOCUMENT_POSITION_DISCONNECTED: 1;
      readonly DOCUMENT_POSITION_PRECEDING: 2;
      static readonly DOCUMENT_POSITION_PRECEDING: 2;
      readonly DOCUMENT_POSITION_FOLLOWING: 4;
      static readonly DOCUMENT_POSITION_FOLLOWING: 4;
      readonly DOCUMENT_POSITION_CONTAINS: 8;
      static readonly DOCUMENT_POSITION_CONTAINS: 8;
      readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
      static readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
      readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
      static readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
      baseURI: string;
      nodeType: number;
      _version: number;
      _attached: boolean;
      _hostObject: XSMLNativeDocument;
      _host: NodeImpl;
      _ownerDocument: XSMLBaseDocument;
      _shadowRoot: XSMLShadowRoot | null;
      _assignedSlot: HTMLSlotElement | null;
      _assignedNodes: Array<NodeImpl>;
      _referencedRanges: Set<Range>;
      _registeredObserverList: Array<ObserverItem>;
      _memoizedQueries: {};
      _ceState: string;
      constructor(hostObject: XSMLNativeDocument, _args: any, _privateData: any);
      get parentNode(): ParentNode;
      get nodeName(): string;
      get firstChild(): ChildNode;
      get lastChild(): ChildNode;
      get childNodes(): NodeListOf<ChildNode>;
      get isConnected(): boolean;
      get ownerDocument(): XSMLBaseDocument | null;
      get nextSibling(): any;
      get previousSibling(): any;
      get parentElement(): any;
      get nodeValue(): string;
      set nodeValue(value: string);
      get textContent(): string;
      set textContent(value: string);
      _modified(): void;
      _childTextContentChangeSteps(): void;
      _clearMemoizedQueries(): void;
      _descendantRemoved(parent: XSMLNode, child: XSMLNode): void;
      _descendantAdded(parent: XSMLNode, child: XSMLNode): void;
      _attach(): void;
      _detach(): void;
      appendChild<T extends XSMLNode>(node: T): T;
      cloneNode(deep?: boolean): Node;
      compareDocumentPosition(other: Node): number;
      contains(other: Node): boolean;
      getRootNode(options?: GetRootNodeOptions): Node;
      hasChildNodes(): boolean;
      insertBefore<T extends XSMLNode>(node: T, child: XSMLNode): T;
      isDefaultNamespace(_namespace: string): boolean;
      isEqualNode(otherNode: XSMLNode): boolean;
      isSameNode(otherNode: XSMLNode): boolean;
      lookupNamespaceURI(prefix: string): string;
      lookupPrefix(namespace: string): string;
      normalize(): void;
      removeChild<T extends XSMLNode>(child: T): T;
      replaceChild<T1 extends XSMLNode, T2 extends Node>(node: T1, child: T1): T2;
      _preInsertValidity(nodeImpl: any, childImpl: any): void;
      _preInsert(nodeImpl: NodeImpl, childImpl: NodeImpl): NodeImpl;
      _insert(nodeImpl: NodeImpl, childImpl: NodeImpl, suppressObservers?: any): void;
      _append(nodeImpl: NodeImpl): NodeImpl;
      _replace(nodeImpl: NodeImpl, childImpl: NodeImpl): NodeImpl;
      _replaceAll(nodeImpl: NodeImpl): void;
      _preRemove(childImpl: NodeImpl): NodeImpl;
      _remove(nodeImpl: NodeImpl, suppressObservers?: any): void;
      get children(): HTMLCollection;
      get firstElementChild(): Element;
      get lastElementChild(): Element;
      get childElementCount(): number;
  }
  export {};

}
declare module '@transmutejs/runtime/dom/living/nodes/shadow-root' {
  import nwsapi from 'nwsapi';
  import { XSMLDocument as XSMLNativeDocument } from '@transmutejs/runtime/xsml/document';
  import { CreateXSMLType, XSMLBaseDocument, XSMLElement, XSMLNode } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { SpatialObject } from '@transmutejs/runtime/dom/living/nodes/spatial-object';
  import { InteractiveDynamicTexture } from '@transmutejs/runtime/gui/2d/texture';
  export class XSMLShadowRoot extends XSMLBaseDocument implements CreateXSMLType<ShadowRoot> {
      doctype: DocumentType;
      documentURI: string;
      domain: string;
      charset: string;
      contentType: string;
      /** @internal */
      _targetSpatialObject: SpatialObject;
      /** @internal */
      _interactiveDynamicTexture: InteractiveDynamicTexture;
      /** @internal */
      _nwsapi: nwsapi.NWSAPI;
      /**
       * Store all children of this shadow root.
       */
      private _allChildren;
      constructor(hostObject: XSMLNativeDocument, args: [ShadowRootInit?], privateData: {
          target: SpatialObject;
      });
      getNativeTexture(): InteractiveDynamicTexture;
      getAnimations(): Animation[];
      innerHTML: string;
      get childElementCount(): number;
      get firstElementChild(): Element;
      get lastElementChild(): Element;
      append(...nodes: (string | Node)[]): void;
      prepend(...nodes: (string | Node)[]): void;
      appendChild<T extends XSMLNode>(node: T): T;
      removeChild<T extends XSMLNode>(child: T): T;
      querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K];
      querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K];
      querySelector<K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K];
      querySelector<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLElementDeprecatedTagNameMap[K];
      querySelector<E extends Element = Element>(selectors: string): E;
      querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;
      querySelectorAll<K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<MathMLElementTagNameMap[K]>;
      querySelectorAll<K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<HTMLElementDeprecatedTagNameMap[K]>;
      querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
      replaceChildren(...nodes: (string | Node)[]): void;
      delegatesFocus: boolean;
      host: Element;
      mode: ShadowRootMode;
      onslotchange: (this: ShadowRoot, ev: Event) => any;
      slotAssignment: SlotAssignmentMode;
      /**
       * Get elements by its id.
       */
      getElementById(elementId: string): HTMLElement;
      /**
       * Get elements by class name
       */
      getElementsByClassName(elementClassName: string): XSMLElement[];
      /**
       * This method is used to get all elements from the this._allChildren, including the element's children recursively.
       */
      private getAllElements;
      adoptedStyleSheets: CSSStyleSheet[];
      fullscreenElement: Element;
      pictureInPictureElement: Element;
      pointerLockElement: Element;
      styleSheets: StyleSheetList;
      elementFromPoint(x: number, y: number): Element;
      elementsFromPoint(x: number, y: number): Element[];
      _lastFocusedElement: XSMLElement;
      _adoptNode(node: XSMLNode): XSMLNode;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/spatial-document' {
  import * as BABYLON from 'babylonjs';
  import { XSMLBaseDocument } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { XSMLDocument as XSMLNativeDocument } from '@transmutejs/runtime/xsml/document';
  import { SpatialObject } from '@transmutejs/runtime/dom/living/nodes/spatial-object';
  import { XSMLShadowRoot } from '@transmutejs/runtime/dom/living/nodes/shadow-root';
  type DocumentInitOptions = {
      screenWidth: number;
      screenHeight: number;
  };
  /**
   * The `SpatialDocument` is a new Web API, it represents the document object in space computing.
   * It is the root of the document tree, and provides the primary access to the document's data.
   */
  export class SpatialDocument extends XSMLBaseDocument {
      #private;
      doctype: DocumentType;
      documentURI: string;
      domain: string;
      charset: string;
      contentType: string;
      /** Used for spatial objects */
      _idsOfSpatialObjects: {
          [key: string]: SpatialObject;
      };
      private _guidSOfSpatialObjects;
      constructor(xsmlDocument: XSMLNativeDocument, options?: DocumentInitOptions);
      /**
       * Get the current scene from the space.
       */
      get scene(): BABYLON.Scene;
      get screenWidth(): number;
      get screenHeight(): number;
      /**
       * This returns this space pose(position, rotation) in the world.
       */
      get poseInWorld(): import("@transmutejs/runtime/xsml/common").Pose;
      attachShadow(target: SpatialObject, options?: ShadowRootInit): XSMLShadowRoot;
      /**
       * Create an element by tag name which could be append to a `XSMLShadowRoot`.
       * @param tagName the tag name: "div", "span", "b", "a", "button" ...
       */
      createElement(tagName: string): Element;
      /**
       * Create a new spatial object by the tag name.
       * @param tagName the tag name of the spatial element.
       */
      createSpatialObject(tagName: string, attributes: any): SpatialObject;
      /**
       * This method create a new `SpatialObject` by a reference to the native object `BABYLON.Node`, it's useful to create `SpatialObject`s which is created by model or created by Babylon.js.
       * @param nativeObject The native object, namely `BABYLON.Node`.
       * @returns a new `SpatialObject` instance to reference the native object.
       */
      createSpatialObjectByNativeReference(nativeObject: BABYLON.Node): SpatialObject;
      /**
       * The `getSpatialObjectById()` method of the `SpatialDocument` interface returns an `SpatialObject` object representing the object whose id property matches the specified string.
       * Since element IDs are required to be unique if specified, they're a useful way to get access to a specific element quickly.
       */
      getSpatialObjectById(id: string): SpatialObject;
      /**
       * This is used to get the spatial object by the transmute GUID.
       * @internal
       */
      _getSpatialObjectByGuid(guid: string): SpatialObject;
      /**
       * Start watching the input event such as: pointer, guesture, keyboard, etc.
       */
      watchInputEvent(): void;
      /**
       * Get the node by the id.
       */
      getNodeById(id: string): BABYLON.Node;
      /**
       * Get the material by the id.
       */
      getMaterialById(id: string): BABYLON.Material;
  }
  export {};

}
declare module '@transmutejs/runtime/dom/living/nodes/spatial-object' {
  import * as BABYLON from 'babylonjs';
  import { VGO_GUID_SYMBOL } from '@transmutejs/babylonjs-adapter/common';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { XSMLShadowRoot } from '@transmutejs/runtime/dom/living/nodes/shadow-root';
  export class SpatialObject extends NodeImpl {
      _scene: BABYLON.Scene;
      _internalObject: BABYLON.Node;
      _id: string;
      _shadowRoot: XSMLShadowRoot;
      [VGO_GUID_SYMBOL]: string;
      constructor(hostObject: XSMLDocument, _args: any, privateData: {
          object: BABYLON.Node;
          scene: BABYLON.Scene;
      });
      get id(): string;
      set id(value: string);
      /**
       * Returns the native Babylon.js object.
       */
      asNativeType<T extends BABYLON.Node>(): T;
      isTransformNode(): boolean;
      isMeshNode(): boolean;
      /** @internal */
      _hasAttachedShadow(): boolean;
      /** @internal */
      _getAttachedShadow(): XSMLShadowRoot;
      /** @internal */
      _dispatchPointerEvent(type: number): void;
      /**
       * Returns the `ShadowRoot` of this `SpatialObject` instance, it's used to get the GUI elements from script.
       */
      get shadowRoot(): XSMLShadowRoot;
      /**
       * The `SpatialObject.attachShadow()` method attaches a shadow DOM tree to the specified element and returns
       * a reference to its ShadowRoot.
       */
      attachShadow(options?: ShadowRootInit): XSMLShadowRoot;
      attachCanvasTexture(width?: number, height?: number): BABYLON.DynamicTexture;
  }

}
declare module '@transmutejs/runtime/dom/living/nodes/text' {
  import { XSMLDocument as XSMLNativeDocument } from '@transmutejs/runtime/xsml/document';
  import { CreateXSMLType } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export class CharacterDataImpl extends NodeImpl implements CreateXSMLType<CharacterData> {
      _data: string;
      constructor(hostObject: XSMLNativeDocument, _args: any, privateData: {
          data: string;
      });
      get data(): string;
      set data(data: string);
      get length(): number;
      appendData(data: string): void;
      deleteData(offset: number, count: number): void;
      insertData(offset: number, data: string): void;
      replaceData(offset: number, count: number, data: string): void;
      substringData(offset: number, count: number): string;
      after(...nodes: (string | Node)[]): void;
      before(...nodes: (string | Node)[]): void;
      remove(): void;
      replaceWith(...nodes: (string | Node)[]): void;
      nextElementSibling: Element;
      previousElementSibling: Element;
  }
  export class TextImpl extends CharacterDataImpl implements CreateXSMLType<Text> {
      _slotableName: string;
      get assignedSlot(): any;
      constructor(hostObject: XSMLNativeDocument, args: any, privateData: {
          data: string;
      });
      _attrModifiedSlotableMixin(name: any, value: any, oldValue: any): void;
      splitText(offset: number): Text;
      get wholeText(): string;
      _initSlotableMixin(): void;
  }

}
declare module '@transmutejs/runtime/dom/living/range/abstract-range' {
  export interface BoundaryPoint {
      node: Node;
      offset: number;
  }
  export class AbstractRangeImpl implements AbstractRange {
      _hostObject: any;
      _start: BoundaryPoint;
      _end: BoundaryPoint;
      constructor(hostObject: any, args: any, privateData: any);
      get startContainer(): Node;
      get startOffset(): number;
      get endContainer(): Node;
      get endOffset(): number;
      get collapsed(): boolean;
  }

}
declare module '@transmutejs/runtime/dom/living/range/range' {
  import { AbstractRangeImpl, BoundaryPoint } from '@transmutejs/runtime/dom/living/range/abstract-range';
  export function compareBoundaryPointsPosition(bpA: BoundaryPoint, bpB: BoundaryPoint): any;
  export function validateSetBoundaryPoint(node: any, offset: any): void;
  export function setBoundaryPointStart(range: any, node: any, offset: any): void;
  export function setBoundaryPointEnd(range: any, node: any, offset: any): void;
  export class RangeImpl extends AbstractRangeImpl implements Range {
      constructor(hostObject: any, args: any, privateData: any);
      getBoundingClientRect(): DOMRect;
      getClientRects(): DOMRectList;
      get commonAncestorContainer(): any;
      setStart(node: any, offset: any): void;
      setEnd(node: any, offset: any): void;
      setStartBefore(node: any): void;
      setStartAfter(node: any): void;
      setEndBefore(node: any): void;
      setEndAfter(node: any): void;
      collapse(toStart: any): void;
      selectNode(node: any): void;
      selectNodeContents(node: any): void;
      compareBoundaryPoints(how: any, sourceRange: any): any;
      deleteContents(): void;
      extractContents(): any;
      cloneContents(): any;
      insertNode(node: any): void;
      surroundContents(newParent: any): void;
      cloneRange(): RangeImpl;
      detach(): void;
      isPointInRange(node: any, offset: any): boolean;
      comparePoint(node: any, offset: any): 0 | 1 | -1;
      intersectsNode(node: any): boolean;
      toString(): string;
      createContextualFragment(fragment: any): any;
      get _root(): import("@transmutejs/runtime/dom/xsml-interfaces").XSMLNode;
      _setLiveRangeStart(node: any, offset: any): void;
      _setLiveRangeEnd(node: any, offset: any): void;
      START_TO_START: 0;
      START_TO_END: 1;
      END_TO_END: 2;
      END_TO_START: 3;
  }

}
declare module '@transmutejs/runtime/dom/utils' {
  export const simultaneousIterators: (first: any, second: any) => Generator<any[], void, unknown>;

}
declare module '@transmutejs/runtime/dom/xsml-interfaces' {
  import { SpatialDocument } from '@transmutejs/runtime/xsml/webapis';
  import { AttrImpl } from '@transmutejs/runtime/dom/living/attributes/attr';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  export type CreateXSMLType<T> = Omit<T, 'ownerDocument'> & {
      ownerDocument: Document | XSMLBaseDocument | null;
  };
  export type XSMLNode = CreateXSMLType<Node>;
  export type XSMLChildNode = CreateXSMLType<ChildNode>;
  export type XSMLParentNode = CreateXSMLType<ParentNode>;
  export type XSMLElement = CreateXSMLType<Element>;
  /**
   * This interface `XSMLBaseDocument` is the base interface for all XSML documents which contains:
   *
   * - `SpatialDocument` this is the main document for the XSML to represent the spatial scene.
   * - `XSMLShadowRoot` this is the shadow root to describe interactive widget that is attached to a spatial object.
   */
  export class XSMLBaseDocument extends NodeImpl implements XSMLNode {
      readonly doctype: DocumentType | null;
      readonly documentURI: string;
      readonly domain: string;
      readonly charset: string;
      readonly contentType: string;
      /**
       * Gets a value that indicates whether standards-compliant mode is switched on for the object.
       */
      readonly compatMode: 'BackCompat' | 'CSS1Compat';
      /**
       * Gets a reference to the root node of the document.
       */
      readonly documentElement: SpatialDocument | Element;
      hoverElement: Element | null;
      activeElement: Element | null;
      /**
       * Sets or gets a value that indicates whether the document can be edited.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/designMode)
       */
      designMode: 'on' | 'off';
      _styleCache: any;
      _lastFocusedElement: XSMLElement | null;
      _adoptNode(node: any): void;
      _runPreRemovingSteps(_oldNode: NodeImpl): void;
      _createAttribute({ localName, value, namespace, namespacePrefix }: {
          localName: any;
          value: any;
          namespace: any;
          namespacePrefix: any;
      }): AttrImpl;
      createTextNode(data: string): Text;
      /**
       * Returns a bitmask indicating the position of other relative to node.
       */
      compareDocumentPosition(other: Node): number;
      /**
       * Gets a value indicating whether the object currently has focus.
       *
       * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/hasFocus)
       */
      hasFocus(): boolean;
  }

}
declare module '@transmutejs/runtime/gui/2d/container' {
  import { Control2D } from '@transmutejs/runtime/gui/2d/control';
  import { InteractiveDynamicTexture } from '@transmutejs/runtime/gui/2d/texture';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  export class Container2D extends Control2D {
      /** @internal */
      protected _background: string;
      /** @internal */
      protected _adaptWidthToChildren: boolean;
      /** @internal */
      protected _adaptHeightToChildren: boolean;
      /** @internal */
      protected _contextTexture: InteractiveDynamicTexture;
      constructor(ownerNativeDocument: XSMLDocument, name?: string, isVertical?: boolean);
  }

}
declare module '@transmutejs/runtime/gui/2d/control' {
  import * as BABYLON from 'babylonjs';
  import cssstyle from 'cssstyle';
  import { ElementImpl } from '@transmutejs/runtime/dom/living/nodes/element';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { InteractiveDynamicTexture } from '@transmutejs/runtime/gui/2d/texture';
  import { Node as LayoutNode } from '@transmutejs/runtime/gui/2d/taffy-layout-wasm';
  import { NodeImpl } from '@transmutejs/runtime/dom/living/nodes/node';
  type LayoutStyle = ConstructorParameters<typeof LayoutNode>[1];
  type Rect = Partial<{
      x: number;
      y: number;
      width: number;
      height: number;
  }>;
  type BorderContext = {
      width: number;
      color: string;
      style?: string;
  };
  /**
   * A 2D Control is just like a HTMLElment.
   */
  export class Control2D extends ElementImpl {
      name: string;
      /**
       * @internal
       * The target texture that this control will render to.
       */
      _targetTexture: InteractiveDynamicTexture;
      /**
       * @internal
       */
      _layoutStyle: LayoutStyle;
      /**
       * @internal
       */
      _layoutNode: LayoutNode;
      /**
       * @internal
       */
      _lastRect: Rect;
      /**
       * @internal
       */
      _style: cssstyle.CSSStyleDeclaration;
      /**
       * If the pointer is in this control zone.
       */
      private _isPointerIn;
      constructor(ownerNativeDocument: XSMLDocument, name: string);
      /**
       * `style` returns the `CSSStyleDeclaration`.
       */
      get style(): cssstyle.CSSStyleDeclaration;
      /**
       * `targetTexture` returns the target texture that this control will render to.
       */
      get targetTexture(): InteractiveDynamicTexture;
      /**
       * If this node owns an inner text.
       */
      private get ownInnerText();
      /**
       * @internal
       * Update the target texture
       */
      updateTargetTexture(targetTexture: InteractiveDynamicTexture): void;
      /**
       * @internal
       * This method fires an update from the underlay texture.
       */
      _tryUpdate(): void;
      private _createLayoutStyle;
      /**
       * Update the layout style, it will be used when the style is changed.
       * @param forceUpdate if true, the layout style will be updated even if the style is not changed.
       * @param extraStyle the extra style that will be merged into the layout style.
       */
      private _updateLayoutStyle;
      _insert(nodeImpl: NodeImpl, childImpl: NodeImpl, suppressObservers?: any): void;
      _remove(nodeImpl: NodeImpl, suppressObservers?: any): void;
      _containsPoint(point: BABYLON.Vector2): boolean;
      _processPicking(x: number, y: number, _type?: number): void;
      _processPointerEvent(x: number, y: number, type: number): boolean;
      private get _fontFamily();
      private get _fontSize();
      private _getTextConfig;
      /**
       * This measures a given text in single-line mode and returns the width and height of the text block.
       */
      private _measureText;
      /**
       * Fix the rect size by text.
       */
      private _fixSizeByText;
      /**
       * Render the inner text in this control.
       */
      _renderInnerText(context: CanvasRenderingContext2D, rect: Rect): void;
      /**
       * Render the rectangle with background color in this control.
       */
      _renderRect(context: CanvasRenderingContext2D, rect: Rect): void;
      _getBorderContext(name?: 'top' | 'right' | 'bottom' | 'left'): BorderContext;
      _updateBorderStyle(context: CanvasRenderingContext2D, border: BorderContext): void;
      _renderBorders(context: CanvasRenderingContext2D, rect: Rect): boolean;
      /**
       * Render the controller itself.
       */
      _renderControlSelf(rect: Rect, base: Rect): void;
      /**
       * Dispose the control.
       */
      _dispose(): void;
  }
  export {};

}
declare module '@transmutejs/runtime/gui/2d/controls/button' {
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { Control2D } from '@transmutejs/runtime/gui/2d/control';
  export class Button2D extends Control2D {
      text: string;
      constructor(ownerNativeDocument: XSMLDocument);
  }

}
declare module '@transmutejs/runtime/gui/2d/taffy-layout-wasm' {
  export const AlignItems: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      Baseline: 5;
      5: "Baseline";
      Stretch: 6;
      6: "Stretch";
  }>;
  export const JustifyItems: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      Baseline: 5;
      5: "Baseline";
      Stretch: 6;
      6: "Stretch";
  }>;
  export const JustifySelf: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      Baseline: 5;
      5: "Baseline";
      Stretch: 6;
      6: "Stretch";
  }>;
  export const AlignSelf: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      Baseline: 5;
      5: "Baseline";
      Stretch: 6;
      6: "Stretch";
  }>;
  export const AlignContent: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      Stretch: 5;
      5: "Stretch";
      SpaceBetween: 6;
      6: "SpaceBetween";
      SpaceAround: 7;
      7: "SpaceAround";
  }>;
  export const Display: Readonly<{
      Flex: 0;
      0: "Flex";
      Grid: 1;
      1: "Grid";
      None: 2;
      2: "None";
  }>;
  export const FlexDirection: Readonly<{
      Row: 0;
      0: "Row";
      Column: 1;
      1: "Column";
      RowReverse: 2;
      2: "RowReverse";
      ColumnReverse: 3;
      3: "ColumnReverse";
  }>;
  export const GridAutoFlow: Readonly<{
      Row: 0;
      0: "Row";
      Column: 1;
      1: "Column";
      RowDense: 2;
      2: "RowDense";
      ColumnDense: 3;
      3: "ColumnDense";
  }>;
  export const JustifyContent: Readonly<{
      FlexStart: 0;
      0: "FlexStart";
      FlexEnd: 1;
      1: "FlexEnd";
      Start: 2;
      2: "Start";
      End: 3;
      3: "End";
      Center: 4;
      4: "Center";
      SpaceBetween: 5;
      5: "SpaceBetween";
      SpaceAround: 6;
      6: "SpaceAround";
      SpaceEvenly: 7;
      7: "SpaceEvenly";
  }>;
  export const Position: Readonly<{
      Relative: 0;
      0: "Relative";
      Absolute: 1;
      1: "Absolute";
  }>;
  export const FlexWrap: Readonly<{
      NoWrap: 0;
      0: "NoWrap";
      Wrap: 1;
      1: "Wrap";
      WrapReverse: 2;
      2: "WrapReverse";
  }>;
  export class Allocator {
      static __wrap(A: any): any;
      ptr: any;
      __destroy_into_raw(): any;
      free(): void;
      constructor();
  }
  export class Layout {
      static __wrap(A: any): any;
      ptr: any;
      __destroy_into_raw(): any;
      free(): void;
      get width(): any;
      get height(): any;
      get x(): any;
      get y(): any;
      get childCount(): number;
      child(A: any): any;
  }
  type NodeStyle = Partial<{
      height: number | string;
      width: number | string;
      minHeight: number | string;
      minWidth: number | string;
      maxHeight: number | string;
      maxWidth: number | string;
      display: number;
      position: number;
      aspectRatio: number;
      flexDirection: number;
      flexWrap: number;
      flexGrow: number;
      flexShrink: number;
      flexBasis: number;
      alignItems: number;
      alignSelf: number;
      alignContent: number;
      justifyContent: number;
      justifySelf: number;
      justifyItems: number;
      gapWidth: number;
      gapHeight: number;
      insetLeft: number;
      insetRight: number;
      insetTop: number;
      insetBottom: number;
      borderLeft: number;
      borderRight: number;
      borderTop: number;
      borderBottom: number;
      marginLeft: number;
      marginRight: number;
      marginTop: number;
      marginBottom: number;
      paddingLeft: number;
      paddingRight: number;
      paddingTop: number;
      paddingBottom: number;
  }>;
  export class Node {
      static __wrap(A: any): any;
      ptr: any;
      __destroy_into_raw(): any;
      free(): void;
      get childCount(): number;
      constructor(A: any, style: NodeStyle);
      setMeasure(A: any): void;
      addChild(A: any): void;
      removeChild(A: any): void;
      replaceChildAtIndex(A: any, g: any): void;
      removeChildAtIndex(A: any): void;
      getStyle(): any;
      setStyle(A: any): void;
      markDirty(): void;
      isDirty(): boolean;
      isChildless(): boolean;
      computeLayout(A?: any): any;
  }
  function initSync(): any;
  export { initSync };
  export default function (): Promise<any>;

}
declare module '@transmutejs/runtime/gui/2d/texture' {
  import { type Nullable, type Scene, type AbstractMesh, Observable, DynamicTexture, ClipboardInfo } from 'babylonjs';
  import { Control2D } from '@transmutejs/runtime/gui/2d/control';
  import { Container2D } from '@transmutejs/runtime/gui/2d/container';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  /**
   * The `InteractiveDynamicTexture` is copied from BabylonJS `InteractiveDynamicTexture` and modified to support the texture to interact in JSAR runtime.
   */
  export class InteractiveDynamicTexture extends DynamicTexture {
      /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */
      static AllowGPUOptimizations: boolean;
      /** Snippet ID if the content was created from the snippet server */
      snippetId: string;
      /** Observable that fires when the GUI is ready */
      onGuiReadyObservable: Observable<InteractiveDynamicTexture>;
      /** if the texture is started */
      private _started;
      /** if the texture is dirty */
      private _isDirty;
      /** if the texture is rendering */
      private _isRendering;
      private _ownerNativeDocument;
      private _pointerObserver;
      private _renderObserver;
      /**
       * This is updated at picking event and used in other hand events.
       */
      private _lastPositionInPicking;
      /** @internal */
      _rootContainer: Container2D;
      /** @internal */
      _lastPickedControl: Control2D;
      /** @internal */
      /** @internal */
      private _idealWidth;
      private _idealHeight;
      private _renderAtIdealSize;
      private _renderScale;
      /**
       * Define type to string to ensure compatibility across browsers
       * Safari doesn't support DataTransfer constructor
       */
      private _clipboardData;
      /**
       * Observable event triggered each time an clipboard event is received from the rendering canvas
       */
      onClipboardObservable: Observable<ClipboardInfo>;
      /**
       * Observable event triggered each time a pointer down is intercepted by a control
       */
      onControlPickedObservable: Observable<Control2D>;
      /**
       * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture
       */
      applyYInversionOnUpdate: boolean;
      /**
       * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).
       * Useful when you want more antialiasing
       */
      get renderScale(): number;
      set renderScale(value: number);
      /**
       * Gets the root container control
       */
      get rootContainer(): Container2D;
      /**
       * Returns an array containing the root container.
       * This is mostly used to let the Inspector introspects the ADT
       * @returns an array containing the rootContainer
       */
      getChildren(): Array<Container2D>;
      /**
       * Gets or sets the current focused control
       */
      /**
       * Gets or set information about clipboardData
       */
      get clipboardData(): string;
      set clipboardData(value: string);
      /**
       * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.
       * Options from values are PointerEventTypes
       * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP
       */
      skipBlockEvents: number;
      /**
       * If set to true, every scene render will trigger a pointer event for the GUI
       * if it is linked to a mesh or has controls linked to a mesh. This will allow
       * you to catch the pointer moving around the GUI due to camera or mesh movements,
       * but it has a performance cost.
       */
      checkPointerEveryFrame: boolean;
      /**
       * Creates a new InteractiveDynamicTexture.
       */
      constructor(name: string, ownerNativeDocument: XSMLDocument, width?: number, height?: number, scene?: Nullable<Scene>, generateMipMaps?: boolean, samplingMode?: number, invertY?: boolean);
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "InteractiveDynamicTexture"
       */
      getClassName(): string;
      /**
       * Release all resources
       */
      dispose(): void;
      private _onResize;
      start(): void;
      pause(): void;
      markAsDirty(value?: boolean): void;
      renderToTexture(): void;
      private _iterateLayoutResult;
      /**
       * This iterate the controls from the given node, and it receives a callback that returns a boolean value. If the boolean is
       * false it stops the iteration of the remaining controls.
       */
      private _iterateControls;
      /**
       * @internal
       * @param x
       * @param y
       * @param type
       */
      _processPicking(x: number, y: number, type: number): void;
      /**
       * @internal
       */
      _processPointerEvent(type: number): void;
      /**
       * @internal
       */
      private _onClipboardCopy;
      /**
       * @internal
       */
      private _onClipboardCut;
      /**
       * @internal
       */
      private _onClipboardPaste;
      /**
       * Register the clipboard Events onto the canvas
       */
      registerClipboardEvents(): void;
      /**
       * Unregister the clipboard Events from the canvas
       */
      unRegisterClipboardEvents(): void;
      /**
       * Serializes the entire GUI system
       * @returns an object with the JSON serialized data
       */
      serializeContent(): any;
      /**
       * Clones the ADT
       * @param newName defines the name of the new ADT
       * @returns the clone of the ADT
       */
      clone(newName?: string): InteractiveDynamicTexture;
      /**
       * Creates a new InteractiveDynamicTexture in projected mode (ie. attached to a mesh)
       * @param mesh defines the mesh which will receive the texture
       * @param width defines the texture width (1024 by default)
       * @param height defines the texture height (1024 by default)
       * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)
       * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)
       * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)
       * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh
       * @returns a new InteractiveDynamicTexture
       */
      static CreateForMesh(ownerNativeDocument: XSMLDocument, mesh: AbstractMesh, width?: number, height?: number, supportPointerMove?: boolean, onlyAlphaTesting?: boolean, invertY?: boolean, materialSetupCallback?: (mesh: AbstractMesh, uniqueId: string, texture: InteractiveDynamicTexture, onlyAlphaTesting: boolean) => void): InteractiveDynamicTexture;
      private static _CreateMaterial;
      /**
       * Scales the texture
       * @param ratio the scale factor to apply to both width and height
       */
      scale(ratio: number): void;
      /**
       * Resizes the texture
       * @param width the new width
       * @param height the new height
       */
      scaleTo(width: number, height: number): void;
      /**
       * Returns true if all the GUI components are ready to render
       */
      guiIsReady(): boolean;
  }

}
declare module '@transmutejs/runtime/gui/3d/container3d' {
  import { TransformNode, type Nullable, type Scene } from 'babylonjs';
  import { Control3D } from '@transmutejs/runtime/gui/3d/control3d';
  export class Container3D extends Control3D {
      private _blockLayout;
      /**
       * Gets the list of child controls
       */
      protected _children: Control3D[];
      /**
       * Gets the list of child controls
       */
      get children(): Array<Control3D>;
      /**
       * Gets or sets a boolean indicating if the layout must be blocked (default is false).
       * This is helpful to optimize layout operation when adding multiple children in a row
       */
      get blockLayout(): boolean;
      set blockLayout(value: boolean);
      /**
       * Creates a new container
       * @param name defines the container name
       */
      constructor(name?: string);
      /**
       * Force the container to update the layout. Please note that it will not take blockLayout property in account
       * @returns the current container
       */
      updateLayout(): Container3D;
      /**
       * Gets a boolean indicating if the given control is in the children of this control
       * @param control defines the control to check
       * @returns true if the control is in the child list
       */
      containsControl(control: Control3D): boolean;
      /**
       * Adds a control to the children of this control
       * @param control defines the control to add
       * @returns the current container
       */
      addControl(control: Control3D): Container3D;
      /**
       * This function will be called everytime a new control is added
       */
      protected _arrangeChildren(): void;
      protected _createNode(scene: Scene): Nullable<TransformNode>;
      /**
       * Removes a control from the children of this control
       * @param control defines the control to remove
       * @returns the current container
       */
      removeControl(control: Control3D): Container3D;
      protected _getTypeName(): string;
      /**
       * Releases all associated resources
       */
      dispose(): void;
      /** Control rotation will remain unchanged  */
      static readonly UNSET_ORIENTATION = 0;
      /** Control will rotate to make it look at sphere central axis */
      static readonly FACEORIGIN_ORIENTATION = 1;
      /** Control will rotate to make it look back at sphere central axis */
      static readonly FACEORIGINREVERSED_ORIENTATION = 2;
      /** Control will rotate to look at z axis (0, 0, 1) */
      static readonly FACEFORWARD_ORIENTATION = 3;
      /** Control will rotate to look at negative z axis (0, 0, -1) */
      static readonly FACEFORWARDREVERSED_ORIENTATION = 4;
  }

}
declare module '@transmutejs/runtime/gui/3d/control3d' {
  import { AbstractMesh, Vector3, Observable, type Nullable, type Scene, type TransformNode, type Behavior, type IBehaviorAware, type IDisposable } from 'babylonjs';
  import { Vector3WithInfo } from '@transmutejs/runtime/gui/math-utils';
  import { Container3D } from '@transmutejs/runtime/gui/3d/container3d';
  import { GUIManager } from '@transmutejs/runtime/gui/3d/gui-manager';
  /**
   * Class used as base class for controls
   */
  export class Control3D implements IDisposable, IBehaviorAware<Control3D> {
      /** Defines the control name */
      name?: string;
      private _node;
      private _downCount;
      private _enterCount;
      private _downPointerIds;
      protected _isVisible: boolean;
      /** @internal */
      _host: GUIManager;
      /** @internal */
      _isScaledByManager: boolean;
      /** Gets or sets the control position in world space */
      get position(): Vector3;
      set position(value: Vector3);
      /** Gets or sets the control scaling in world space */
      get scaling(): Vector3;
      set scaling(value: Vector3);
      /** Callback used to start pointer enter animation */
      pointerEnterAnimation: () => void;
      /** Callback used to start pointer out animation */
      pointerOutAnimation: () => void;
      /** Callback used to start pointer down animation */
      pointerDownAnimation: () => void;
      /** Callback used to start pointer up animation */
      pointerUpAnimation: () => void;
      /**
       * An event triggered when the pointer moves over the control
       */
      onPointerMoveObservable: Observable<Vector3>;
      /**
       * An event triggered when the pointer moves out of the control
       */
      onPointerOutObservable: Observable<Control3D>;
      /**
       * An event triggered when the pointer taps the control
       */
      onPointerDownObservable: Observable<Vector3WithInfo>;
      /**
       * An event triggered when pointer is up
       */
      onPointerUpObservable: Observable<Vector3WithInfo>;
      /**
       * An event triggered when a control is clicked on (with a mouse)
       */
      onPointerClickObservable: Observable<Vector3WithInfo>;
      /**
       * An event triggered when pointer enters the control
       */
      onPointerEnterObservable: Observable<Control3D>;
      /**
       * Gets or sets the parent container
       */
      parent: Nullable<Container3D>;
      private _behaviors;
      /**
       * Gets the list of attached behaviors
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
       */
      get behaviors(): Behavior<Control3D>[];
      /**
       * Attach a behavior to the control
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
       * @param behavior defines the behavior to attach
       * @returns the current control
       */
      addBehavior(behavior: Behavior<Control3D>): Control3D;
      /**
       * Remove an attached behavior
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
       * @param behavior defines the behavior to attach
       * @returns the current control
       */
      removeBehavior(behavior: Behavior<Control3D>): Control3D;
      /**
       * Gets an attached behavior by name
       * @param name defines the name of the behavior to look for
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
       * @returns null if behavior was not found else the requested behavior
       */
      getBehaviorByName(name: string): Nullable<Behavior<Control3D>>;
      /** Gets or sets a boolean indicating if the control is visible */
      get isVisible(): boolean;
      set isVisible(value: boolean);
      /**
       * Creates a new control
       * @param name defines the control name
       */
      constructor(
      /** Defines the control name */
      name?: string);
      /**
       * Gets a string representing the class name
       */
      get typeName(): string;
      /**
       * Get the current class name of the control.
       * @returns current class name
       */
      getClassName(): string;
      protected _getTypeName(): string;
      /**
       * Gets the transform node used by this control
       */
      get node(): Nullable<TransformNode>;
      /**
       * Gets the mesh used to render this control
       */
      get mesh(): Nullable<AbstractMesh>;
      /**
       * Link the control as child of the given node
       * @param node defines the node to link to. Use null to unlink the control
       * @returns the current control
       */
      linkToTransformNode(node: Nullable<TransformNode>): Control3D;
      /**
       * @internal*
       */
      _prepareNode(scene: Scene): void;
      protected _injectGUI3DReservedDataStore(node: TransformNode): any;
      /**
       * Node creation.
       * Can be overriden by children
       * @param scene defines the scene where the node must be attached
       * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object
       */
      protected _createNode(scene: Scene): Nullable<TransformNode>;
      /**
       * Affect a material to the given mesh
       * @param mesh defines the mesh which will represent the control
       */
      protected _affectMaterial(mesh: AbstractMesh): void;
      /**
       * @internal
       */
      _onPointerMove(target: Control3D, coordinates: Vector3): void;
      /**
       * @internal
       */
      _onPointerEnter(target: Control3D): boolean;
      /**
       * @internal
       */
      _onPointerOut(target: Control3D): void;
      /**
       * @internal
       */
      _onPointerDown(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number): boolean;
      /**
       * @internal
       */
      _onPointerUp(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number, notifyClick: boolean): void;
      /**
       * @internal
       */
      forcePointerUp(pointerId?: Nullable<number>): void;
      /**
       * @internal
       */
      _processObservables(type: number, pickedPoint: Vector3, originMeshPosition: Nullable<Vector3>, pointerId: number, buttonIndex: number): boolean;
      /** @internal */
      _disposeNode(): void;
      /**
       * Releases all associated resources
       */
      dispose(): void;
  }

}
declare module '@transmutejs/runtime/gui/3d/controls/button' {
  import { TransformNode, AbstractMesh, Material, Scene } from 'babylonjs';
  import { ContentDisplay3D } from '@transmutejs/runtime/gui/3d/controls/content-display';
  import { InteractiveDynamicTexture } from '@transmutejs/runtime/gui/2d/texture';
  export class AbstractButton3D extends ContentDisplay3D {
      /**
       * Creates a new button
       * @param name defines the control name
       */
      constructor(name?: string);
      protected _getTypeName(): string;
      protected _createNode(scene: Scene): TransformNode;
  }
  /**
   * Options used to create a button in 3D
   */
  export interface IButton3DCreationOptions {
      /**
       * Width of the button. Default: 1
       */
      width?: number;
      /**
       * Height of the button. Default: 1
       */
      height?: number;
      /**
       * Depth of the button. Default: 0.08
       */
      depth?: number;
  }
  /**
   * Class used to create a button in 3D
   */
  export class Button3D extends AbstractButton3D {
      /** @internal */
      protected _currentMaterial: Material;
      protected _options: IButton3DCreationOptions;
      protected _height: number;
      protected _depth: number;
      /**
       * Creates a new button
       * @param name defines the control name
       */
      constructor(name?: string, options?: IButton3DCreationOptions);
      /**
       * Apply the facade texture (created from the content property).
       * @param facadeTexture defines the AdvancedDynamicTexture to use
       */
      protected _applyFacade(facadeTexture: InteractiveDynamicTexture): void;
      protected _getTypeName(): string;
      protected _createNode(scene: Scene): TransformNode;
      protected _affectMaterial(mesh: AbstractMesh): void;
      /**
       * Releases all associated resources
       */
      dispose(): void;
  }

}
declare module '@transmutejs/runtime/gui/3d/controls/content-display' {
  import { Control3D } from '@transmutejs/runtime/gui/3d/control3d';
  import { Control2D } from '@transmutejs/runtime/gui/2d/control';
  /**
   * The base class for controls that display content
   */
  export class ContentDisplay3D extends Control3D {
      private _content;
      private _facadeTexture;
      protected _contentResolution: number;
      protected _contentScaleRatio: number;
      protected _contentScaleRatioY?: number;
      /**
       * Gets or sets the GUI 2D content used to display the button's facade
       */
      get content(): Control2D;
      set content(value: Control2D);
      protected _setFacadeTextureScaling(): void;
      /**
       * Gets or sets the texture resolution used to render content (512 by default)
       */
      get contentResolution(): number;
      set contentResolution(value: number);
      protected _disposeFacadeTexture(): void;
      protected _resetContent(): void;
      /**
       * Apply the facade texture (created from the content property).
       * This function can be overloaded by child classes
       * @param facadeTexture defines the AdvancedDynamicTexture to use
       */
      protected _applyFacade(facadeTexture: any): void;
  }

}
declare module '@transmutejs/runtime/gui/3d/controls/stack-panel' {
  import { Vector3 } from 'babylonjs';
  import { VolumeBasedPanel } from '@transmutejs/runtime/gui/3d/volume-based-panel';
  import { Control3D } from '@transmutejs/runtime/gui/3d/control3d';
  export class StackPanel3D extends VolumeBasedPanel {
      protected _mapGridNode(control: Control3D, nodePosition: Vector3): void;
      private _isVertical;
      get isVertical(): boolean;
      set isVertical(value: boolean);
      margin: number;
      constructor(isVertical?: boolean);
      protected _arrangeChildren(): void;
  }

}
declare module '@transmutejs/runtime/gui/3d/gui-manager' {
  import { Vector3, Observable, type Scene, type AbstractMesh, type Material, type IDisposable } from 'babylonjs';
  import { Container3D } from '@transmutejs/runtime/gui/3d/container3d';
  import { Control3D } from '@transmutejs/runtime/gui/3d/control3d';
  export class GUIManager implements IDisposable {
      private _scene;
      private _sceneDisposeObserver;
      private _rootContainer;
      private _customControlScaling;
      /** @internal */
      _lastPickedControl: Control3D;
      /** @internal */
      _lastControlOver: {
          [pointerId: number]: Control3D;
      };
      /** @internal */
      _lastControlDown: {
          [pointerId: number]: Control3D;
      };
      protected static MRTK_REALISTIC_SCALING: number;
      /**
       * Observable raised when the point picked by the pointer events changed
       */
      onPickedPointChangedObservable: Observable<Vector3>;
      /**
       * Observable raised when a picking happens
       */
      onPickingObservable: Observable<AbstractMesh>;
      /** @internal */
      _sharedMaterials: {
          [key: string]: Material;
      };
      /** @internal */
      _touchSharedMaterials: {
          [key: string]: Material;
      };
      /** Gets the hosting scene */
      get scene(): Scene;
      /** Gets the scaling for all UI elements owned by this manager */
      get controlScaling(): number;
      /** Sets the scaling adjustment for all UI elements owned by this manager */
      set controlScaling(newScale: number);
      /** Gets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
      get useRealisticScaling(): boolean;
      /** Sets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
      set useRealisticScaling(newValue: boolean);
      /**
       * Creates a new GUIManager
       * @param scene
       */
      constructor(scene?: Scene);
      /**
       * Gets the root container
       */
      get rootContainer(): Container3D;
      /**
       * Gets a boolean indicating if the given control is in the root child list
       * @param control defines the control to check
       * @returns true if the control is in the root child list
       */
      containsControl(control: Control3D): boolean;
      /**
       * Adds a control to the root child list
       * @param control defines the control to add
       * @returns the current manager
       */
      addControl(control: Control3D): GUIManager;
      /**
       * Removes a control from the root child list
       * @param control defines the control to remove
       * @returns the current container
       */
      removeControl(control: Control3D): GUIManager;
      /**
       * Releases all associated resources
       */
      dispose(): void;
  }

}
declare module '@transmutejs/runtime/gui/3d/volume-based-panel' {
  import { Vector3, type int } from 'babylonjs';
  import { Control3D } from '@transmutejs/runtime/gui/3d/control3d';
  import { Container3D } from '@transmutejs/runtime/gui/3d/container3d';
  /**
   * Abstract class used to create a container panel deployed on the surface of a volume
   */
  export abstract class VolumeBasedPanel extends Container3D {
      private _columns;
      private _rows;
      private _rowThenColum;
      private _orientation;
      protected _cellWidth: number;
      protected _cellHeight: number;
      /**
       * Gets or sets the distance between elements
       */
      margin: number;
      /**
       * Gets or sets the orientation to apply to all controls (BABYLON.Container3D.FaceOriginReversedOrientation by default)
       * | Value | Type                                | Description |
       * | ----- | ----------------------------------- | ----------- |
       * | 0     | UNSET_ORIENTATION                   |  Control rotation will remain unchanged |
       * | 1     | FACEORIGIN_ORIENTATION              |  Control will rotate to make it look at sphere central axis |
       * | 2     | FACEORIGINREVERSED_ORIENTATION      |  Control will rotate to make it look back at sphere central axis |
       * | 3     | FACEFORWARD_ORIENTATION             |  Control will rotate to look at z axis (0, 0, 1) |
       * | 4     | FACEFORWARDREVERSED_ORIENTATION     |  Control will rotate to look at negative z axis (0, 0, -1) |
       */
      get orientation(): number;
      set orientation(value: number);
      /**
       * Gets or sets the number of columns requested (10 by default).
       * The panel will automatically compute the number of rows based on number of child controls.
       */
      get columns(): int;
      set columns(value: int);
      /**
       * Gets or sets a the number of rows requested.
       * The panel will automatically compute the number of columns based on number of child controls.
       */
      get rows(): int;
      set rows(value: int);
      /**
       * Creates new VolumeBasedPanel
       * @param name
       */
      constructor(name?: string);
      protected _arrangeChildren(): void;
      /** Child classes must implement this function to provide correct control positioning */
      protected abstract _mapGridNode(control: Control3D, nodePosition: Vector3): void;
      /** Child classes can implement this function to provide additional processing */
      protected _finalProcessing(): void;
  }

}
declare module '@transmutejs/runtime/gui/math-utils' {
  import { Vector3 } from 'babylonjs';
  export class Vector3WithInfo extends Vector3 {
      /** defines the current mouse button index */
      buttonIndex: number;
      /**
       * Creates a new Vector3WithInfo
       * @param source defines the vector3 data to transport
       * @param buttonIndex defines the current mouse button index
       */
      constructor(source: Vector3, 
      /** defines the current mouse button index */
      buttonIndex?: number);
  }

}
declare module '@transmutejs/runtime/index' {
  /// <reference types="node" />
  /**
   * Apply the patches for babylonjs.
   *
   * This requires @babylonjs/loaders to be 6.10.0.
   */
  import '@transmutejs/runtime/babylon-patches/rewrite-draco-compression';
  import '@transmutejs/runtime/babylon-patches/rewrite-meshopt-compression';
  import { TransmuteEngine } from '@transmutejs/babylonjs-adapter/engine';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { Pose } from '@transmutejs/runtime/xsml/common';
  class ReadyContext {
      screenHeight: number;
      screenWidth: number;
      applicationCacheDirectory: string;
      static FromString(s: string): ReadyContext;
  }
  type RuntimeInitOptions = {
      onReadTextFile: (pathname: string) => Promise<string>;
      onReadBinaryFile: (pathname: string) => Promise<ArrayBuffer>;
      onWriteConsoleLine?: (line: string) => void;
      isResourceCached?: (runtime: TransmuteRuntime, uri: string) => Promise<[boolean, string?]>;
      cacheResource?: (runtime: TransmuteRuntime, uri: string, content: string | NodeJS.ArrayBufferView) => Promise<void>;
  };
  type ScriptRunOptions = {
      cwd: string;
      channelId?: string;
      filename?: string;
      containerPose?: Pose;
      onError?: (err: Error) => void;
  };
  export class DocumentContentLoadedEvent extends CustomEvent<XSMLDocument> {
      constructor(document: XSMLDocument);
  }
  /**
   * The JSAR(Transmute) runtime.
   */
  export class TransmuteRuntime extends EventTarget {
      #private;
      constructor(runtimeInitOptions: RuntimeInitOptions, engineInitOptions?: ConstructorParameters<typeof TransmuteEngine>[1]);
      get documents(): XSMLDocument[];
      get readyContext(): ReadyContext;
      start(): void;
      load(url: string, channelId: string, containerPose: Pose): Promise<XSMLDocument>;
      /**
       * Read the text file.
       * @param pathname the file path.
       * @returns the file content.
       */
      readTextFile(pathname: string): Promise<string>;
      /**
       * Read the binary file.
       * @param pathname the file path.
       * @returns the file content.
       */
      readBinaryFile(pathname: string): Promise<ArrayBuffer>;
      isResourceCached(uri: string): Promise<[boolean, string?]>;
      cacheResource(uri: string, content: string | NodeJS.ArrayBufferView): Promise<void>;
      /**
       * Should use the cached resource or not.
       * @param resourceUri the origin resource uri.
       * @param cachePath the cached resource path.
       * @returns check their md5 values and return true if they are the same or something went wrong.
       */
      shouldUseResourceCache(resourceUri: string, cachePath: string): Promise<boolean>;
      writeConsoleLine(line: string): void;
      /**
       * Run the XSML document, it returns a promise which will be resolved when the xsml document is loaded and serialized for
       * the first frame.
       *
       * @param source the XSML document source.
       * @param options the options for running the XSML document.
       */
      runXsml(source: string, options: ScriptRunOptions): Promise<XSMLDocument>;
      /**
       * Stop the runtime.
       */
      stop(): void;
  }
  export {};

}
declare module '@transmutejs/runtime/main' {
  /**
   * Browser Pollyfills for Node.js
   */
  /**
   * A patch to the Node.js TextDecoder.
   *
   * Node.js TextDecoder with samll ICU doesn't support ascii encoding, however the fontkit library depends on
   * the ASCII decoder to parse the font file headers.
   */
  import './polyfills/textdecoder';
  import './polyfills/webaudio';

}
declare module '@transmutejs/runtime/polyfills/canvaskit-wasm' {
  const _default: string;
  export default _default;

}
declare module '@transmutejs/runtime/polyfills/events/error-event' {
  export class ErrorEventImpl extends Event implements ErrorEvent {
      colno: number;
      error: any;
      filename: string;
      lineno: number;
      message: string;
      constructor(type: string, eventInitDict: ErrorEventInit);
  }

}
declare module '@transmutejs/runtime/polyfills/get-system-fonts/index' {
  export interface Options {
      /**
       * Additional folders to search for fonts. Default: []
       */
      additionalFolders?: string[];
      /**
       * File extensions to search for. Default: ['ttf', 'otf', 'ttc', 'woff', 'woff2']
       */
      extensions?: string[];
  }
  /**
   * List absolute paths to all installed system fonts present.
   *
   * @param options Configuration options
   */
  function getSystemFonts(options?: Options): Promise<string[]>;
  export default getSystemFonts;

}
declare module '@transmutejs/runtime/polyfills/get-system-fonts/recursiveWalk' {
  /**
   * Recursively scans the list of directories for files with one of the provided
   * extensions.
   *
   * @param baseDirs Directories to search for files
   * @param extensions List of valid extensions that files may have
   */
  export default function recursiveWalk(baseDirs: string[], extensions: string[]): Promise<string[]>;

}
declare module '@transmutejs/runtime/polyfills/offscreencanvas' {
  import { EmulatedCanvas2D, CanvasKit, Image as CanvasKitImage } from 'canvaskit-wasm';
  export class OffscreenCanvasRenderingContext2DImpl implements OffscreenCanvasRenderingContext2D {
      #private;
      constructor(canvas?: OffscreenCanvasImpl);
      commit(): void;
      reset(): void;
      transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
      clearRect(x: number, y: number, w: number, h: number): void;
      fillRect(x: number, y: number, w: number, h: number): void;
      strokeRect(x: number, y: number, w: number, h: number): void;
      fillText(text: string, x: number, y: number, maxWidth?: number): void;
      drawText(text: string, x: number, y: number, maxWidth?: number): void;
      strokeText(text: string, x: number, y: number, maxWidth?: number): void;
      measureText(text: string): TextMetrics;
      get lineWidth(): number;
      set lineWidth(value: number);
      get lineCap(): CanvasLineCap;
      set lineCap(value: CanvasLineCap);
      get lineJoin(): CanvasLineJoin;
      set lineJoin(value: CanvasLineJoin);
      get miterLimit(): number;
      set miterLimit(value: number);
      get lineDashOffset(): number;
      set lineDashOffset(value: number);
      getLineDash(): number[];
      setLineDash(segments: number[]): void;
      get font(): string;
      set font(value: string);
      get textAlign(): CanvasTextAlign;
      set textAlign(value: CanvasTextAlign);
      get textBaseline(): CanvasTextBaseline;
      set textBaseline(value: CanvasTextBaseline);
      get direction(): CanvasDirection;
      set direction(value: CanvasDirection);
      get fontKerning(): CanvasFontKerning;
      set fontKerning(value: CanvasFontKerning);
      get fillStyle(): string | CanvasGradient | CanvasPattern;
      set fillStyle(value: string | CanvasGradient | CanvasPattern);
      get strokeStyle(): string | CanvasGradient | CanvasPattern;
      set strokeStyle(value: string | CanvasGradient | CanvasPattern);
      createConicGradient(startAngle: number, x: number, y: number): CanvasGradient;
      createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
      createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
      createPattern(image: CanvasImageSource, repetition: string): CanvasPattern;
      get shadowBlur(): number;
      set shadowBlur(value: number);
      get shadowColor(): string;
      set shadowColor(value: string);
      get shadowOffsetX(): number;
      set shadowOffsetX(value: number);
      get shadowOffsetY(): number;
      set shadowOffsetY(value: number);
      beginPath(): void;
      closePath(): void;
      moveTo(x: number, y: number): void;
      lineTo(x: number, y: number): void;
      bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
      quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
      arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
      arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
      ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
      rect(x: number, y: number, w: number, h: number): void;
      roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | (number | DOMPointInit)[]): void;
      roundRect(x: number, y: number, w: number, h: number, radii?: number | DOMPointInit | Iterable<number | DOMPointInit>): void;
      fill(fillRule?: CanvasFillRule): void;
      fill(path: Path2D, fillRule?: CanvasFillRule): void;
      stroke(path?: Path2D): void;
      drawFocusIfNeeded(element: Element): void;
      drawFocusIfNeeded(path: Path2D, element: Element): void;
      scrollPathIntoView(): void;
      scrollPathIntoView(path: Path2D): void;
      clip(fillRule?: CanvasFillRule): void;
      clip(path: Path2D, fillRule?: CanvasFillRule): void;
      isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean;
      isPointInPath(path: Path2D, x: number, y: number, fillRule?: CanvasFillRule): boolean;
      isPointInStroke(x: number, y: number): boolean;
      isPointInStroke(path: Path2D, x: number, y: number): boolean;
      getTransform(): DOMMatrix;
      rotate(angle: number): void;
      scale(x: number, y: number): void;
      translate(x: number, y: number): void;
      setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
      setTransform(transform?: DOMMatrix2DInit): void;
      resetTransform(): void;
      get globalAlpha(): number;
      set globalAlpha(value: number);
      get globalCompositeOperation(): GlobalCompositeOperation;
      set globalCompositeOperation(value: GlobalCompositeOperation);
      drawImage(image: CanvasImageSource, dx: number, dy: number): void;
      drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;
      drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
      createImageData(sw: number, sh: number, settings?: ImageDataSettings): ImageData;
      createImageData(imagedata: ImageData): ImageData;
      getImageData(sx: number, sy: number, sw: number, sh: number, settings?: ImageDataSettings): ImageData;
      putImageData(imagedata: ImageData, dx: number, dy: number): void;
      putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
      get imageSmoothingEnabled(): boolean;
      set imageSmoothingEnabled(value: boolean);
      get imageSmoothingQuality(): ImageSmoothingQuality;
      set imageSmoothingQuality(value: ImageSmoothingQuality);
      save(): void;
      restore(): void;
      canvas: OffscreenCanvas;
      getContextAttributes(): CanvasRenderingContext2DSettings;
      get filter(): string;
      set filter(value: string);
      markAsNotDirty(): void;
      isDirty(): boolean;
  }
  /**
   * OffscreenCanvas
   */
  export class OffscreenCanvasImpl extends EventTarget implements OffscreenCanvas {
      #private;
      width: number;
      height: number;
      oncontextlost: (event: Event) => any;
      oncontextrestored: (event: Event) => any;
      constructor(width: number, height: number);
      get nativeCanvas(): EmulatedCanvas2D;
      getContext(contextId: string, _contextAttributes?: any): any;
      transferToImageBitmap(): ImageBitmap;
      convertToBlob(_options?: any): Promise<Blob>;
      toDataURL(mime: string): string;
  }
  export class ImageBitmapImpl implements ImageBitmap {
      height: number;
      width: number;
      private skImage;
      constructor(buffer: ArrayBuffer);
      close(): void;
      _getSkImage(): CanvasKitImage;
  }
  export class ImageDataImpl implements ImageData {
      constructor(data: unknown, sw: unknown, sh?: unknown, settings?: unknown);
      data: Uint8ClampedArray;
      height: number;
      width: number;
      colorSpace: PredefinedColorSpace;
  }
  export function createImageBitmapImpl(source: ImageBitmapSource, _sx?: unknown, _sy?: unknown, _sw?: unknown, _sh?: unknown, _options?: unknown): Promise<ImageBitmap>;
  export const InitializeOffscreenCanvas: (options?: Partial<{
      loadSystemFonts: boolean;
  }>) => Promise<CanvasKit>;

}
declare module '@transmutejs/runtime/polyfills/textdecoder' {
  export {};

}
declare module '@transmutejs/runtime/polyfills/webaudio' {
  import { CreateXSMLType } from '@transmutejs/runtime/dom/xsml-interfaces';
  import { HTMLElementImpl } from '@transmutejs/runtime/dom/living/nodes/html-element';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { XSMLScript } from '@transmutejs/runtime/xsml/script';
  enum MediaReadyState {
      HAVE_NOTHING = 0,
      HAVE_METADATA = 1,
      HAVE_CURRENT_DATA = 2,
      HAVE_FUTURE_DATA = 3,
      HAVE_ENOUGH_DATA = 4
  }
  enum MediaNetworkState {
      NETWORK_EMPTY = 0,
      NETWORK_IDLE = 1,
      NETWORK_LOADING = 2,
      NETWORK_NO_SOURCE = 3
  }
  class HTMLAudioElementImpl extends HTMLElementImpl implements CreateXSMLType<HTMLAudioElement> {
      #private;
      autoplay: boolean;
      buffered: TimeRanges;
      controls: boolean;
      crossOrigin: string;
      currentSrc: string;
      defaultMuted: boolean;
      defaultPlaybackRate: number;
      disableRemotePlayback: boolean;
      duration: number;
      ended: boolean;
      error: MediaError;
      mediaKeys: MediaKeys;
      muted: boolean;
      networkState: MediaNetworkState;
      onencrypted: (this: HTMLMediaElement, ev: MediaEncryptedEvent) => any;
      onwaitingforkey: (this: HTMLMediaElement, ev: Event) => any;
      playbackRate: number;
      played: TimeRanges;
      preload: '' | 'metadata' | 'none' | 'auto';
      preservesPitch: boolean;
      readyState: MediaReadyState;
      remote: RemotePlayback;
      seekable: TimeRanges;
      seeking: boolean;
      src: string;
      srcObject: MediaProvider;
      textTracks: TextTrackList;
      constructor(src: string, hostObject: XSMLDocument, script: XSMLScript);
      get paused(): boolean;
      get currentTime(): number;
      set currentTime(value: number);
      get volume(): number;
      set volume(value: number);
      get loop(): boolean;
      set loop(value: boolean);
      addTextTrack(_kind: TextTrackKind, _label?: string, _language?: string): TextTrack;
      canPlayType(type: string): CanPlayTypeResult;
      fastSeek(time: number): void;
      load(): void;
      pause(): void;
      play(): Promise<void>;
      setMediaKeys(mediaKeys: MediaKeys): Promise<void>;
      NETWORK_EMPTY: 0;
      NETWORK_IDLE: 1;
      NETWORK_LOADING: 2;
      NETWORK_NO_SOURCE: 3;
      HAVE_NOTHING: 0;
      HAVE_METADATA: 1;
      HAVE_CURRENT_DATA: 2;
      HAVE_FUTURE_DATA: 3;
      HAVE_ENOUGH_DATA: 4;
  }
  export { HTMLAudioElementImpl, };

}
declare module '@transmutejs/runtime/xsml/audio' {
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  export class HTMLAudioElement extends EventTarget {
      #private;
      autoplay: boolean;
      controls: boolean;
      crossOrigin: string | null;
      defaultMuted: boolean;
      defaultPlaybackRate: number;
      disableRemotePlayback: boolean;
      loop: boolean;
      muted: boolean;
      playbackRate: number;
      preload: 'none' | 'metadata' | 'auto' | '';
      preservesPitch: boolean;
      src: string;
      srcObject: MediaProvider | null;
      volume: number;
      /** READONLY */
      buffered: TimeRanges;
      currentSrc: string;
      duration: number;
      ended: boolean;
      error: MediaError | null;
      mediaKeys: MediaKeys | null;
      networkState: number;
      paused: boolean;
      played: TimeRanges;
      readyState: number;
      remote: RemotePlayback;
      seekable: TimeRanges;
      seeking: boolean;
      textTracks: TextTrackList;
      readonly NETWORK_EMPTY: 0;
      readonly NETWORK_IDLE: 1;
      readonly NETWORK_LOADING: 2;
      readonly NETWORK_NO_SOURCE: 3;
      readonly HAVE_NOTHING: 0;
      readonly HAVE_METADATA: 1;
      readonly HAVE_CURRENT_DATA: 2;
      readonly HAVE_FUTURE_DATA: 3;
      readonly HAVE_ENOUGH_DATA: 4;
      constructor(document: XSMLDocument, src?: string);
      onencrypted: ((this: HTMLMediaElement, ev: MediaEncryptedEvent) => any) | null;
      onwaitingforkey: ((this: HTMLMediaElement, ev: Event) => any) | null;
      addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack;
      canPlayType(type: string): CanPlayTypeResult;
      fastSeek(time: number): void;
      load(): void;
      pause(): void;
      play(): Promise<void>;
      setMediaKeys(_mediaKeys: MediaKeys | null): Promise<void>;
      get currentTime(): number;
  }
  export const createHTMLAudioElement: (document: XSMLDocument, src?: string) => HTMLAudioElement;

}
declare module '@transmutejs/runtime/xsml/common' {
  /// <reference types="babylonjs" />
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  export type Pose = {
      position: {
          x: number;
          y: number;
          z: number;
      };
      rotation: {
          x: number;
          y: number;
          z: number;
          w: number;
      };
  };
  export class XSMLNode extends EventTarget {
      runner: XSMLRunner;
      constructor(runner: XSMLRunner);
      get scene(): import("babylonjs/scene").Scene;
  }
  export function toXmlNode(xmlObject: any): Partial<{
      name: string;
      text: string;
      attrs: {
          [key: string]: any;
      };
      children: any[];
  }>;
  export function getDisplayNodeName(node: ReturnType<typeof toXmlNode>, defaultName?: string): any;
  export function toPropertyNumber(value: string): number;
  export function parseColorChanel(value: string): number;
  export function toPropertyColor(value: string): BABYLON.Color3;
  export function parseStringToUrlOrPath(s: string, cwd: string): string;

}
declare module '@transmutejs/runtime/xsml/css/animation/Error' {
  export class $Error extends Error {
      readonly code: string;
      constructor(code: string, message?: string);
  }

}
declare module '@transmutejs/runtime/xsml/css/animation/character' {
  import { CodePointTest } from '@transmutejs/runtime/xsml/css/animation/type';
  export const Zero = 48;
  export const Nine = 57;
  export const Dot = 46;
  export const Space = 32;
  export const HTab = 9;
  export const LF = 10;
  export const CR = 13;
  export const UpperA = 65;
  export const LowerA = 97;
  export const UpperF = 70;
  export const LowerF = 102;
  export const UpperM = 77;
  export const LowerM = 109;
  export const UpperS = 83;
  export const LowerS = 115;
  export const UpperZ = 90;
  export const LowerZ = 122;
  export const DoubleQuote = 34;
  export const SingleQuote = 39;
  export const OpenParenthesis = 40;
  export const CloseParenthesis = 41;
  export const Comma = 44;
  export const Backslash = 92;
  export const Hyphen = 45;
  export const Underscore = 95;
  export const isInRange: (cp: number | undefined, min: number, max: number) => cp is number;
  export const isOneOf: (...cps: Array<number>) => CodePointTest;
  export const isNot: (...cps: Array<number>) => CodePointTest;
  export const isWhiteSpace: CodePointTest;
  export const isDigit: CodePointTest;
  export const isUpperAlpha: CodePointTest;
  export const isLowerAlpha: CodePointTest;
  export const isAlpha: CodePointTest;
  export const isNumberStart: CodePointTest;
  export const isHexCharacter: CodePointTest;
  export const isIdentCharacter: CodePointTest;

}
declare module '@transmutejs/runtime/xsml/css/animation/fillAnimation' {
  import { CSSAnimation } from '@transmutejs/runtime/xsml/css/animation/type';
  export const fillAnimation: (patch: Partial<CSSAnimation> & {
      name: string;
  }) => CSSAnimation;

}
declare module '@transmutejs/runtime/xsml/css/animation/getCubicBezier' {
  import { CSSCubicBezier } from '@transmutejs/runtime/xsml/css/animation/type';
  export const getCubicBezier: (input: string, start: number) => {
      start: number;
      end: number;
      value: CSSCubicBezier;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/getCubicBezier.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/getCustomIdent' {
  export const getCustomIdent: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };
  export const getCustomIdentOrNull: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/getCustomIdent.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/getNumber' {
  export const getNumber: (input: string, start: number) => {
      start: number;
      end: number;
      value: number;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/getNumber.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/getSteps' {
  import { CSSSteps } from '@transmutejs/runtime/xsml/css/animation/type';
  export const getSteps: (input: string, start: number) => {
      start: number;
      end: number;
      value: CSSSteps;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/getSteps.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/getString' {
  export const getString: (input: string, start: number) => {
      start: number;
      end: number;
      value: string;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/getString.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/index' {
  export * from '@transmutejs/runtime/xsml/css/animation/type';
  export const parseSingle: (input: string, startFrom?: number) => {
      start: number;
      end: number;
      value: import("@transmutejs/runtime/xsml/css/animation/type").CSSAnimation;
  };
  export const parse: (input: string) => import("@transmutejs/runtime/xsml/css/animation/type").CSSAnimation[];
  export const serialize: (animation: Partial<import("@transmutejs/runtime/xsml/css/animation/type").CSSAnimation> & {
      name: string;
  }) => string;

}
declare module '@transmutejs/runtime/xsml/css/animation/index.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/keyword' {
  export const StepDirection: Set<string>;
  export const TimingFunctionKeyword: Set<string>;
  export const AnimationDirection: Set<string>;
  export const AnimationFillMode: Set<string>;
  export const AnimationPlayState: Set<string>;

}
declare module '@transmutejs/runtime/xsml/css/animation/parseAnimationShorthand' {
  import { CSSAnimation } from '@transmutejs/runtime/xsml/css/animation/type';
  export const parseAnimationShorthand: (input: string) => Generator<CSSAnimation>;

}
declare module '@transmutejs/runtime/xsml/css/animation/parseAnimationShorthand.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/parseSingleAnimationShorthand' {
  import { CSSAnimation } from '@transmutejs/runtime/xsml/css/animation/type';
  export const parseSingleAnimationShorthand: (input: string, startFrom?: number) => {
      start: number;
      end: number;
      value: CSSAnimation;
  };

}
declare module '@transmutejs/runtime/xsml/css/animation/parseSingleAnimationShorthand.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeAnimation' {
  import { CSSAnimation } from '@transmutejs/runtime/xsml/css/animation/type';
  export const serializeAnimation: (animation: Partial<CSSAnimation> & {
      name: string;
  }) => string;

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeAnimation.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeAnimationValue' {
  import { CSSAnimation } from '@transmutejs/runtime/xsml/css/animation/type';
  export const serializeAnimationValue: <Key extends keyof CSSAnimation>(key: Key, value: CSSAnimation[Key]) => string;

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeAnimationValue.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeNumber' {
  export const serializeNumber: (value: number) => string;

}
declare module '@transmutejs/runtime/xsml/css/animation/serializeNumber.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/shortest' {
  export const shortest: (...list: Array<string>) => string;

}
declare module '@transmutejs/runtime/xsml/css/animation/shortest.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/skip' {
  import { CodePointTest } from '@transmutejs/runtime/xsml/css/animation/type';
  export const skip: (input: string, start: number, test: CodePointTest) => number;

}
declare module '@transmutejs/runtime/xsml/css/animation/skip.test' {
  export {};

}
declare module '@transmutejs/runtime/xsml/css/animation/type' {
  export interface CodePointTest {
      (cp?: number): cp is number;
  }
  export interface CSSCubicBezier {
      type: 'cubic-bezier';
      value: [number, number, number, number];
  }
  export type CSSStepDirection = 'jump-start' | 'jump-end' | 'jump-none' | 'jump-both' | 'start' | 'end';
  export interface CSSSteps {
      type: 'steps';
      stepCount: number;
      direction: CSSStepDirection;
  }
  export type CSSTimingFunctionKeyword = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' | 'step-start' | 'step-end';
  export type CSSTimingFunction = CSSCubicBezier | CSSSteps | CSSTimingFunctionKeyword;
  export type CSSAnimationDirection = 'normal' | 'reverse' | 'alternate' | 'alternate-reverse';
  export type CSSAnimationFillMode = 'none' | 'forwards' | 'backwards' | 'both';
  export type CSSAnimationPlayState = 'paused' | 'running';
  export interface CSSAnimation {
      name: string;
      duration: number | 'unset';
      timingFunction: CSSTimingFunction | 'unset';
      delay: number | 'unset';
      iterationCount: number | 'infinite' | 'unset';
      direction: CSSAnimationDirection | 'unset';
      fillMode: CSSAnimationFillMode | 'unset';
      playState: CSSAnimationPlayState | 'unset';
  }

}
declare module '@transmutejs/runtime/xsml/custom/bound' {
  import * as BABYLON from 'babylonjs';
  export class XSMLBound extends BABYLON.TransformNode {
      isBound: boolean;
      constructor(name: string, scene: BABYLON.Scene);
  }

}
declare module '@transmutejs/runtime/xsml/document' {
  import * as BABYLON from 'babylonjs';
  import { Logger } from '@transmutejs/binding/logger';
  import { Pose, XSMLNode } from '@transmutejs/runtime/xsml/common';
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  import { XSMLDocumentHead } from '@transmutejs/runtime/xsml/head';
  import { XSMLDocumentSpace } from '@transmutejs/runtime/xsml/space';
  import { SpatialDocument } from '@transmutejs/runtime/xsml/webapis';
  import { XRSystemImpl } from '@transmutejs/runtime/xsml/webxr/system';
  import { GUIManager } from '@transmutejs/runtime/gui/3d/gui-manager';
  import { InteractiveDynamicTexture } from '@transmutejs/runtime/gui/2d/texture';
  import { Allocator as TaffyAllocator } from '@transmutejs/runtime/gui/2d/taffy-layout-wasm';
  export type XSMLLoadOptions = Partial<{
      cwd: string;
      channelId: string;
      filename: string;
      containerPose?: Pose;
  }>;
  export class XSMLDocument extends XSMLNode {
      #private;
      specVersion: string;
      head: XSMLDocumentHead;
      space: XSMLDocumentSpace;
      cwd: string;
      channelId: string;
      filename: string;
      containerPose: Pose;
      spaceDocument: SpatialDocument;
      webxr: XRSystemImpl;
      guiManager: GUIManager;
      guiLayoutAllocator: TaffyAllocator;
      constructor(source: string, runner: XSMLRunner, options?: XSMLLoadOptions);
      get logger(): Logger;
      get scene(): BABYLON.Scene;
      get title(): string;
      get metadata(): Partial<{
          description: string;
          author: string;
          keywords: string;
          license: string;
          licenseUrl: string;
          viewportInitialScale: number;
      }>;
      get audioContext(): AudioContext;
      load(): Promise<void>;
      run(): Promise<void>;
      dispose(): void;
      querySelector(selector: string): BABYLON.Node;
      querySelectors(selector: string): BABYLON.Node[];
      getResourceUri(s: string): string;
      attachShadow(node: BABYLON.AbstractMesh, _options?: ShadowRootInit): InteractiveDynamicTexture;
      dispatchAnimationEvent(eventDetail: any): void;
      dispatchInputEvent(eventDetail: any): boolean;
      watchInputEvent(): void;
  }

}
declare module '@transmutejs/runtime/xsml/head' {
  import * as BABYLON from 'babylonjs';
  import { XSMLNode, toXmlNode } from '@transmutejs/runtime/xsml/common';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  import { XSMLDocumentStyle } from '@transmutejs/runtime/xsml/style';
  type DocumentMetadata = Partial<{
      description: string;
      author: string;
      keywords: string;
      license: string;
      licenseUrl: string;
      viewportInitialScale: number;
  }>;
  export class XSMLDocumentHead extends XSMLNode {
      #private;
      title: string;
      metadata: DocumentMetadata;
      style: XSMLDocumentStyle;
      pendingScriptLoaders: Array<Promise<void>>;
      pendingMeshLoaders: Array<Promise<void>>;
      preloadedMeshes: Map<string, BABYLON.TransformNode[]>;
      preloadedAnimationGroups: Map<string, BABYLON.AnimationGroup[]>;
      constructor(xmlNode: ReturnType<typeof toXmlNode>, runner: XSMLRunner, document: XSMLDocument);
      waitForScriptsLoaded(): Promise<void>;
      waitForPreloadingFinished(): Promise<void>;
      runScripts(): Promise<void>;
      stopScripts(): void;
  }
  export {};

}
declare module '@transmutejs/runtime/xsml/runner' {
  import * as BABYLON from 'babylonjs';
  import type { TransmuteEngine } from '@transmutejs/babylonjs-adapter/engine';
  import { XSMLDocument, XSMLLoadOptions } from '@transmutejs/runtime/xsml/document';
  import { TransmuteRuntime } from '@transmutejs/runtime/index';
  /**
   * A XSML runner is a runner class to run a XSML document.
   */
  export class XSMLRunner {
      #private;
      constructor(scene: BABYLON.Scene, runtime: TransmuteRuntime);
      get engine(): TransmuteEngine;
      get runtime(): TransmuteRuntime;
      get scene(): BABYLON.Scene;
      get document(): XSMLDocument;
      get readyContext(): {
          screenHeight: number;
          screenWidth: number;
          applicationCacheDirectory: string;
      };
      load(source: string, options: XSMLLoadOptions): Promise<XSMLDocument>;
      run(): Promise<void>;
  }

}
declare module '@transmutejs/runtime/xsml/script' {
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  import { XSMLNode, toXmlNode } from '@transmutejs/runtime/xsml/common';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  export class XSMLScript extends XSMLNode {
      #private;
      constructor(xmlNode: ReturnType<typeof toXmlNode>, runner: XSMLRunner, document: XSMLDocument);
      get runtime(): import("@transmutejs/runtime/index").TransmuteRuntime;
      /**
       * Load the script source and compile it.
       */
      load(): Promise<void>;
      run(): Promise<void>;
      stop(): void;
  }

}
declare module '@transmutejs/runtime/xsml/space' {
  import * as BABYLON from 'babylonjs';
  import { XSMLNode, toXmlNode } from '@transmutejs/runtime/xsml/common';
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  export class XSMLDocumentSpace extends XSMLNode {
      #private;
      constructor(xmlNode: ReturnType<typeof toXmlNode>, runner: XSMLRunner, document: XSMLDocument);
      protected get documentLogger(): import("@transmutejs/binding/logger").Logger;
      /**
       * Start to load the space from the root <space> node.
       */
      load(): void;
      /**
       * Query the first element by the selector.
       */
      querySelector(selector: string): BABYLON.Node;
      /**
       * Query the elements by the selector.
       */
      querySelectors(selector: string): BABYLON.Node[];
  }

}
declare module '@transmutejs/runtime/xsml/style' {
  import * as BABYLON from 'babylonjs';
  import { XSMLNode, toXmlNode } from '@transmutejs/runtime/xsml/common';
  import { XSMLRunner } from '@transmutejs/runtime/xsml/runner';
  type CssRule = {
      type: 'rule' | 'keyframes';
      name?: string;
      selectors?: string[];
      declarations?: Array<{
          type: 'declaration' | 'comment';
          property: string;
          value: string;
      }>;
      keyframes?: Array<{
          type: 'keyframe';
          values: string[];
          declarations: Array<{
              type: 'declaration';
              property: string;
              value: string;
          }>;
      }>;
  };
  export class XSMLDocumentStyle extends XSMLNode {
      #private;
      constructor(xmlNode: ReturnType<typeof toXmlNode>, runner: XSMLRunner);
      /**
       * Parse the css rules into this object.
       */
      parse(): void;
      addTextureByRule(rule: CssRule): void;
      addMaterialByRule(rule: CssRule): void;
      /**
       * Add keyframes from the rule data structure.
       */
      addKeyframesByRule(rule: CssRule): void;
      /**
       * The method should be called when an object is created when it updates space styles
       * by the above declared css rules.
       */
      updateStylesOnCreated(object: BABYLON.Node, sourceXmlNode: ReturnType<typeof toXmlNode>): void;
  }
  export {};

}
declare module '@transmutejs/runtime/xsml/webapis' {
  export * from '@transmutejs/runtime/dom/living/nodes/spatial-document';

}
declare module '@transmutejs/runtime/xsml/webxr/frame' {
  /// <reference types="babylonjs" />
  export class XRFrameImpl implements XRFrame {
      session: XRSession;
      constructor(session: XRSession);
      createAnchor?: (pose: XRRigidTransform, space: XRSpace) => Promise<XRAnchor>;
      fillJointRadii(_jointSpaces: XRJointSpace[], _radii: Float32Array): boolean;
      fillPoses(_spaces: XRSpace[], _baseSpace: XRSpace, _transforms: Float32Array): boolean;
      getDepthInformation(_view: XRView): XRCPUDepthInformation;
      getHitTestResults(_hitTestSource: XRHitTestSource): XRHitTestResult[];
      getHitTestResultsForTransientInput(_hitTestSource: XRTransientInputHitTestSource): XRTransientInputHitTestResult[];
      getLightEstimate(_xrLightProbe: XRLightProbe): XRLightEstimate;
      getImageTrackingResults(): XRImageTrackingResult[];
      getPose(_space: XRSpace, _baseSpace: XRSpace): XRPose;
      getViewerPose(_referenceSpace: XRReferenceSpace): XRViewerPose;
      getJointPose(_joint: XRJointSpace, _baseSpace: XRSpace): XRJointPose;
  }

}
declare module '@transmutejs/runtime/xsml/webxr/hand' {
  /// <reference types="babylonjs" />
  export class XRJointSpaceImpl extends EventTarget implements XRJointSpace {
      readonly session: XRSession;
      readonly jointName: XRHandJoint;
      constructor(session: XRSession, jointName: XRHandJoint);
  }

}
declare module '@transmutejs/runtime/xsml/webxr/input-source' {
  /// <reference types="babylonjs" />
  export class XRInputSourceImpl implements XRInputSource {
      handedness: XRHandedness;
      targetRayMode: XRTargetRayMode;
      targetRaySpace: XRSpace;
      gripSpace: XRSpace;
      profiles: string[];
      gamepad?: Gamepad;
      hand?: XRHand;
  }
  export class XRInputSourceArrayImpl implements XRInputSourceArray {
      [index: number]: XRInputSource;
      length: number;
      forEach(callbackfn: (value: XRInputSource, index: number, array: XRInputSource[]) => void, thisArg?: any): void;
      entries(): IterableIterator<[number, XRInputSource]>;
      keys(): IterableIterator<number>;
      values(): IterableIterator<XRInputSource>;
      [Symbol.iterator](): IterableIterator<XRInputSource>;
  }

}
declare module '@transmutejs/runtime/xsml/webxr/session' {
  /// <reference types="babylonjs" />
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  export class XRSessionImpl extends EventTarget implements XRSession {
      #private;
      inputSources: XRInputSourceArray;
      renderState: XRRenderState;
      visibilityState: XRVisibilityState;
      baseLayer: XRWebGLLayer;
      depthNear: number;
      depthFar: number;
      depthUsage: XRDepthUsage;
      depthDataFormat: XRDepthDataFormat;
      environmentBlendMode: XREnvironmentBlendMode;
      enabledFeatures: string[];
      constructor(document: XSMLDocument);
      trySetMeshDetectorEnabled(enabled: boolean): boolean;
      trySetFeaturePointCloudEnabled(enabled: boolean): boolean;
      trySetPreferredMeshDetectorOptions(preferredOptions: XRGeometryDetectorOptions): boolean;
      trySetPreferredPlaneDetectorOptions(preferredOptions: XRGeometryDetectorOptions): boolean;
      onend: XRSessionEventHandler;
      onframeratechange: XRSessionEventHandler;
      oninputsourceschange: XRInputSourceChangeEventHandler;
      onselect: XRInputSourceEventHandler;
      onselectend: XRInputSourceEventHandler;
      onselectstart: XRInputSourceEventHandler;
      onsqueeze: XRInputSourceEventHandler;
      onsqueezeend: XRInputSourceEventHandler;
      onsqueezestart: XRInputSourceEventHandler;
      onvisibilitychange: XRSessionEventHandler;
      updateTargetFrameRate(_rate: number): Promise<void>;
      updateRenderState(_renderStateInit?: XRRenderStateInit): Promise<void>;
      requestAnimationFrame(callback: XRFrameRequestCallback): number;
      requestHitTest?: (ray: XRRay, referenceSpace: XRReferenceSpace) => Promise<XRHitResult[]>;
      requestHitTestSource?: (options: XRHitTestOptionsInit) => Promise<XRHitTestSource>;
      requestHitTestSourceForTransientInput?: (options: XRTransientInputHitTestOptionsInit) => Promise<XRTransientInputHitTestSource>;
      requestLightProbe(_options?: XRLightProbeInit): Promise<XRLightProbe>;
      requestReferenceSpace(_type: XRReferenceSpaceType): Promise<XRReferenceSpace | XRBoundedReferenceSpace>;
      cancelAnimationFrame(id: number): void;
      end(): Promise<void>;
  }

}
declare module '@transmutejs/runtime/xsml/webxr/system' {
  /// <reference types="babylonjs" />
  import { XSMLDocument } from '@transmutejs/runtime/xsml/document';
  import { XRSessionImpl } from '@transmutejs/runtime/xsml/webxr/session';
  export class XRSystemImpl extends EventTarget implements XRSystem {
      #private;
      constructor(document: XSMLDocument);
      requestSession(mode: XRSessionMode, _options?: XRSessionInit): Promise<XRSession>;
      isSessionSupported(mode: XRSessionMode): Promise<boolean>;
      ondevicechange: XRSystemDeviceChangeEventHandler;
      onsessiongranted: XRSystemSessionGrantedEventHandler;
      __getCurrentSession(): XRSessionImpl | null;
  }

}
declare module '@transmutejs/runtime' {
  import main = require('@transmutejs/runtime/xsml/webapis');
  export = main;
}